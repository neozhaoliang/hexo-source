--------------------------------------
title: 最小化有限状态机的 Hopcroft 算法（上）
tags: [算法, Automata, Python]
categories: 算法
--------------------------------------

关于有限状态机最小化的 Hopcroft 算法，我个人认为最好的参考资料是 [David Gries 的文章][^1]，写的非常清楚，读起来很舒服。

本文将介绍 Hopcroft 算法的证明，采用的是 Gries 的叙述方式。下一篇将介绍怎样用 Python 实现这个算法。


## 背景设定

-----------

一个确定的有限状态机（英文 Deterministic Finite Automaton，以下简称为 DFA）由如下 5 个要素组成：

+ 由一些状态组成的集合 $S$。
+ 由一些输入符号组成的集合 $\Sigma$。
+ 一个初始状态 $s$。
+ 由一些接受状态组成的 $S$ 的一个子集 $F$。$S\backslash F$ 中的状态叫做拒绝状态。$F$ 可以等于 $S$（即所有状态都是接受态），但不能是空集（否则这个自动机识别的语言是空集）。
+ 状态之间的一个转移函数 $\delta$。

顾名思义，有限状态机的意思就是状态的总数是有限的，即 $|S|<\infty$。确定的意思是，对任一状态 $x$ 和任一输入 $a$，要么 $\delta(x,a)$ 没有定义，要么存在唯一确定的状态 $y\in S$ 使得 $\delta(x,a)=y$。

有的书上（比如 [^2]）对 DFA 的定义中要求 $\delta(x,a)$ 总是等于 $S$ 中的某个唯一确定的状态，这和我们的定义其实本质上是一样的：在我们的定义中，如果某些时候 $\delta(x,a)$ 没有定义的话，那就新建一个拒绝态 $z$，把状态空间扩大为 $S\cup\{z\}$，并把所有没有定义的 $\delta(x,a)$ 统统指向 $z$ 即可。

如果两个 DFA 识别的语言完全相同，则称它俩是等价的。

对任何一个 DFA $A$，都存在唯一的一个与之等价的 DFA $A'$ 满足条件：在所有与 $A$ 等价的 DFA 中 $A'$ 所含的状态数目最少。这里唯一的含义是如果 $A'$ 和 $A''$ 都满足所述条件，则适当对状态重命名以后 $A'$ 和 $A''$ 完全相同。

我们的任务是，给定一个 DFA，求出与它等价的最小的 DFA。


--------------

## Hopcroft 算法

--------------

正常情况下我应该先介绍 Hopcroft 算法的思路，然后贴上伪代码，再叙述证明。但是这里采用另外一种叙述风格：从一些基本的事实出发，用简单的推理得出新的事实，在此基础上再用简单的推理再得出新的事实，层层递进，抽次剥茧，Hopcroft 算法就是显然的事情了。

> **定义 1**：设 $P = \{B_1,\ldots, B_m\}$ 是 $S$ 的一组子集，如果所有的 $B_i$ 两两之间互不相交而且它们的并等于 $S$，就称 $P$ 是 $S$ 的一个划分。

> **定义 2**：$S$ 的一个划分 $P=\{B_1,\ldots, B_m\}$ 如果满足如下两个条件，就称它是一个合法的划分：
    1. 任何 $B_i$ 要么都是接受态，要么都是拒绝态。
    2. 如果 $s,t$ 是两个等价的状态，则它俩属于同一个 $B_i$。

举个例子，设 $B_1=F$ 为所有的接受态组成的集合，$B_2=S\backslash F$ 为所有拒绝态组成的集合，则 $P=\{B_1, B_2\}$ 是一个合法的划分（这很显然）。

----------------------
我们的目的是把 $S$ 划分为等价类。即两个状态 $s,t$ 属于同一个 $B_i$ 当且仅当它俩等价。我们把这个特殊的划分简称为等价类划分。
----------------------

这个划分由如下的性质刻画：

> **引理 3**：$P=\{B_1,\ldots, B_m\}$ 是 $S$ 的等价类划分的充要条件是：1. $P$ 是合法的。2. 对任何 $B_i, B_j$ 和输入符号 $a$，$$s,t\in B_i,\quad \delta(s,a)\in B_j\Rightarrow\delta(t,a)\in B_j.$$

必要性的证明：等价类划分当然是合法的划分，因此条件 1 满足，下面来证明它也满足条件 2。用反证法，若不然，则存在 $s,t,B_i,B_j,a$ 满足：
$$s,t\in B_i,\quad \delta(s,a)\in B_j,\quad \delta(t,a)\notin B_j.$$
由于 $\delta(s,a)$ 和 $\delta(t,a)$ 一个属于 $B_j$ 一个不属于 $B_j$，因此它俩不可能等价（回忆合法划分的定义中的条件 2），所以存在输入 $x\in\Sigma^\ast$ 使得 $\delta(\delta(s,a),x)\in F$ 但 $\delta(\delta(t,a),x)\notin F$（或者反过来），从而 $\delta(s,ax)\in F,\delta(t,ax)\notin F$，这说明 $s,t$ 是不等价的，但是它俩同属于 $B_i$，这与等价类划分的定义矛盾。

充分性的证明：假设 1 和 2 成立，我们只要证明对任何 $s,t\in B_i$ 必有 $s,t$ 等价即可。显然对任何输入 $x$，$\delta(s,x)$ 和 $\delta(t,x)$ 总是属于同一个 $B_j$，而任何 $B_j$ 不能同时包含接受态和拒绝态，因此 $\delta(s,x)$ 和 $\delta(t,x)$ 要么都接受，要么都拒绝，即 $s,t$ 等价，引理 3 得证。

由引理 3 我们立刻得到一个可以帮助我们 "分离" 不等价的状态的方法：

> **引理 4**：设 $P=\{B_1,\ldots,B_m\}$ 是一个合法的划分，设 $s,t,B_i,B_j,a$ 使得
$$s,t\in B_i,\quad \delta(s,a)\in B_j,\quad \delta(t,a)\notin B_j.$$
则 $s,t$ 是不等价的状态。我们把集合 $B_i$ 分裂成如下两个子集：
$$B'=\{s\in B_i\ |\ \delta(s,a)\in B_j\},\quad B''=\{s\in B_i\ |\ \delta(s,a)\notin B_j\}$$
则得到的新的划分
$$P' = P -\{B_i\} + \{ B',B''\}$$
仍然是一个合法的划分。
此时我们称 $(B_j,a)$ 分裂 $B_i$。

现在我们就可以提出一个 "粗糙" 的最小化算法了：

```c
令 B_1 = F 以及 B_2 = S\F
while 存在 (B_i, B_j, a) 使得 (B_j,a) 分裂 B_i
    将 B_i 用分裂后得到的两个子集替换之
end
```

这个算法一定是在有限时间内结束的，这是因为每分裂一次，子集的个数就会增加 1，但是子集的个数不可能超过状态的总数，所以必然在某个时刻得到的划分无法再被细分，这时这个划分满足引理 3 的两个条件（注意根据引理 4 划分的合法性在整个执行过程中始终是保持的），因此必然就是我们要求的等价类划分。

我想你一定看到了这个算法的粗糙之处：在每次循环的时候，我们需要对所有的 $(B_i,B_j,a)$ 检查是否可以分裂，这其中可能包含了大量的重复检查，效率太低了，怎样简化它呢？

--------------------------------
我们需要避免重复那些已经做过的检查工作。
--------------------------------


-------------

## 更细致的分析

-------------

> 为了后面简化论述，我们采用这样的说法： 用 $(B_j,a)$ 检查当前划分 $P$，即指对 $P$ 的每个子集 $B$，判断 $(B_j,a)$ 是否可以分裂 $B$，可以的话就立刻把 $B$ 用分裂后得到的两个子集替换之。这个过程也简称为用 $(B_j,a)$ 检查。

注意到这样一个事情

> **引理 5**：假设划分 $P$ 中的所有子集都已经用 $(B_j,a)$ 检查过了（检查完后得到的是一个更细的划分 $P'$），那么以后就再也不需要用 $(B_j,a)$ 检查了。

这是因为用 $(B_j,a)$ 检查过后，每个子集 $B\in P'$ 都满足要么 $\delta(B,a)\in B_j$，要么 $\delta(B,a)\in B_j^c$。此后再出现的子集也都满足这一点，当然不可能被 $(B_j,a)$ 分裂了。

这是一个不错的简化，但是还不够好，下面这个引理比较难发现：

> **引理 6**：假设一个子集 $B$ 分裂成了 $B'$ 和 $B''$（怎么分裂的不用关心），则对任何输入 $a\in\Sigma$，从 $\{(B,a),(B',a),(B'',a)\}$ 中任选两个去检查当前划分，与使用全部三个去检查是等效的（即最终得到的划分相同）。

从 $\{(B,a),(B',a),(B'',a)\}$ 中任选两个有三种可能，我们只证明选择 $(B',a)$ 和 $(B'',a)$ 的情形，另外两种情形是类似的。

假设 $C$ 是用 $(B',a)$ 和 $(B'',a)$ 检查完当前划分以后，得到的任一子集，则有如下四种可能:

1. $\delta(C,a)\in B',\delta(C,a)\in B''$。
2. $\delta(C,a)\in B',\delta(C,a)\in (B'')^c$。
3. $\delta(C,a)\in (B')^c,\delta(C,a)\in B''$。
4. $\delta(C,a)\in (B')^c,\delta(C,a)\in (B'')^c$。

前三种情形说明 $\delta(C,a)\in B$，最后一种情形说明 $\delta(C,a)\in B^c$，总之 $\delta(C,a)$ 要么完全属于 $B$ 要么和 $B$ 不相交，即 $C$ 无法被 $(B,a)$ 分裂，所以再用 $(B,a)$ 检查是多余的。

由此我们立刻得到了

> **引理 7**：设初始划分为 $\{B_1=F,B_2=S\backslash F\}$，则对任何符号 $a\in\Sigma$，只要用 $(B_1,a)$ 或者 $(B_2,a)$ 其中之一去检查即可。

证明：在引理 6 中令 $B=S, B'=B_1, B''=B_2$ 即可。

这样我们就可以把前面的算法大大改进一步：用一个列表（或者集合、栈都行）$L$ 来维护需要进行的检查对 $(B_j,a)$。

注意: $L$ 的含义并不简单，哪些 $(B_j,a)$ 需要放在 $L$ 里？哪些不需要？怎样判断需不需要？我们后面会仔细说。

``` python
B_1:=F, B_2:=S\F, L=[]
for each input symbol a do
    if |B_1|<|B_2| then add (B_1,a) to L
    else add (B_2,a) to L

while L is not empty do
    pop one pair (B_j,a) from L
        check current partition wrt (B_j,a)
            for each B just splitted to B' and B'' in do
                for each input symbol c do
                    if (B,c) in L then
                        L =  L + (B',c) + (B'',c) - (B,c)
                    elif |B'|<|B''| then add (B',c) to L
                    else add (B'',c) to L
```

---------------

## $L$ 的准确含义

---------------

为什么要把这个单独放在一节来说呢？因为理解 $L$ 的含义是真正 Hopcroft 算法的非常关键的一步，但不幸的是我见到的所有文献（包括网页）都没有把它讲清楚，Gries 的文章如果你不仔细看的话，也不太可能理解得到位。

注意到 $L$ 和当前划分 $P$ 是同步地变化的：我们一边将 $P$ 划分得更细，一边在 $L$ 中添加/删除元素。但是 $L$ 和 $P$ 始终保持满足这样一个关系：

> **引理 8**：对任何 $B\in P$ 和 $a\in\Sigma$，如果 $(B,a)\notin L$，则永远也不需要用 $(B,a)$ 去检查。话句话说，任何时刻（直到算法结束）的划分 $P'$ 的每个元素都不能被 $(B,a)$ 分裂。

比如说在算法开始的时候 $P=\{B_1=F,B_2=S\backslash F\}$，如果某个 $a$ 使得 $(B_1,a)\notin L$，这说明必然有 $(B_2,a)\in L$，而根据引理 7，我们是不需要用 $(B_1,a)$ 去检查的，引理 8 的断言满足。

我们还需要说明在算法执行的过程中（即对 $L$ 进行添加/删除操作后）引理 8 断言依然是保持成立的。

我们从 $L$ 中弹出一个 $(B_j,a)$ 并用它检查当前划分 $L$。这一步结束后，$L$ 变成了 $L'=L-(B_j,a)$，$P$ 变成了某个更细的划分 $P'$。如果某 $(B,c)\notin L$，这有两种可能：$(B,c)\ne (B_j,a)$，那么这一步之前 $(B,c)$ 也不属于 $L$，我们永不需要它；如果 $(B,c)=(B_j,a)$，根据引理 5，我们此后不再需要用 $(B_j,a)$ 检查，因此 $(P',L')$ 满足引理 8 的断言。

然后我们对每个刚刚分裂了的 $B\in P$ 和 $c\in\Sigma$ 检查是否有 $(B,c)\in L$，如果有的话，就把 $L$ 变成 $L-(B,c)+(B',c)+(B'',c)$

---------------

## 算法性能分析

---------------

这里需要一些啰嗦的分析，但是不难，我就不再写了。可以参考 Gries 的文章。

---------------

## 参考文献
[^1]: D Gries. [Describing an algorithm by Hopcroft](http://link.springer.com/article/10.1007%2FBF00264025)

[^2]: Hopcroft, etc. Introduction to automata theory, languages, and computation.