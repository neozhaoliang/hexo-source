[{"ver":"0.1","info":{"id":"dtdSD4","date":"0","viewed":0,"name":"3D Kleinian group limit set ","username":"neozhaoliang","description":"3D Kleinian group limit set ","likes":0,"published":0,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sigmoid(float t) {\n\tfloat K = 1.0 - 1. / (1.0 + exp(-2.5));\n\tt -= 0.5;\n\tfloat  x = 1./(1.0+exp(-t*5.))-K;\n\treturn x / (1.0 - 2.0*K);\n}\n\n\nvec3 sigmoid3(vec3 t) {\n\treturn vec3(sigmoid(t.x), sigmoid(t.y), sigmoid(t.z));\n}\n\n\nvec4 bloom(vec2 pos, vec2 quality) {\n\tint samples = 9;\n\tvec4 sum = vec4(0);\n\tint diff = (samples - 1) / 2;\n\tvec2 sizeFactor = quality;\n\tfor (int x = -diff; x <= diff; x++) {\n\t\tfloat wx=float(x)/float(diff); wx=1.-wx*wx; wx=wx*wx;\n\t\tfor (int y = -diff; y <= diff; y++) {\n\t\t\tfloat wy=float(y)/float(diff); wy=1.-wy*wy; wy=wy*wy;\n\t\t\tvec2 offset = vec2(x, y) * sizeFactor;\n\t\t\tsum += texture(iChannel0, (pos+offset))*wx*wy;\n\t\t}\n\t}\n\treturn (sum / float(samples * samples)); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\tvec2 pixelsize = vec2(dFdx(uv.x), dFdy(uv.y)) * 6.58;\n\tvec4 tex = texture(iChannel0, uv);\n\tvec3 col = tex.xyz/ tex.a;\n\tvec4 b = bloom(uv, pixelsize);\n\tb = b / b.w;\n\tcol += 0.7331 * pow(b.xyz, vec3(5.22));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"WdGBz3","date":"1607739529","viewed":2608,"name":"Boyd-Maxwell 2D circle packing","username":"neozhaoliang","description":"Limit set of rank 4 hyperbolic Coxeter groups, drawn both on the boundary sphere and the stereo-projected plane.","likes":66,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nBoyd-Maxwell circle packings of hyperbolic Coxeter groups: rank 4/level 2 case\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor more information check the github repo:\n\n    https://github.com/neozhaoliang/Hyperbolic-Honeycombs\n\nRequired input:\n\nThe Coxeter diagram of a rank 4 Coxeter group G = <A, B, C, D>, with dihedral angles\nm_{s,t} in the order (AB, AC, AD, BC, BD, CD).\n\nNote:\n\n1. CD must be finite\n2. The triangle group <B, C, D> must be hyperbolic\n\nIf you see only a sphere and a small disk under it, try comment out `#define useMouseInvert` below.\n*/\n\n\n#define useMouseInvert\n\n#define shiny        5.\n\n\n//#define config      initLevel2Graph(float[6](4., 2., 7., 4., 2., 5.))\n//#define config      initLevel2Graph(float[6](3., 2., 2., 3., 2., 7.))\n//#define config      initLevel2Graph(float[6](3., 3., 2., 3., 2., 7.))\n//#define config      initLevel2Graph(float[6](4., 4., 4., 4., 4., 4.))\n//#define config      initLevel2Graph(float[6](2., 2., 7., inf, 3., 3.))\n//#define config      initLevel2Graph(float[6](3., 3., 2., 7., 2., 3.))\n#define config      initLevel2Graph(float[6](5., 2., 3., 4., 3., 3.))\n\n\nvec2 map(vec3 p) {\n    float d1 = sdSphere(p);\n    float d2 = sdPlane(p);\n    float id = (d1 < d2) ? 0.: 1.;\n    return vec2(min(d1, d2), id);\n}\n\n// standard scene normal\nvec3 getNormal(vec3 p) {\n    const vec2 e = vec2(0.0001, 0.);\n    return normalize(\n        vec3(\n            map(p + e.xyy).x - map(p  - e.xyy).x,\n            map(p + e.yxy).x - map(p  - e.yxy).x,\n            map(p + e.yyx).x - map(p  - e.yyx).x\n            )\n        );\n}\n\n// get the signed distance to an object and object id\nvec2 raymarch(in vec3 ro, in vec3 rd)\n{\n    float t = MIN_TRACE_DIST;\n    vec2 h;\n    for(int i=0; i<MAX_TRACE_STEPS; i++)\n    {\n        h = map(ro + t * rd);\n        if (h.x < PRECISION * (t*0.125+1.))\n            return vec2(t, h.y);\n\n        if (t > MAX_TRACE_DIST)\n            break;\n\n        t += h.x;\n    }\n    return vec2(-1.0);\n}\n\nfloat calcOcclusion(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.15 * float(i) / 4.0;\n        float d = map(p + h * n).x;\n        occ += (h - d) * sca;\n        sca *= 0.85;\n    }\n    return clamp(1.0 - occ, 0.2, 1.0);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k) {\n    float res = 1.0;\n    float t = tmin;\n    for (int i = 0; i < 20; i++) {\n        float h = map(ro + rd * t).x;\n        res = min(res, k * h / t);\n        t += clamp(h, 0.001, 0.1);\n        if (h < 0.0001 || t > tmax)\n            break;\n    }\n    return clamp(res, 0., 1.0);\n}\n\nvec3 getColor(vec3 ro, vec3 rd, vec3 pos, vec3 nor, vec3 lp, vec3 basecol) {\n    vec3 col = vec3(0.0);\n    vec3 ld = lp - pos;\n    float lDist = max(length(ld), .001);\n    ld /= lDist;\n    float ao = calcOcclusion(pos, nor);\n    float sh = softShadow(pos+0.001*nor, ld, 0.01, lDist, 8.);\n    float diff = clamp(dot(nor, ld), 0., 1.);\n    float atten = shiny / (1. + lDist * lDist * .001);\n    float spec = pow(max( dot( reflect(-ld, nor), -rd ), 0.0 ), 6.);\n    float fres = clamp(1.0 + dot(rd, nor), 0.0, 1.0);\n    col += basecol * diff;\n    col += basecol * vec3(.8, 1., 0.3) * spec * 4.;\n    col += basecol * vec3(1.2, 1., .8) * fres * fres * 2.;\n    col *= ao * atten * sh;\n    col += basecol * clamp(0.8 + 0.2 * nor.z, 0., 1.);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 scenecol = vec3(0.);\n\n// initialize the mirrors\n  \n    config;\n    \n    vec3 camera = vec3(4, 1.5, 4);\n    vec3 lp =  vec3(.5, .5, 4.); //light position\n    camera.xy = rot2d(camera.xy, iTime*0.3);\n    vec3 lookat  = vec3(0.);\n    vec3 up = vec3(0, 0, 1);\n    vec3 forward = normalize(lookat - camera);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    \n    float lw = 8. / iResolution.y;\n\n// antialiasing loop\n\n    for(int ii=0; ii<AA; ii++) {\n        for(int jj=0; jj<AA; jj++) {\n            vec2 o = vec2(float(ii), float(jj)) / float(AA);\n            vec2 uv = (2. * fragCoord + o - iResolution.xy) / iResolution.y;\n            vec3 rd = normalize(uv.x * right + uv.y * up + 1.5 * forward);\n            vec2 res = raymarch(camera, rd);\n            float t = res.x;\n            float id = res.y;\n            vec3 pos = camera + t * rd;\n\n            float ed;\n            vec3 col;\n            vec2 p0;\n            vec3 nor;\n\n            // the sphere is hit\n            if (id == 0.) {\n                nor = pos;\n                p0 = sphereToPlane(pos);\n            }\n            \n            // the plane is hit\n            else if (id == 1.) {\n                nor = vec3(0, 0, 1);\n                p0 = pos.xy;\n            }\n#ifdef useMouseInvert      \n            vec2 mouse = (iMouse.xy-2.*iResolution.xy)/iResolution.y;\n            if (iMouse.z == 0.)\n                mouse = vec2(1.5, 1.5);\n            mouse = rot2d(mouse, iTime*0.1);\n            float k = 1./L2(mouse);\n            vec2 invCtr = k * mouse;\n            float tt = (k - 1.) / L2(p0 -invCtr);\n            p0 = tt*p0 + (1. - tt)*invCtr;\n#endif\n            vec3 basecol = getcolor(p0, ed);\n            col = getColor(camera, rd, pos, nor, lp, basecol);\n            float dist = distanceToMirrors(p0) ;\n            col = mix(col, vec3(0.), 1.0 - exp(-0.01*t*t));\n            scenecol += col;\n        }\n    }\n    scenecol /= (float(AA) * float(AA));\n\n    fragColor = vec4(sqrt(max(scenecol, 0.0)), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define inf                 1.0     // Vinberg convention for edge labels\n#define MAX_REFLECTIONS     500\n#define AA                  2\n#define PI                  3.141592653\n#define L2(x)               dot(x, x)\n#define L2XY(x, y)          L2(x - y)\n#define Hyperbolic          -1.0\n#define Euclidean           0.\n#define Spherical           1.\n#define MAX_TRACE_STEPS     500\n#define MIN_TRACE_DIST      0.001\n#define MAX_TRACE_DIST      100.0\n#define PRECISION           0.0001\n#define EdgeSize1           0.0035 \n#define EdgeSize2           0.01\n#define ColorScale          0.8\n\n// Move a vertex of Euclidean type (if there is any) to infinity,\n// so the pattern tiles the entire plane\n#define moveVertexToInf\n\n// 4x4 Cartan matrix for the Coxeter group\nmat4 cartan;\n\n// geometry type of each vertex in the Coxeter diagram\n// -1 for hyerbolic, 0 for Euclidean, 1 for spherial\nvec4 vertexType = vec4(1);\n\n// coordinates of a Euclidean vertex\nvec2 euclideanVertex;\n\n// if we are outside of the unit circle\n// if a point lies outside of unit circle, the distance\n// estimation becomes inaccurate. We use EdgeSize2 to control the edge size for this case.\nbool outside = false;\n\n// if there is an Euclidean vertex, i.e. if remove this vertex, the remain diagram is affine\nbool hasEuclideanVertex;\n\n// compute cos(PI / x), for x = inf this is just inf\nfloat dihedral(float x) {\n    return x == inf ? inf : cos(PI / x);\n}\n\n// complex multiplication\nvec2 cmul(vec2 p, vec2 q) { return vec2(p.x*q.x-p.y*q.y, p.x*q.y+p.y*q.x); }\n\n\n// complex division\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y, -z.x * w.y + z.y * w.x) / dot(w, w);\n}\n\n// compute the vertex type of each vertex.\n// for each vertex in the Coxeter diagram, its vertex type is determined by the triangle group G formed by\n// the remaining three vertices. This vertex is of hyperbolic/spherical/euclidean iff G is\n// hyperbolic/spherical/euclidean, respectively.\n// This can be checked from the determinant of the leading minors of the Cartan matrix.\nvoid checkCartan(mat4 M) {\n    const float e = 0.001;\n    float det;\n    det = determinant(mat3(M[1].yzw, M[2].yzw, M[3].yzw));\n    vertexType.x = step(-e, det) + step(e, det) - 1.;\n        \n    det = determinant(mat3(M[0].xzw, M[2].xzw, M[3].xzw));\n    vertexType.y = step(-e, det) + step(e, det) - 1.;\n    \n    det = determinant(mat3(M[0].xyw, M[1].xyw, M[3].xyw));\n    vertexType.z = step(-e, det) + step(e, det) - 1.;\n    \n    det = determinant(mat3(M[0].xyz, M[1].xyz, M[2].xyz));\n    vertexType.w = step(-e, det) + step(e, det) - 1.;\n}\n\n\n// For spheres cen is the center, r is the radius\n// For planes cen is the normal vector, r is the offset from the origin along the normal. \n// if invert is true then the inside/outside of the sphere is exchanged.\nstruct Ball {\n    vec2 cen;\n    float r;\n    bool isplane;\n    bool invert;\n};\n\n\n// coclusters are mirror balls, they corresponde to root vectors (space-like)\nBall[4] coclusters;\n// clusters are real balls, they corresponde to space-like weight vectors\nBall[4] clusters;\n\n\n// create a default ball (unit circle)\nBall defaultBall() {\n    return Ball(vec2(0), 1., false, false);\n}\n\n\nBall from_plane(vec2 normal, float offset) {\n    return Ball(normal, offset, true, false);\n}\n\nBall from_sphere(vec2 cen, float r) {\n    return Ball(cen, r, false, false);\n}\n\nvoid invertBall(inout Ball B) {\n    B.invert = !B.invert;\n}\n\n\n// try to reflect a point p to the positive half space bounded by a ball\n// if we are already in the positive half space, do nothing and return true,\n// else reflect about the ball and return false\n// if B is a sphere we try to reflect p into the interior of B\nbool try_reflect(inout vec2 p, Ball B, inout int count, inout float scale) {\n    vec2 cen = B.cen;\n    float r = B.r;\n    if (B.isplane) {\n        float k = dot(vec3(p, 1), vec3(cen, r));\n        if (k >= 0.)\n            return true;\n        p -= 2. * k  * cen;\n        count += 1;\n        return false;\n    }\n    else {\n        vec2 q = p - cen;\n        float d2 = dot(q, q);\n        float k = (r * r) / d2;\n        if ( (k < 1.0 && B.invert) || (k > 1. && !B.invert) )\n            return true;\n        p = k * q + cen;\n        scale *= k;\n        count += 1;\n        return false;\n    }\n}\n\n\nvec2 getIntersection(Ball B1, Ball B2, Ball B3) {\n    vec2 dir = vec2(-B3.cen.y, B3.cen.x);\n    float r1 = B1.r, r2 = B2.r;\n    float k = (L2(B1.cen) - L2(B2.cen) - (r1*r1 - r2*r2)) / (2. * dot(B1.cen - B2.cen, dir));\n    return k*dir;\n}\n\nBall solveBall(Ball B1, Ball B2, Ball B3) {\n    vec2 dir = vec2(-B3.cen.y, B3.cen.x);\n    float r1 = B1.r, r2 = B2.r;\n    float k = (L2(B1.cen) - L2(B2.cen) - (r1*r1 - r2*r2)) / (2. * dot(B1.cen - B2.cen, dir));\n    vec2 cen = k * dir; \n    float r = sqrt(L2XY(cen, B1.cen) - r1*r1);\n    return from_sphere(cen, r);\n}\n\n\nfloat sdistanceToBall(vec2 p, Ball B) {\n    if (B.isplane) {\n        float k = dot(vec3(p, 1), vec3(B.cen, B.r));\n        return k;\n    }\n    else {\n        float k = length(p - B.cen) - B.r;\n        return B.invert ? -k : k;\n    }\n}\n\n\nvoid initLevel2Graph(in float[6] diagram) {\n    Ball B0, B1, B2, B3;\n    float c01 = dihedral(diagram[0]);\n    float c02 = dihedral(diagram[1]);\n    float c03 = dihedral(diagram[2]);\n    float c12 = dihedral(diagram[3]);\n    float c13 = dihedral(diagram[4]);\n    float c23 = dihedral(diagram[5]);\n    \n    cartan = mat4(1, -c01, -c02, -c03,\n                  -c01, 1, -c12, -c13,\n                  -c02, -c12, 1, -c23,\n                  -c03, -c13, -c23, 1);\n    checkCartan(cartan);\n    \n    float s23 = sqrt(1. - c23*c23);\n    \n    // The two virtual balls B2, B3 (reflection mirrors) are lines through the origin\n    B2 = from_plane(vec2(1, 0), 0.);\n    B3 = from_plane(vec2(-c23, s23), 0.);\n    \n    // The mirror ball B1(x, y, r) satisfy\n    // Angle with B2: dot((x, y), (1, 0)) / r = c12\n    // Angle with B3: dot((x, y), (-c23, s23)) / r = c13\n    // Orthogonal to the real ball (unit ball) C0: x^2 + y^2 = r^2 + 1\n    float k1 = c12;\n    float k2 = (c13 + c23*c12) / s23;\n    float r = 1. / sqrt(k1*k1 + k2*k2 - 1.);\n    \n    B1 = from_sphere(vec2(k1*r, k2*r), r);\n    \n    // The mirror ball B0(x, y, r) satisfy\n    // Angle with B2: dot((x, y), (1, 0)) / r = c02\n    // Angle with B3: dot((x, y), (-c23, s23)) / r = c03\n    // Angle with B1:\n    //\n    //        r^2 + r1^2 - |(x,y) - (x1,y1)|^2\n    //        --------------------------------  = -c01\n    //                   2 * r * r1\n    k1 = c02;\n    k2 = (c03 + c23*c02) / s23;\n    \n    float a = k1*k1 + k2*k2 - 1.;\n    float b = dot(vec3(k1, k2, c01), vec3(B1.cen, B1.r));\n    float c = L2(B1.cen) - B1.r*B1.r;\n    \n    r = b / a - sqrt(b*b - a*c) / a;\n    B0 = from_sphere(vec2(k1*r, k2*r), r);\n    \n    invertBall(B0);\n    invertBall(B1);\n    \n    coclusters = Ball[4] (B0, B1, B2, B3);\n    \n    for (int k = 0; k < 4; k++) {\n        clusters[k] = defaultBall();\n    }\n   \n    invertBall(clusters[0]);\n    \n    if (vertexType.y == Hyperbolic) {\n        float r = sqrt(L2(B0.cen) - B0.r*B0.r);\n        clusters[1] = from_sphere(vec2(0), r);\n    }\n    if (vertexType.z == Hyperbolic) {\n        clusters[2] = solveBall(B0, B1, B3);\n    }\n    if (vertexType.w == Hyperbolic) {\n        clusters[3] = solveBall(B0, B1, B2);\n    }\n    \n    if (vertexType.y == Euclidean) {\n        hasEuclideanVertex = true;\n        euclideanVertex = vec2(0);\n        return;\n    }\n        \n    if (vertexType.z == Euclidean) {\n        hasEuclideanVertex = true;\n        euclideanVertex = getIntersection(B0, B1, B3);\n        return;\n    }\n    \n    if (vertexType.w == Euclidean) {\n        hasEuclideanVertex = true;\n        euclideanVertex = getIntersection(B0, B1, B2);\n        return;\n    }\n}\n\nvec2 applyMobius(vec2 p) {\n    if (hasEuclideanVertex) {\n        vec2 A = euclideanVertex;\n        vec2 B = vec2(0, 0);\n        vec2 C = vec2(1, 0);\n        vec2 D = vec2(4, 0);\n        p = cdiv(cmul(p, A) + B, cmul(C, p) + D);\n    }\n    return p;\n}\n\n\nfloat distanceToMirrors(vec2 p) {\n    float d = abs(sdistanceToBall(p, coclusters[0]));\n    \n    if (length(p) > 1.) {\n        p /= L2(p);\n        outside = true;\n    }\n    \n    for (int k = 1; k < 4; k++) {\n         d = min(d, abs(sdistanceToBall(p, coclusters[k])));\n    }\n    return d;\n}\n\n\nvoid fold(inout vec2 p, inout int count, inout float scale, inout int index) {\n#ifdef moveVertexToInf\n    p = applyMobius(p);\n#endif\n    for (int i = 0; i < MAX_REFLECTIONS; i++) {\n        bool cond = true;\n        for (int k = 0; k < 4; k++) {\n            cond = try_reflect(p, coclusters[k], count, scale) && cond;\n        }\n        if (cond)\n            break;\n    }\n    for (int k = 0; k < 4; k++) {\n        if (vertexType[k] == Hyperbolic && sdistanceToBall(p, clusters[k]) < -0.0001) {\n            index = k;\n            break;\n        }\n    }\n}\n\n// signed distance to unit ball and plane z=-1\nfloat sdSphere(vec3 p) { return length(p) - 1.0; }\nfloat sdPlane(vec3 p) { return p.z + 1.0; }\n\n// project points on the unit ball to plabe z=-1\nvec2 sphereToPlane(vec3 p) {\n    return 2. * p.xy / (1. - p.z);\n}\n\n// 2d rotation\nvec2 rot2d(vec2 p, float a) { return p * cos(a) + vec2(-p.y, p.x) * sin(a); }\n\n// you can implement your color functions here\nvec3 colormap(int index, float t) {\n    float c = float(index) + 1.;\n    return .5 + .45*cos(2.*PI  * pow(t, 0.3) * ColorScale * c + vec3(0, 1, 2));\n}\n\nvec3 getcolor(inout vec2 p, out float ed) {\n    int index = -1;\n    int count = 0;\n    float scale = 1.;\n    fold(p, count, scale, index);\n    float dist = distanceToMirrors(p);\n    float t = clamp(float(count + 1) / float(MAX_REFLECTIONS), 0., 1.);\n    vec3 col = colormap(index, t);\n    float es = outside ? EdgeSize2 : EdgeSize1;\n    float aa = fwidth(dist) / 2.;\n    col = mix(col, vec3(0), 1. - smoothstep(es-aa, es+aa, dist));\n    return col;\n}\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"NdK3zy","date":"1631768030","viewed":1036,"name":"Boyd-Maxwell ball packings","username":"neozhaoliang","description":"Beautiful math produce beautiful images. This program draws 2d sections of 3d Boyd-Maxwell ball packings.","likes":27,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n2d slices of 3D Boyd-Maxwell Ball packings\n\nauthors: Chen Hao: https://num.math.uni-goettingen.de/~hchen/\n         Zhao Liang: https://twitter.com/neozhaoliang\n\nReference: see Hao's Ph.D thesis:\n\n    https://refubium.fu-berlin.de/bitstream/handle/fub188/1147/diss_haochen.pdf?sequence=1&isAllowed=y\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe name may sound unfamiliar to most people, but basically this is a kind of\nkaleidoscope structure in 4D hyperbolic space, we just draw their 2d slices here.\n\nFor a Coxeter group of rank 5 and level 2, the complement of its limit set form a dense\nball packing of the ideal boundary of hyperbolic 4-space, hence a ball packing of the\nEuclidean 3-space. We use z=c or y=c planes with varying c to see the circle packing patterns\non these slices.\n\n \nIn Hao's paper he listed out all Coxeter groups of level 2, the diagrams that\nhave 5 vertices with none of them surrounded by a blue box are all valid inputs for this program.\n\nUsage:\n\n1. Select a configuration below and uncomment it, or you can input one manually\n2. In common.frag, use `#define DrawLimitSet` to switch between the limit set view and circle packing view\n3. In common.frag, change `ZOOM` to zoom in/out.\n4. When drawing circle packings, use the bvec4 param 'isRealBall' to add/remove circles (explained below).\n5. In common.frag, use `#define DrawVerticalSections` to show vertical sections (suggested by @mla)\n\nExample:\n\nThis is a rank 5 group of level 2:\n     \n     v2\n     x\n       \\   5\n     |  o --- o --- x\n     | / v4   v1    v0\n     x\n     v3\n     \nEach vertex in the diagram represents a 'virtual mirror' in 3d space (a plane or a sphere),\nthe labels on the edges indicate the angles between the mirrors.\n\nA vertex drawn by `x` means it has a `real ball` correspondes to it,\nA vertex drawn by `o` means it does not have a real ball correspondes to it.\nThere are always 5 virtual balls and at least one real ball.\n\nIf we iteratively reflect the real balls across the virual balls, we will eventually get a dense packing of\nthe 3d space.\n\nThe set of virtual balls are called coclusters, the set of real balls are called clusters.\n\nYou can see there is a Euclidean triangle (333) in the diagram, this holds for almost all groups of rank 5 and level 2.\n\nThe input data requires you specify:\n\nparam 1:\n\nThe type of the Euclidean triangle, must be one of 244, 236 or 333. In this example it's 333.\nThese virual mirrors are labelled as v2, v3, v4.\n\n| For the remaining two vertices, at least one must be 'x', choose such one as v0. If both two are 'x',\n| choose either of them as v0, the remaining one is labelled v1.\n\nparam 2:\n\nThe labels between v0 and (v2, v3, v4), in this example it's (2, 2, 2) (in a Coxeter diagram\ndisjoint mirrors are orthogonal with each other, hence has dihedral angle PI/2, hence label 2)\n\nparam 3:\n\nThe labels between v1 and (v2, v3, v4), in this example it's (2, 2, 5). Note v1 and v4 are connected\nby an edge of label 5.\n\nparam 4:\n\nThe label between v0 and v1, in this example it's 3 (edges with labels 3 are represented by an unlabelled line)\n\nparam 5:\n\nFour bools indicate those virtual mirrors in (v1, v2, v3, v4) that have real balls corresponde to them.\nIn this example v2, v3 are represented by 'x', v1, v4 are represented by 'o', hence v2, v3 have real balls,\nwhile v1, v4 do not. So the four bools should be (false, true, true, false). Note by our choice v0 is\nalways 'x', so v0 has a real ball correspondes to it. This real ball is always the z=0 plane.\n\nSo the above diagram gives input\n\ninit(333, vec3(2, 2, 2), vec3(2, 2, 5), 3, bvec4(0, 1, 1, 0))\n\n\n!important:\n\nFor the 333 triangle, you can arbitrarily order them as (v2, v3, v4), it doesn't matter.\n\nBut for the 236 triangle, the ordering is fixed, you must label them as\n\n  6   3\n*---*---*\nv2  v3  v4\n\nAlso for the 244 triangle, the ordering must be\n\n  4   4\n*---*---*\nv2  v3  v4\n\n\nI have included ~60 examples below, a complete list would contain around ~180+ diagrams,\naccording to Hao's enumeration. You can find other diagrams in his thesis paper.\n\nNote: \n\n1. Some diagrams may give equivalent packings, though the visual effects are different.\n2. The bvec param 'isRealBall' does not take effect in the 'limit set' view in most times,\nit's mainly used for adding/removing circles in the circle packing view. You can change some\n1's in it to 0 to remove the corresponding real balls, hence produce holes in the pattern.\n*/\n\n\n//*****************************************************************************\n\n//#define config init(236, vec3(2, 2, 2), vec3(3, 2, 2), 5., bvec4(0))\n//#define config init(236, vec3(2, 2, 2), vec3(2, 2, 5), 3., bvec4(0, 0, 0, 0))\n//#define config init(236, vec3(2, 2, 2), vec3(3, 2, 2), 4., bvec4(0, 0, 0, 1))\n//#define config init(333, vec3(3, 3, 3), vec3(3, 3, 3), 3., bvec4(1, 1, 1, 1))\n//#define config init(333, vec3(3, 3, 2), vec3(2, 3, 3), 3., bvec4(1, 1, 0, 1))\n//#define config init(333, vec3(3, 2, 2), vec3(2, 3, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(4, 2, 2), vec3(2, 3, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(5, 2, 2), vec3(2, 3, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(2, 2, 5), vec3(2, 3, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(3, 2, 3), vec3(2, 3, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 5), vec3(2, 3, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 3), vec3(3, 3, 2), 5., bvec4(1, 1, 1, 1))\n//#define config init(333, vec3(2, 2, 3), vec3(3, 3, 2), 6., bvec4(1, 1, 1, 1))\n//#define config init(333, vec3(2, 3, 3), vec3(2, 3, 3), 2., bvec4(0, 0, 0, 1))\n//#define config init(244, vec3(2, 2, 2), vec3(2, 3, 2), 3., bvec4(0, 0, 0, 0))\n//#define config init(244, vec3(2, 3, 2), vec3(2, 4, 2), 2., bvec4(1, 1, 0, 1))\n//#define config init(244, vec3(2, 2, 2), vec3(2, 3, 2), 4., bvec4(0, 0, 0, 0))\n//#define config init(244, vec3(2, 2, 2), vec3(2, 3, 2), 5., bvec4(0, 1, 0, 1))\n//#define config init(236, vec3(2, 2, 2), vec3(2, 2, 3), 5., bvec4(0, 0, 0, 0))\n//#define config init(236, vec3(2, 2, 2), vec3(2, 2, 3), 6., bvec4(0, 1, 0, 0))\n//#define config init(244, vec3(3, 2, 2), vec3(2, 2, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(236, vec3(2, 2, 2), vec3(2, 3, 2), 4., bvec4(0, 0, 0, 1))\n//#define config init(333, vec3(3, 2, 2), vec3(2, 2, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(6, 2, 2), vec3(2, 2, 4), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(2, 2, 4), vec3(2, 2, 4), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 5), vec3(2, 2, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 6), vec3(2, 2, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 4), vec3(2, 2, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(2, 2, 3), vec3(2, 2, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(6, 2, 2), vec3(2, 2, 4), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(5, 2, 2), vec3(2, 2, 4), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(4, 2, 2), vec3(2, 2, 4), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(6, 2, 2), vec3(2, 2, 3), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(6, 2, 2), vec3(2, 2, 4), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(2, 2, 2), vec3(2, 2, 6), 3., bvec4(0, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 2), vec3(2, 2, 5), 3., bvec4(0, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 2), vec3(2, 2, 4), 4., bvec4(0, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 2), vec3(2, 2, 4), 3., bvec4(0, 0, 0, 0))\n//#define config init(236, vec3(2, 2, 3), vec3(3, 2, 6), 2., bvec4(1, 1, 1, 0))\n//#define config init(244, vec3(2, 2, 4), vec3(4, 2, 4), 2., bvec4(1, 1, 1, 0))\n//#define config init(244, vec3(2, 2, 3), vec3(4, 2, 4), 2., bvec4(1, 1, 1, 0))\n//#define config init(236, vec3(2, 2, 3), vec3(3, 2, 5), 2., bvec4(1, 1, 1, 0))\n//#define config init(236, vec3(2, 2, 4), vec3(3, 2, 4), 2., bvec4(1, 1, 1, 0))\n//#define config init(244, vec3(2, 2, 3), vec3(2, 3, 2), 5., bvec4(1, 1, 0, 1))\n//#define config init(244, vec3(2, 2, 2), vec3(3, 2, 4), 4., bvec4(0, 1, 1, 0))\n//#define config init(244, vec3(2, 4, 2), vec3(3, 2, 3), 2., bvec4(1, 1, 0, 1))\n//#define config init(236, vec3(2, 2, 6), vec3(3, 2, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(236, vec3(2, 2, 5), vec3(3, 2, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(236, vec3(3, 2, 2), vec3(2, 2, 6), 3., bvec4(1, 1, 1, 1))\n//#define config init(236, vec3(3, 2, 2), vec3(2, 2, 5), 3., bvec4(1, 1, 0, 1))\n//#define config init(236, vec3(3, 2, 2), vec3(2, 2, 4), 3., bvec4(1, 0, 0, 1))\n//#define config init(244, vec3(3, 2, 2), vec3(2, 2, 3), 3., bvec4(1, 0, 0, 0))\n//#define config init(244, vec3(3, 2, 2), vec3(2, 2, 3), 5., bvec4(1, 1, 1, 1))\n//#define config init(244, vec3(4, 2, 2), vec3(2, 2, 4), 4., bvec4(1, 1, 1, 1))\n//#define config init(244, vec3(3, 2, 2), vec3(2, 2, 3), 5., bvec4(1, 1, 1, 1))\n//#define config init(333, vec3(5, 2, 2), vec3(2, 2, 6), 3., bvec4(1, 1, 1, 1))\n//#define config init(244, vec3(4, 2, 4), vec3(4, 2, 4), 2., bvec4(1, 1, 1, 1))\n//#define config init(244, vec3(4, 2, 2), vec3(2, 2, 4), 4., bvec4(1, 1, 1, 1))\n//#define config init(236, vec3(2, 3, 2), vec3(3, 2, 4), 3., bvec4(1, 1, 0, 1))\n//#define config init(244, vec3(2, 2, 2), vec3(3, 2, 3), 4., bvec4(0))\n//#define config init(244, vec3(4, 2, 2), vec3(2, 2, 4), 4., bvec4(1, 1, 1, 1))\n#define config init(236, vec3(2, 2, 2), vec3(2, 3, 2), 5., bvec4(0, 0, 0, 1))\n\n\n//*****************************************************************************\n\nfloat map(vec2 p, inout int index) {\n    vec2 mouse = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float k = 1.0;\n    if (iMouse.z > 0.0) {\n        p -= mouse;\n        k = dot(p,p);\n        p /= k;\n        p += mouse;\n    }\n    const float strong_factor = 4.;\n#ifdef DrawVerticalSections\n    vec3 q = vec3(p.x, iTime*0.1, p.y + 1.);\n#else\n    vec3 q = vec3(p, mod(iTime*0.2 - 0.01, SECTION_HEIGHT - 0.02) + 0.01);\n#endif\n    return k*DE(q, index) * strong_factor;\n    \n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 post_process(vec3 col, vec2 uv) {\n  col = pow(clamp(col, 0., 1.), vec3(1.0/2.2)); \n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *= 0.5 + 0.5*pow(19.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.7);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    config;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 p = 2. * uv - 1.;\n    p.x *= iResolution.x / iResolution.y;\n    p *= ZOOM;\n    float aa  = 2.0 / clamp(iResolution.y, 400., 800.);\n\n    int index, cid;\n    \n    float d = map(p, index);\n    cid = index;\n    \n    \n    float b = -0.4;\n    float t = 10.0;\n    const float lh = 2.;\n    const vec3 lp = vec3(2.5, 2.5, lh);\n    \n    vec3 ro = vec3(0, 0, t);\n    vec3 pp = vec3(p, 0);\n    \n    vec3 rd = normalize(pp - ro);\n\n    vec3 ld = normalize(lp - pp);\n    \n    float bt = -(t-b)/rd.z;\n  \n    vec3  bp   = ro + bt*rd;\n    vec3  srd = normalize(lp - bp);\n    float bl = L2(lp - bp);\n\n    float st = (0.0-b)/srd.z;\n    vec3  sp = bp + srd*st;\n\n    float bd = map(bp.xy, index);\n    float sd = map(sp.xy, index);\n\n    vec3 col = vec3(0);\n    const float ss = 15.0;\n    col       += vec3(1.)  * (1.0 - exp(-ss*(max(sd, 0.0)))) / bl;\n    float l   = length(p);\n#ifdef DrawLimitSet\n    float hue = fract(0.75*l-0.3*iTime) + .45;\n#else\n    float hue = fract(0.15*l-0.3*iTime) + .5;\n#endif\n    float sat = .9*tanh(4.*l);\n    vec3 hsv  = vec3(hue, sat, 1.0);\n    vec3 bcol = hsv2rgb(hsv);\n    \n    col       *= (1.0-clamp(tanh(0.75*l), 0., .1)) * 1.3;\n\n#ifdef DrawLimitSet\n    col       = mix(col, vec3(1), smoothstep(-aa, aa, -d));\n#else\n    col       = mix(col, bcol, 1. - step(-d, aa));\n#endif\n    col       += 0.5*sqrt(bcol.zxy)*(exp(-(10.0+100.0*tanh(l))*max(d, 0.0)));\n    \n    col = post_process(col, uv);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_ITER         30\n#define PI               3.141592653\n#define L2(x)            dot(x, x)\n#define ZOOM             3.\n#define inf              -1.\n\n// comment out this to show the circles\n#define DrawLimitSet\n\n\n// uncomment this to show the vertice sections\n//#define DrawVerticalSections\n\nfloat dihedral(float x) {\n    return x == inf ? 1. : cos(PI / x);\n}\n\nvec3 dihedral(vec3 v) {\n    return vec3(dihedral(v.x), dihedral(v.y), dihedral(v.z));\n}\n\nfloat SECTION_HEIGHT;\n\n// For spheres n is the center, r is the radius\n// For planes n is the normal vector, r is the distance between the plane and the origin\n// if invert is true then the inside/outside of the sphere is interchanged (not used in this program)\n// if hasRealBall is true then this virtual ball has a real ball correspondes to it\nstruct Ball {\n    bool isplane;\n    vec3 n;\n    float r;\n    bool invert;\n    bool isRealBall;\n};\n\n// coclusters are mirror balls, they corresponde to root vectors (space-like)\nBall[5] coclusters;\n// clusters are real balls, they corresponde to space-like weight vectors\nBall[5] clusters;\n\n\n// create a ball. by default it's the z=0 plane with normal points to the negative half\nBall defaultBall() {\n    return Ball(false, vec3(0, 0, -1), 0., false, false);\n}\n\n// Distance from a point to a ball\nfloat sdistanceToBall(vec3 p, Ball B) {\n    if (B.isplane) {\n        float k = dot(vec4(p, 1), vec4(B.n, B.r));\n        return k;\n    }\n    else\n        return length(p - B.n) - B.r;\n}\n\nBall from_plane(vec3 n, float d) {\n    return Ball(true, n, d, false, false);\n}\n\nBall from_sphere(vec3 cen, float r) {\n    return Ball(false, cen, r, false, false);\n}\n\nvoid invertBall(inout Ball B) {\n    B.invert = !B.invert;\n}\n\n// try to reflect a point p to the positive half space bounded by a ball\n// if we are already in the positive half space, do nothing and return true,\n// else reflect about the ball and return false\n// if B is a sphere we try to reflect p into the interior of B\nbool try_reflect(inout vec3 p, Ball B, inout float scale) {\n    if (B.isplane) {\n        float k = dot(vec4(p, 1), vec4(B.n, B.r));\n        if (k >= 0.)\n            return true;\n        p -= 2. * k  * B.n;\n        return false;\n    }\n    else {\n        vec3 cen = B.n;\n        float r = B.r;\n        vec3 q = p - cen;\n        float d2 = dot(q, q);\n        float k = (r * r) / d2;\n        if ( (k < 1.0 && B.invert) || (k > 1. && !B.invert) )\n            return true;\n        p = k * q + cen;\n        scale *= k;\n        return false;\n    }\n}\n\n// return distance to the scene, and get the index of the real ball hitted\nfloat DE(vec3 p, inout int index) {\n    float scale = 3.;\n    for (int i = 0; i < MAX_ITER; i++) {\n        bool cond = true;\n        for (int k = 0; k < 5; k++) {\n            cond = try_reflect(p, coclusters[k], scale) && cond;\n        }\n\n        if (cond)\n            break;\n    }\n    index = 0;\n#ifdef DrawLimitSet\n    float d = abs(p.z);\n    for (int j = 1; j < 5; j++) {\n        if (clusters[j].isRealBall) {\n            float d1 = abs(sdistanceToBall(p, clusters[j]));\n            if (d1 < d) { d = d1; index = j; }\n        }\n    }\n#else\n    float d = p.z;\n    for (int j = 1; j < 5; j++) {\n        if (clusters[j].isRealBall) {\n            float d1 = sdistanceToBall(p, clusters[j]);\n            if (d1 < d) { d = d1; index = j; }\n        }\n    }\n    \n#endif\n    return d / scale;\n}\n\n// solve M*v = b, where v = (x, y, r) is the xy-coordinate of the center of the ball,\n// r is the radius of the ball.\nBall solveBall(mat3 M, vec3 b) {\n    vec3 p = b * inverse(M);\n    return from_sphere(vec3(p.xy, 0.), p.z);\n}\n\n// Solve a ball with its center has xy-coordinates P, and is orthogonal to other two Balls B0, B1.\n// Here B0 may be either a sphere or a plane, B1 is always a sphere. \nBall solveBall(vec2 P, Ball B0, Ball B1) {\n    if (B0.isplane) {\n        float z = B0.r;\n        vec3 cen = vec3(P, z);\n        float R = sqrt(L2(cen - B1.n) - B1.r*B1.r);\n        return from_sphere(cen, R);\n    }\n    else {\n        float r1 = B1.r;\n        float r0 = B0.r;\n        float z0 = B0.n.z;\n        float k0 = L2(P - B0.n.xy);\n        float k1 = L2(P - B1.n.xy);\n        float z = (r1*r1 - r0*r0 + z0*z0 + k0 - k1) / (2.*z0);\n        float R = sqrt(k1 + z*z - r1*r1);\n        return from_sphere(vec3(P, z), R);\n    }\n    \n}\n\n// triangleType: must be one of 236, 244 or 333\n// dihedralAngles0: labels of the edges between v0 and (v2, v3, v4)\n// dihedralAngles1: labels of the edges between v1 and (v2, v3, v4)\n// dihedralAngles0_1: label of the edge between (v0, v1)\n// isRealBall: specify which of (v1, v2, v3, v4) has real balls\nvoid init(int triangleType,\n          vec3 dihedralAngles0,\n          vec3 dihedralAngles1,\n          float dihedralAngle0_1,\n          bvec4 isRealBall) {\n    const float s2 = sqrt(2.);\n    const float s3 = sqrt(3.);\n    mat3 M0, M1;\n    vec3 b;\n    Ball B0, B1, B2, B3, B4;\n    vec3 t0 = dihedral(dihedralAngles0);\n    vec3 t1 = dihedral(dihedralAngles1);\n    float t01 = dihedral(dihedralAngle0_1);\n    // A, B, C are the vertices of the triangle formed by mirror plane v2, v3, v4 and z=0 plane\n    vec2 A, B, C;\n\n    // the 236 case\n    if (triangleType == 236) {\n        A = vec2(0, 0), B = vec2(0, s3), C = vec2(1, 0);\n        B2 = from_plane(vec3(1, 0, 0), 0.);\n        B3 = from_plane(vec3(-s3/2., -0.5, 0), s3/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(1, 0, -t1.x), vec3(s3/2., 0.5, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(1, 0, -t0.x), vec3(s3/2., 0.5, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(0, s3/2., 0);\n    }\n    \n    // the 244 case\n    else if (triangleType == 244) {\n        A = vec2(0, 0), B = vec2(0, 1), C = vec2(1, 0);\n        B2 = from_plane(vec3(1, 0, 0), 0.);\n        B3 = from_plane(vec3(-s2/2., -s2/2., 0), s2/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(1, 0, -t1.x), vec3(1./s2, 1./s2, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(1, 0, -t0.x), vec3(1./s2, 1./s2, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(0, s2/2., 0);\n    }\n    \n    // the 333 case\n    else {\n        A = vec2(-1, 0), B = vec2(0, s3), C = vec2(1, 0);\n        B2 = from_plane(vec3(s3/2., -.5, 0), s3/2.);\n        B3 = from_plane(vec3(-s3/2., -.5, 0), s3/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(-s3/2., 0.5, t1.x), vec3(s3/2., .5, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(-s3/2., 0.5, t0.x), vec3(s3/2., .5, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(s3, s3, 0)/2.;\n    }\n    \n    // now we solve the virtual ball B1, this can't be a plane\n    B1 = solveBall(M1, b);\n    invertBall(B1);\n    \n    // now we solve the virtual ball B0, this can be either a plane or a sphere\n    // this depends on if all entries in dihedralAngles0 are all 2\n    if (dot(dihedralAngles0, vec3(1)) == 6.) {\n        B0 = from_plane(vec3(0, 0, -1), B1.r*t01);\n    }\n    else {\n        B0 = solveBall(M0, b);\n        float r1 = B1.r, r0 = B0.r;\n        B0.n.z = sqrt(r0*r0 + r1*r1 + 2.*r0*r1*t01 - L2(B1.n.xy - B0.n.xy));\n        invertBall(B0);\n    }\n    coclusters = Ball[5] (B0, B1, B2, B3, B4);\n    \n    SECTION_HEIGHT = B0.isplane ? 2.*B0.r : B0.n.z;\n    \n    //now we process the real balls\n    for (int k = 0; k < 5; k++)\n        clusters[k] = defaultBall();\n        \n    if (isRealBall.x) {\n        clusters[1] = from_plane(vec3(0, 0, -1.), B0.n.z);\n        clusters[1].isRealBall = true;\n    }\n    if (isRealBall.y) {\n        clusters[2] = solveBall(C, B0, B1);\n        clusters[2].isRealBall = true;\n    }\n    if (isRealBall.z) {\n        clusters[3] = solveBall(A, B0, B1);\n        clusters[3].isRealBall = true;\n    }\n   \n    if (isRealBall.w) {\n        clusters[4] = solveBall(B, B0, B1);\n        clusters[4].isRealBall = true;\n    }\n}\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"DdVBWW","date":"0","viewed":0,"name":"Fork Boyd-Maxwe neozhaolia 124","username":"neozhaoliang","description":"Limit set of rank 4 hyperbolic Coxeter groups, drawn both on the boundary sphere and the stereo-projected plane.","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nBoyd-Maxwell circle packings and limit set of hyperbolic Coxeter groups: rank 4/level 2 case\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor more information check the github repo:\n\n    https://github.com/neozhaoliang/Hyperbolic-Honeycombs\n\nRequired input:\n\nThe Coxeter diagram of a rank 4 Coxeter group G = <A, B, C, D>, with dihedral angles\nm_{s,t} in the order (AB, AC, AD, BC, BD, CD).\n\nNote:\n\n1. CD must be finite\n2. The triangle group <B, C, D> must be hyperbolic\n\nIf you see only a sphere and a small disk under it, try comment out `#define useMouseInvert` below.\n*/\n\n\n#define useMouseInvert\n\n#define shiny        5.\n\n\n//#define config      initLevel2Graph(float[6](4., 2., 7., 4., 2., 5.))\n//#define config      initLevel2Graph(float[6](3., 2., 2., 3., 2., 7.))\n//#define config      initLevel2Graph(float[6](3., 3., 2., 3., 2., 7.))\n//#define config      initLevel2Graph(float[6](4., 4., 4., 4., 4., 4.))\n//#define config      initLevel2Graph(float[6](2., 2., 7., inf, 3., 3.))\n//#define config      initLevel2Graph(float[6](3., 3., 2., 7., 2., 3.))\n#define config      initLevel2Graph(float[6](5., 2., 3., 4., 3., 3.))\n\n\nvec2 map(vec3 p) {\n    float d1 = sdSphere(p);\n    float d2 = sdPlane(p);\n    float id = (d1 < d2) ? 0.: 1.;\n    return vec2(min(d1, d2), id);\n}\n\n// standard scene normal\nvec3 getNormal(vec3 p) {\n    const vec2 e = vec2(0.0001, 0.);\n    return normalize(\n        vec3(\n            map(p + e.xyy).x - map(p  - e.xyy).x,\n            map(p + e.yxy).x - map(p  - e.yxy).x,\n            map(p + e.yyx).x - map(p  - e.yyx).x\n            )\n        );\n}\n\n// get the signed distance to an object and object id\nvec2 raymarch(in vec3 ro, in vec3 rd)\n{\n    float t = MIN_TRACE_DIST;\n    vec2 h;\n    for(int i=0; i<MAX_TRACE_STEPS; i++)\n    {\n        h = map(ro + t * rd);\n        if (h.x < PRECISION * (t*0.125+1.))\n            return vec2(t, h.y);\n\n        if (t > MAX_TRACE_DIST)\n            break;\n\n        t += h.x;\n    }\n    return vec2(-1.0);\n}\n\nfloat calcOcclusion(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.15 * float(i) / 4.0;\n        float d = map(p + h * n).x;\n        occ += (h - d) * sca;\n        sca *= 0.85;\n    }\n    return clamp(1.0 - occ, 0.2, 1.0);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k) {\n    float res = 1.0;\n    float t = tmin;\n    for (int i = 0; i < 20; i++) {\n        float h = map(ro + rd * t).x;\n        res = min(res, k * h / t);\n        t += clamp(h, 0.001, 0.1);\n        if (h < 0.0001 || t > tmax)\n            break;\n    }\n    return clamp(res, 0., 1.0);\n}\n\nvec3 getColor(vec3 ro, vec3 rd, vec3 pos, vec3 nor, vec3 lp, vec3 basecol) {\n    vec3 col = vec3(0.0);\n    vec3 ld = lp - pos;\n    float lDist = max(length(ld), .001);\n    ld /= lDist;\n    float ao = calcOcclusion(pos, nor);\n    float sh = softShadow(pos+0.001*nor, ld, 0.01, lDist, 8.);\n    float diff = clamp(dot(nor, ld), 0., 1.);\n    float atten = shiny / (1. + lDist * lDist * .001);\n    float spec = pow(max( dot( reflect(-ld, nor), -rd ), 0.0 ), 6.);\n    float fres = clamp(1.0 + dot(rd, nor), 0.0, 1.0);\n    col += basecol * diff;\n    col += basecol * vec3(.8, 1., 0.3) * spec * 4.;\n    col += basecol * vec3(1.2, 1., .8) * fres * fres * 2.;\n    col *= ao * atten * sh;\n    col += basecol * clamp(0.8 + 0.2 * nor.z, 0., 1.);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 scenecol = vec3(0.);\n\n// initialize the mirrors\n  \n    config;\n    \n    vec3 camera = vec3(4, 1.5, 4);\n    vec3 lp =  vec3(.5, .5, 4.); //light position\n    camera.xy = rot2d(camera.xy, iTime*0.3);\n    vec3 lookat  = vec3(0.);\n    vec3 up = vec3(0, 0, 1);\n    vec3 forward = normalize(lookat - camera);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    \n    float lw = 8. / iResolution.y;\n\n// antialiasing loop\n\n    for(int ii=0; ii<AA; ii++) {\n        for(int jj=0; jj<AA; jj++) {\n            vec2 o = vec2(float(ii), float(jj)) / float(AA);\n            vec2 uv = (2. * fragCoord + o - iResolution.xy) / iResolution.y;\n            vec3 rd = normalize(uv.x * right + uv.y * up + 1.5 * forward);\n            vec2 res = raymarch(camera, rd);\n            float t = res.x;\n            float id = res.y;\n            vec3 pos = camera + t * rd;\n\n            float ed;\n            vec3 col;\n            vec2 p0;\n            vec3 nor;\n\n            // the sphere is hit\n            if (id == 0.) {\n                nor = pos;\n                p0 = sphereToPlane(pos);\n            }\n            \n            // the plane is hit\n            else if (id == 1.) {\n                nor = vec3(0, 0, 1);\n                p0 = pos.xy;\n            }\n#ifdef useMouseInvert      \n            vec2 mouse = (iMouse.xy-2.*iResolution.xy)/iResolution.y;\n            if (iMouse.z == 0.)\n                mouse = vec2(1.5, 1.5);\n            mouse = rot2d(mouse, iTime*0.1);\n            float k = 1./L2(mouse);\n            vec2 invCtr = k * mouse;\n            float tt = (k - 1.) / L2(p0 -invCtr);\n            p0 = tt*p0 + (1. - tt)*invCtr;\n#endif\n            vec3 basecol = getcolor(p0, ed);\n            col = getColor(camera, rd, pos, nor, lp, basecol);\n            float dist = distanceToMirrors(p0) ;\n            col = mix(col, vec3(0.), 1.0 - exp(-0.01*t*t));\n            scenecol += col;\n        }\n    }\n    scenecol /= (float(AA) * float(AA));\n\n    fragColor = vec4(sqrt(max(scenecol, 0.0)), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define inf                 1.0     // Vinberg convention for edge labels\n#define MAX_REFLECTIONS     500\n#define AA                  2\n#define PI                  3.141592653\n#define L2(x)               dot(x, x)\n#define L2XY(x, y)          L2(x - y)\n#define Hyperbolic          -1.0\n#define Euclidean           0.\n#define Spherical           1.\n#define MAX_TRACE_STEPS     500\n#define MIN_TRACE_DIST      0.001\n#define MAX_TRACE_DIST      100.0\n#define PRECISION           0.0001\n#define EdgeSize1           0.0035 \n#define EdgeSize2           0.01\n#define ColorScale          0.8\n\n// Move a vertex of Euclidean type (if there is any) to infinity,\n// so the pattern tiles the entire plane\n#define moveVertexToInf\n\n// 4x4 Cartan matrix for the Coxeter group\nmat4 cartan;\n\n// geometry type of each vertex in the Coxeter diagram\n// -1 for hyerbolic, 0 for Euclidean, 1 for spherial\nvec4 vertexType = vec4(1);\n\n// coordinates of a Euclidean vertex\nvec2 euclideanVertex;\n\n// if we are outside of the unit circle\n// if a point lies outside of unit circle, the distance\n// estimation becomes inaccurate. We use EdgeSize2 to control the edge size for this case.\nbool outside = false;\n\n// if there is an Euclidean vertex, i.e. if remove this vertex, the remain diagram is affine\nbool hasEuclideanVertex;\n\n// compute cos(PI / x), for x = inf this is just inf\nfloat dihedral(float x) {\n    return x == inf ? inf : cos(PI / x);\n}\n\n// complex multiplication\nvec2 cmul(vec2 p, vec2 q) { return vec2(p.x*q.x-p.y*q.y, p.x*q.y+p.y*q.x); }\n\n\n// complex division\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y, -z.x * w.y + z.y * w.x) / dot(w, w);\n}\n\n// compute the vertex type of each vertex.\n// for each vertex in the Coxeter diagram, its vertex type is determined by the triangle group G formed by\n// the remaining three vertices. This vertex is of hyperbolic/spherical/euclidean iff G is\n// hyperbolic/spherical/euclidean, respectively.\n// This can be checked from the determinant of the leading minors of the Cartan matrix.\nvoid checkCartan(mat4 M) {\n    const float e = 0.001;\n    float det;\n    det = determinant(mat3(M[1].yzw, M[2].yzw, M[3].yzw));\n    vertexType.x = step(-e, det) + step(e, det) - 1.;\n        \n    det = determinant(mat3(M[0].xzw, M[2].xzw, M[3].xzw));\n    vertexType.y = step(-e, det) + step(e, det) - 1.;\n    \n    det = determinant(mat3(M[0].xyw, M[1].xyw, M[3].xyw));\n    vertexType.z = step(-e, det) + step(e, det) - 1.;\n    \n    det = determinant(mat3(M[0].xyz, M[1].xyz, M[2].xyz));\n    vertexType.w = step(-e, det) + step(e, det) - 1.;\n}\n\n\n// For spheres cen is the center, r is the radius\n// For planes cen is the normal vector, r is the offset from the origin along the normal. \n// if invert is true then the inside/outside of the sphere is exchanged.\nstruct Ball {\n    vec2 cen;\n    float r;\n    bool isplane;\n    bool invert;\n};\n\n\n// coclusters are mirror balls, they corresponde to root vectors (space-like)\nBall[4] coclusters;\n// clusters are real balls, they corresponde to space-like weight vectors\nBall[4] clusters;\n\n\n// create a default ball (unit circle)\nBall defaultBall() {\n    return Ball(vec2(0), 1., false, false);\n}\n\n\nBall from_plane(vec2 normal, float offset) {\n    return Ball(normal, offset, true, false);\n}\n\nBall from_sphere(vec2 cen, float r) {\n    return Ball(cen, r, false, false);\n}\n\nvoid invertBall(inout Ball B) {\n    B.invert = !B.invert;\n}\n\n\n// try to reflect a point p to the positive half space bounded by a ball\n// if we are already in the positive half space, do nothing and return true,\n// else reflect about the ball and return false\n// if B is a sphere we try to reflect p into the interior of B\nbool try_reflect(inout vec2 p, Ball B, inout int count, inout float scale) {\n    vec2 cen = B.cen;\n    float r = B.r;\n    if (B.isplane) {\n        float k = dot(vec3(p, 1), vec3(cen, r));\n        if (k >= 0.)\n            return true;\n        p -= 2. * k  * cen;\n        count += 1;\n        return false;\n    }\n    else {\n        vec2 q = p - cen;\n        float d2 = dot(q, q);\n        float k = (r * r) / d2;\n        if ( (k < 1.0 && B.invert) || (k > 1. && !B.invert) )\n            return true;\n        p = k * q + cen;\n        scale *= k;\n        count += 1;\n        return false;\n    }\n}\n\n\nvec2 getIntersection(Ball B1, Ball B2, Ball B3) {\n    vec2 dir = vec2(-B3.cen.y, B3.cen.x);\n    float r1 = B1.r, r2 = B2.r;\n    float k = (L2(B1.cen) - L2(B2.cen) - (r1*r1 - r2*r2)) / (2. * dot(B1.cen - B2.cen, dir));\n    return k*dir;\n}\n\nBall solveBall(Ball B1, Ball B2, Ball B3) {\n    vec2 dir = vec2(-B3.cen.y, B3.cen.x);\n    float r1 = B1.r, r2 = B2.r;\n    float k = (L2(B1.cen) - L2(B2.cen) - (r1*r1 - r2*r2)) / (2. * dot(B1.cen - B2.cen, dir));\n    vec2 cen = k * dir; \n    float r = sqrt(L2XY(cen, B1.cen) - r1*r1);\n    return from_sphere(cen, r);\n}\n\n\nfloat sdistanceToBall(vec2 p, Ball B) {\n    if (B.isplane) {\n        float k = dot(vec3(p, 1), vec3(B.cen, B.r));\n        return k;\n    }\n    else {\n        float k = length(p - B.cen) - B.r;\n        return B.invert ? -k : k;\n    }\n}\n\n\nvoid initLevel2Graph(in float[6] diagram) {\n    Ball B0, B1, B2, B3;\n    float c01 = dihedral(diagram[0]);\n    float c02 = dihedral(diagram[1]);\n    float c03 = dihedral(diagram[2]);\n    float c12 = dihedral(diagram[3]);\n    float c13 = dihedral(diagram[4]);\n    float c23 = dihedral(diagram[5]);\n    \n    cartan = mat4(1, -c01, -c02, -c03,\n                  -c01, 1, -c12, -c13,\n                  -c02, -c12, 1, -c23,\n                  -c03, -c13, -c23, 1);\n    checkCartan(cartan);\n    \n    float s23 = sqrt(1. - c23*c23);\n    \n    // The two virtuak balls B2, B3 are lines through the origin\n    B2 = from_plane(vec2(1, 0), 0.);\n    B3 = from_plane(vec2(-c23, s23), 0.);\n    \n    float k1 = c12;\n    float k2 = (c13 + c23*c12) / s23;\n    float r = 1. / sqrt(k1*k1 + k2*k2 - 1.);\n    \n    B1 = from_sphere(vec2(k1*r, k2*r), r);\n    \n    k1 = c02;\n    k2 = (c03 + c23*c02) / s23;\n    \n    float a = k1*k1 + k2*k2 - 1.;\n    float b = dot(vec3(k1, k2, c01), vec3(B1.cen, B1.r));\n    float c = L2(B1.cen) - B1.r*B1.r;\n    \n    r = b / a - sqrt(b*b - a*c) / a;\n    B0 = from_sphere(vec2(k1*r, k2*r), r);\n    \n    invertBall(B0);\n    invertBall(B1);\n    \n    coclusters = Ball[4] (B0, B1, B2, B3);\n    \n    for (int k = 0; k < 4; k++) {\n        clusters[k] = defaultBall();\n    }\n    \n   \n    invertBall(clusters[0]);\n    \n    if (vertexType.y == Hyperbolic) {\n        float r = sqrt(L2(B0.cen) - B0.r*B0.r);\n        clusters[1] = from_sphere(vec2(0), r);\n    }\n    if (vertexType.z == Hyperbolic) {\n        clusters[2] = solveBall(B0, B1, B3);\n    }\n    if (vertexType.w == Hyperbolic) {\n        clusters[3] = solveBall(B0, B1, B2);\n    }\n    \n    if (vertexType.y == Euclidean) {\n        hasEuclideanVertex = true;\n        euclideanVertex = vec2(0);\n        return;\n    }\n        \n    if (vertexType.z == Euclidean) {\n        hasEuclideanVertex = true;\n        euclideanVertex = getIntersection(B0, B1, B3);\n        return;\n    }\n    \n    if (vertexType.w == Euclidean) {\n        hasEuclideanVertex = true;\n        euclideanVertex = getIntersection(B0, B1, B2);\n        return;\n    }\n}\n\nvec2 applyMobius(vec2 p) {\n    if (hasEuclideanVertex) {\n        vec2 A = euclideanVertex;\n        vec2 B = vec2(0, 0);\n        vec2 C = vec2(1, 0);\n        vec2 D = vec2(4, 0);\n        p = cdiv(cmul(p, A) + B, cmul(C, p) + D);\n    }\n    return p;\n}\n\n\nfloat distanceToMirrors(vec2 p) {\n    float d = abs(sdistanceToBall(p, coclusters[0]));\n    \n    if (length(p) > 1.) {\n        p /= L2(p);\n        outside = true;\n    }\n    \n    for (int k = 1; k < 4; k++) {\n         d = min(d, abs(sdistanceToBall(p, coclusters[k])));\n    }\n    return d;\n}\n\n\nvoid fold(inout vec2 p, inout int count, inout float scale, inout int index) {\n#ifdef moveVertexToInf\n    p = applyMobius(p);\n#endif\n    for (int i = 0; i < MAX_REFLECTIONS; i++) {\n        bool cond = true;\n        for (int k = 0; k < 4; k++) {\n            cond = try_reflect(p, coclusters[k], count, scale) && cond;\n        }\n        if (cond)\n            break;\n    }\n    for (int k = 0; k < 4; k++) {\n        if (vertexType[k] == Hyperbolic && sdistanceToBall(p, clusters[k]) < -0.0001) {\n            index = k;\n            break;\n        }\n    }\n}\n\n// signed distance to unit ball and plane z=-1\nfloat sdSphere(vec3 p) { return length(p) - 1.0; }\nfloat sdPlane(vec3 p) { return p.z + 1.0; }\n\n// project points on the unit ball to plabe z=-1\nvec2 sphereToPlane(vec3 p) {\n    return 2. * p.xy / (1. - p.z);\n}\n\n// 2d rotation\nvec2 rot2d(vec2 p, float a) { return p * cos(a) + vec2(-p.y, p.x) * sin(a); }\n\n// you can implement your color functions here\nvec3 colormap(int index, float t) {\n    float c = float(index) + 1.;\n    return .5 + .45*cos(2.*PI  * pow(t, 0.3) * ColorScale * c + vec3(0, 1, 2));\n}\n\nvec3 getcolor(inout vec2 p, out float ed) {\n    int index = -1;\n    int count = 0;\n    float scale = 1.;\n    fold(p, count, scale, index);\n    float dist = distanceToMirrors(p);\n    float t = clamp(float(count + 1) / float(MAX_REFLECTIONS), 0., 1.);\n    vec3 col = colormap(index, t);\n    float es = outside ? EdgeSize2 : EdgeSize1;\n    float aa = fwidth(dist) / 2.;\n    col = mix(col, vec3(0), 1. - smoothstep(es-aa, es+aa, dist));\n    return col;\n}\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"cttfRn","date":"0","viewed":0,"name":"Fork Boyd-Maxwe neozhaolia 362","username":"neozhaoliang","description":"Beautiful math produce beautiful images. This program draws 2d sections of 3d Boyd-Maxwell ball packings.","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n2d slices of 3D Boyd-Maxwell Ball packings\n\nauthors: Chen Hao: https://num.math.uni-goettingen.de/~hchen/\n         Zhao Liang: https://twitter.com/neozhaoliang\n\nReference: see Hao's Ph.D thesis:\n\n    https://refubium.fu-berlin.de/bitstream/handle/fub188/1147/diss_haochen.pdf?sequence=1&isAllowed=y\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe name may sound unfamiliar to most people, but basically this is a kind of\nkaleidoscope structure in 4D hyperbolic space, we just draw their 2d slices here.\n\nFor a Coxeter group of rank 5 and level 2, the complement of its limit set form a dense\nball packing of the ideal boundary of hyperbolic 4-space, hence a ball packing of the\nEuclidean 3-space. We use z=c or y=c planes with varying c to see the circle packing patterns\non these slices.\n\n \nIn Hao's paper he listed out all Coxeter groups of level 2, the diagrams that\nhave 5 vertices with none of them surrounded by a blue box are all valid inputs for this program.\n\nUsage:\n\n1. Select a configuration below and uncomment it, or you can input one manually\n2. In common.frag, use `#define DrawLimitSet` to switch between the limit set view and circle packing view\n3. In common.frag, change `ZOOM` to zoom in/out.\n4. When drawing circle packings, use the bvec4 param 'isRealBall' to add/remove circles (explained below).\n5. In common.frag, use `#define DrawVerticalSections` to show vertical sections (suggested by @mla)\n\nExample:\n\nThis is a rank 5 group of level 2:\n     \n     v2\n     x\n       \\   5\n     |  o --- o --- x\n     | / v4   v1    v0\n     x\n     v3\n     \nEach vertex in the diagram represents a 'virtual mirror' in 3d space (a plane or a sphere),\nthe labels on the edges indicate the angles between the mirrors.\n\nA vertex drawn by `x` means it has a `real ball` correspondes to it,\nA vertex drawn by `o` means it does not have a real ball correspondes to it.\nThere are always 5 virtual balls and at least one real ball.\n\nIf we iteratively reflect the real balls across the virual balls, we will eventually get a dense packing of\nthe 3d space.\n\nThe set of virtual balls are called coclusters, the set of real balls are called clusters.\n\nYou can see there is a Euclidean triangle (333) in the diagram, this holds for almost all groups of rank 5 and level 2.\n\nThe input data requires you specify:\n\nparam 1:\n\nThe type of the Euclidean triangle, must be one of 244, 236 or 333. In this example it's 333.\nThese virual mirrors are labelled as v2, v3, v4.\n\n| For the remaining two vertices, at least one must be 'x', choose such one as v0. If both two are 'x',\n| choose either of them as v0, the remaining one is labelled v1.\n\nparam 2:\n\nThe labels between v0 and (v2, v3, v4), in this example it's (2, 2, 2) (in a Coxeter diagram\ndisjoint mirrors are orthogonal with each other, hence has dihedral angle PI/2, hence label 2)\n\nparam 3:\n\nThe labels between v1 and (v2, v3, v4), in this example it's (2, 2, 5). Note v1 and v4 are connected\nby an edge of label 5.\n\nparam 4:\n\nThe label between v0 and v1, in this example it's 3 (edges with labels 3 are represented by an unlabelled line)\n\nparam 5:\n\nFour bools indicate those virtual mirrors in (v1, v2, v3, v4) that have real balls corresponde to them.\nIn this example v2, v3 are represented by 'x', v1, v4 are represented by 'o', hence v2, v3 have real balls,\nwhile v1, v4 do not. So the four bools should be (false, true, true, false). Note by our choice v0 is\nalways 'x', so v0 has a real ball correspondes to it. This real ball is always the z=0 plane.\n\nSo the above diagram gives input\n\ninit(333, vec3(2, 2, 2), vec3(2, 2, 5), 3, bvec4(0, 1, 1, 0))\n\n\n!important:\n\nFor the 333 triangle, you can arbitrarily order them as (v2, v3, v4), it doesn't matter.\n\nBut for the 236 triangle, the ordering is fixed, you must label them as\n\n  6   3\n*---*---*\nv2  v3  v4\n\nAlso for the 244 triangle, the ordering must be\n\n  4   4\n*---*---*\nv2  v3  v4\n\n\nI have included ~60 examples below, a complete list would contain around ~180+ diagrams,\naccording to Hao's enumeration. You can find other diagrams in his thesis paper.\n\nNote: \n\n1. Some diagrams may give equivalent packings, though the visual effects are different.\n2. The bvec param 'isRealBall' does not take effect in the 'limit set' view in most times,\nit's mainly used for adding/removing circles in the circle packing view. You can change some\n1's in it to 0 to remove the corresponding real balls, hence produce holes in the pattern.\n*/\n\n\n//*****************************************************************************\n\n//#define config init(236, vec3(2, 2, 2), vec3(3, 2, 2), 5., bvec4(0))\n//#define config init(236, vec3(2, 2, 2), vec3(2, 2, 5), 3., bvec4(0, 0, 0, 0))\n//#define config init(236, vec3(2, 2, 2), vec3(3, 2, 2), 4., bvec4(0, 0, 0, 1))\n//#define config init(333, vec3(3, 3, 3), vec3(3, 3, 3), 3., bvec4(1, 1, 1, 1))\n//#define config init(333, vec3(3, 3, 2), vec3(2, 3, 3), 3., bvec4(1, 1, 0, 1))\n//#define config init(333, vec3(3, 2, 2), vec3(2, 3, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(4, 2, 2), vec3(2, 3, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(5, 2, 2), vec3(2, 3, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(2, 2, 5), vec3(2, 3, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(3, 2, 3), vec3(2, 3, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 5), vec3(2, 3, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 3), vec3(3, 3, 2), 5., bvec4(1, 1, 1, 1))\n//#define config init(333, vec3(2, 2, 3), vec3(3, 3, 2), 6., bvec4(1, 1, 1, 1))\n//#define config init(333, vec3(2, 3, 3), vec3(2, 3, 3), 2., bvec4(0, 0, 0, 1))\n//#define config init(244, vec3(2, 2, 2), vec3(2, 3, 2), 3., bvec4(0, 0, 0, 0))\n//#define config init(244, vec3(2, 3, 2), vec3(2, 4, 2), 2., bvec4(1, 1, 0, 1))\n//#define config init(244, vec3(2, 2, 2), vec3(2, 3, 2), 4., bvec4(0, 0, 0, 0))\n//#define config init(244, vec3(2, 2, 2), vec3(2, 3, 2), 5., bvec4(0, 1, 0, 1))\n//#define config init(236, vec3(2, 2, 2), vec3(2, 2, 3), 5., bvec4(0, 0, 0, 0))\n//#define config init(236, vec3(2, 2, 2), vec3(2, 2, 3), 6., bvec4(0, 1, 0, 0))\n//#define config init(244, vec3(3, 2, 2), vec3(2, 2, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(236, vec3(2, 2, 2), vec3(2, 3, 2), 4., bvec4(0, 0, 0, 1))\n//#define config init(333, vec3(3, 2, 2), vec3(2, 2, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(6, 2, 2), vec3(2, 2, 4), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(2, 2, 4), vec3(2, 2, 4), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 5), vec3(2, 2, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 6), vec3(2, 2, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 4), vec3(2, 2, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(2, 2, 3), vec3(2, 2, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(6, 2, 2), vec3(2, 2, 4), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(5, 2, 2), vec3(2, 2, 4), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(4, 2, 2), vec3(2, 2, 4), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(6, 2, 2), vec3(2, 2, 3), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(6, 2, 2), vec3(2, 2, 4), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(2, 2, 2), vec3(2, 2, 6), 3., bvec4(0, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 2), vec3(2, 2, 5), 3., bvec4(0, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 2), vec3(2, 2, 4), 4., bvec4(0, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 2), vec3(2, 2, 4), 3., bvec4(0, 0, 0, 0))\n//#define config init(236, vec3(2, 2, 3), vec3(3, 2, 6), 2., bvec4(1, 1, 1, 0))\n//#define config init(244, vec3(2, 2, 4), vec3(4, 2, 4), 2., bvec4(1, 1, 1, 0))\n//#define config init(244, vec3(2, 2, 3), vec3(4, 2, 4), 2., bvec4(1, 1, 1, 0))\n//#define config init(236, vec3(2, 2, 3), vec3(3, 2, 5), 2., bvec4(1, 1, 1, 0))\n//#define config init(236, vec3(2, 2, 4), vec3(3, 2, 4), 2., bvec4(1, 1, 1, 0))\n//#define config init(244, vec3(2, 2, 3), vec3(2, 3, 2), 5., bvec4(1, 1, 0, 1))\n//#define config init(244, vec3(2, 2, 2), vec3(3, 2, 4), 4., bvec4(0, 1, 1, 0))\n//#define config init(244, vec3(2, 4, 2), vec3(3, 2, 3), 2., bvec4(1, 1, 0, 1))\n//#define config init(236, vec3(2, 2, 6), vec3(3, 2, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(236, vec3(2, 2, 5), vec3(3, 2, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(236, vec3(3, 2, 2), vec3(2, 2, 6), 3., bvec4(1, 1, 1, 1))\n//#define config init(236, vec3(3, 2, 2), vec3(2, 2, 5), 3., bvec4(1, 1, 0, 1))\n//#define config init(236, vec3(3, 2, 2), vec3(2, 2, 4), 3., bvec4(1, 0, 0, 1))\n//#define config init(244, vec3(3, 2, 2), vec3(2, 2, 3), 3., bvec4(1, 0, 0, 0))\n//#define config init(244, vec3(3, 2, 2), vec3(2, 2, 3), 5., bvec4(1, 1, 1, 1))\n//#define config init(244, vec3(4, 2, 2), vec3(2, 2, 4), 4., bvec4(1, 1, 1, 1))\n//#define config init(244, vec3(3, 2, 2), vec3(2, 2, 3), 5., bvec4(1, 1, 1, 1))\n//#define config init(333, vec3(5, 2, 2), vec3(2, 2, 6), 3., bvec4(1, 1, 1, 1))\n//#define config init(244, vec3(4, 2, 4), vec3(4, 2, 4), 2., bvec4(1, 1, 1, 1))\n//#define config init(244, vec3(4, 2, 2), vec3(2, 2, 4), 4., bvec4(1, 1, 1, 1))\n//#define config init(236, vec3(2, 3, 2), vec3(3, 2, 4), 3., bvec4(1, 1, 0, 1))\n//#define config init(244, vec3(2, 2, 2), vec3(3, 2, 3), 4., bvec4(0))\n//#define config init(244, vec3(4, 2, 2), vec3(2, 2, 4), 4., bvec4(1, 1, 1, 1))\n#define config init(vec3(5, 2, 3), vec3(3, 2, 3), vec3(3, 2, 5), 2., bvec4(1))\n\n\n//*****************************************************************************\n\nfloat map(vec2 p, inout int index) {\n    vec2 mouse = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float k = 1.0;\n    if (iMouse.z > 0.0) {\n        p -= mouse;\n        k = dot(p,p);\n        p /= k;\n        p += mouse;\n    }\n    const float strong_factor = 4.;\n#ifdef DrawVerticalSections\n    vec3 q = vec3(p.x, iTime*0.1, p.y + 1.);\n#else\n    vec3 q = vec3(p, mod(iTime*0.2 - 0.01, SECTION_HEIGHT - 0.02) + 0.01);\n#endif\n    return k*DE(q, index) * strong_factor;\n    \n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 post_process(vec3 col, vec2 uv) {\n  col = pow(clamp(col, 0., 1.), vec3(1.0/2.2)); \n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *= 0.5 + 0.5*pow(19.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.7);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    config;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 p = 2. * uv - 1.;\n    p.x *= iResolution.x / iResolution.y;\n    p *= ZOOM;\n    float aa  = 2.0 / clamp(iResolution.y, 400., 800.);\n\n    int index, cid;\n    \n    float d = map(p, index);\n    cid = index;\n    \n    \n    float b = -0.4;\n    float t = 10.0;\n    const float lh = 2.;\n    const vec3 lp = vec3(2.5, 2.5, lh);\n    \n    vec3 ro = vec3(0, 0, t);\n    vec3 pp = vec3(p, 0);\n    \n    vec3 rd = normalize(pp - ro);\n\n    vec3 ld = normalize(lp - pp);\n    \n    float bt = -(t-b)/rd.z;\n  \n    vec3  bp   = ro + bt*rd;\n    vec3  srd = normalize(lp - bp);\n    float bl = L2(lp - bp);\n\n    float st = (0.0-b)/srd.z;\n    vec3  sp = bp + srd*st;\n\n    float bd = map(bp.xy, index);\n    float sd = map(sp.xy, index);\n\n    vec3 col = vec3(0);\n    const float ss = 15.0;\n    col       += vec3(1.)  * (1.0 - exp(-ss*(max(sd, 0.0)))) / bl;\n    float l   = length(p);\n#ifdef DrawLimitSet\n    float hue = fract(0.75*l-0.3*iTime) + .45;\n#else\n    float hue = fract(0.15*l-0.3*iTime) + .5;\n#endif\n    float sat = .9*tanh(4.*l);\n    vec3 hsv  = vec3(hue, sat, 1.0);\n    vec3 bcol = hsv2rgb(hsv);\n    \n    col       *= (1.0-clamp(tanh(0.75*l), 0., .1)) * 1.3;\n\n#ifdef DrawLimitSet\n    col       = mix(col, vec3(1), smoothstep(-aa, aa, -d));\n#else\n    col       = mix(col, bcol, 1. - step(-d, aa));\n#endif\n    col       += 0.5*sqrt(bcol.zxy)*(exp(-(10.0+100.0*tanh(l))*max(d, 0.0)));\n    \n    col = post_process(col, uv);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_ITER         30\n#define PI               3.141592653\n#define L2(x)            dot(x, x)\n#define ZOOM             3.\n#define inf              -1.\n#define K(cx2, cx3)      vec2(cx2, (cx3 + cx2*c23) / s23)       \n\n// comment out this to show the circles\n#define DrawLimitSet\n\n\n// uncomment this to show the vertice sections\n//#define DrawVerticalSections\n\nfloat dihedral(float x) {\n    return x == inf ? 1. : cos(PI / x);\n}\n\nvec3 dihedral(vec3 v) {\n    return vec3(dihedral(v.x), dihedral(v.y), dihedral(v.z));\n}\n\nfloat SECTION_HEIGHT;\n\n// For spheres n is the center, r is the radius\n// For planes n is the normal vector, r is the distance between the plane and the origin\n// if invert is true then the inside/outside of the sphere is interchanged (not used in this program)\n// if hasRealBall is true then this virtual ball has a real ball correspondes to it\nstruct Ball {\n    bool isplane;\n    vec3 n;\n    float r;\n    bool invert;\n    bool isRealBall;\n};\n\n// coclusters are mirror balls, they corresponde to root vectors (space-like)\nBall[5] coclusters;\n// clusters are real balls, they corresponde to space-like weight vectors\nBall[5] clusters;\n\n\n// create a ball. by default it's the z=0 plane with normal points to the negative half\nBall defaultBall() {\n    return Ball(false, vec3(0, 0, -1), 0., false, false);\n}\n\n// Distance from a point to a ball\nfloat sdistanceToBall(vec3 p, Ball B) {\n    if (B.isplane) {\n        float k = dot(vec4(p, 1), vec4(B.n, B.r));\n        return k;\n    }\n    else\n        return length(p - B.n) - B.r;\n}\n\nBall from_plane(vec3 n, float d) {\n    return Ball(true, n, d, false, false);\n}\n\nBall from_sphere(vec3 cen, float r) {\n    return Ball(false, cen, r, false, false);\n}\n\nvoid invertBall(inout Ball B) {\n    B.invert = !B.invert;\n}\n\n// try to reflect a point p to the positive half space bounded by a ball\n// if we are already in the positive half space, do nothing and return true,\n// else reflect about the ball and return false\n// if B is a sphere we try to reflect p into the interior of B\nbool try_reflect(inout vec3 p, Ball B, inout float scale) {\n    if (B.isplane) {\n        float k = dot(vec4(p, 1), vec4(B.n, B.r));\n        if (k >= 0.)\n            return true;\n        p -= 2. * k  * B.n;\n        return false;\n    }\n    else {\n        vec3 cen = B.n;\n        float r = B.r;\n        vec3 q = p - cen;\n        float d2 = dot(q, q);\n        float k = (r * r) / d2;\n        if ( (k < 1.0 && B.invert) || (k > 1. && !B.invert) )\n            return true;\n        p = k * q + cen;\n        scale *= k;\n        return false;\n    }\n}\n\n// return distance to the scene, and get the index of the real ball hitted\nfloat DE(vec3 p, inout int index) {\n    float scale = 3.;\n    for (int i = 0; i < MAX_ITER; i++) {\n        bool cond = true;\n        for (int k = 0; k < 5; k++) {\n            cond = try_reflect(p, coclusters[k], scale) && cond;\n        }\n\n        if (cond)\n            break;\n    }\n    index = 0;\n#ifdef DrawLimitSet\n    float d = abs(p.z);\n    for (int j = 1; j < 5; j++) {\n        if (clusters[j].isRealBall) {\n            float d1 = abs(sdistanceToBall(p, clusters[j]));\n            if (d1 < d) { d = d1; index = j; }\n        }\n    }\n#else\n    float d = p.z;\n    for (int j = 1; j < 5; j++) {\n        if (clusters[j].isRealBall) {\n            float d1 = sdistanceToBall(p, clusters[j]);\n            if (d1 < d) { d = d1; index = j; }\n        }\n    }\n    \n#endif\n    return d / scale;\n}\n\n// solve a ball with center (0, 0, z), radius r and orthogonal to two other\n// Balls A and B\nBall solveBall(Ball A, Ball B) {\n    float zA = A.n.z, rA=A.r;\n    float zB = B.n.z, rB=B.r;\n    float z = (rB*rB - rA*rA + L2(A.n) - L2(B.n)) / 2. / (zA - zB);\n    float r = sqrt(z*z - 2.*z*zA + L2(A.n) - rA*rA);\n    return from_sphere(vec3(0, 0, z), r);\n}\n \n// solve a ball which is orthogonal to three Balls A, B, C and plane P\nBall solveBall(Ball A, Ball B, Ball C, Ball P) {\n    float k = -P.n.y / P.n.x;\n    float d1 = B.r*B.r - A.r*A.r + L2(A.n) - L2(B.n);\n    float d2 = C.r*C.r - A.r*A.r + L2(A.n) - L2(C.n);\n    vec3 coeff1 = 2. * (B.n - A.n);\n    vec3 coeff2 = 2. * (C.n - A.n);\n    float a1 = coeff1.x, b1 = coeff1.y, c1 = coeff1.z;\n    float a2 = coeff2.x, b2 = coeff2.y, c2 = coeff2.z;\n    float delta = d1 * c2 - d2 * c1;\n    float p = a1 * k + b1;\n    float q = a2 * k + b2;\n    float y = delta / (p * c2 - q * c1);\n    float x = k * y;\n    float z = (d1 - p * y) / c1;\n    vec3 cen = vec3(x, y, z);\n    float r = sqrt(L2(cen - A.n) - A.r*A.r);\n    return from_sphere(cen, r);\n}\n\n\nBall solveBall(Ball A, Ball B, vec2 k1k2, float cA, float cB) {\n    float a = 2.0 * dot(k1k2, B.n.xy - A.n.xy) + 2. * (B.r * cB - A.r * cA);\n    float b = 2. * (B.n.z - A.n.z);\n    float c = L2(B.n) - L2(A.n) + A.r*A.r - B.r*B.r;\n    float p = c /  b, q = -a / b;\n    float zA = p - B.n.z;\n    a = L2(k1k2) + q * q - 1.0;\n    b = 2. * (dot(k1k2, A.n.xy) + q * zA + cA * A.r);\n    c = L2(vec3(B.n.xy, zA)) - A.r*A.r;\n    float r = b / a - sqrt(b * b - a * c) / a;\n    return from_sphere(vec3(k1k2*r, p + q*r), r);\n}\n \n\n// triangleType: must be one of 236, 244 or 333\n// dihedralAngles0: labels of the edges between v0 and (v2, v3, v4)\n// dihedralAngles1: labels of the edges between v1 and (v2, v3, v4)\n// dihedralAngles0_1: label of the edge between (v0, v1)\n// isRealBall: specify which of (v1, v2, v3, v4) has real balls\nvoid init(vec3 triangle234,\n          vec3 dihedralAngles0_234,\n          vec3 dihedralAngles1_234,\n          float dihedralAngle01,\n          bvec4 isRealBall) {\n \n    Ball B0, B1, B2, B3, B4;\n    vec3 c234 = dihedral(triangle234);\n    vec3 c0_234 = dihedral(dihedralAngles0_234);\n    vec3 c1_234 = dihedral(dihedralAngles1_234);\n    float c01 = dihedral(dihedralAngle01);\n    \n    // B2 is the plane with normal x-axis\n    B2 = from_plane(vec3(1, 0, 0), 0.0);\n    // B3 is alsp a plane with normal (x, y, 0)\n    float c23 = c234.x;\n    float s23 = sqrt(1.0 - c23*c23);\n    B3 = from_plane(vec3(-c23, s23, 0.0), 0.0);\n\n    // B4 must be a ball since the triangle 234 is of finite type\n    // B4 has center at (x, y, 0) and radius r\n    float c24 = c234.y;\n    float c34 = c234.z;\n    vec2 k1k2 = K(c23, c34);\n    B4 = from_sphere(vec3(k1k2, 0.), 1.0);\n    \n    \n    // now we solve the ball B1(x, y, 0), r\n    float c12 = c1_234.x;\n    float c13 = c1_234.y;\n    float c14 = c1_234.z;\n\n    k1k2 = K(c12, c13);\n    \n    float a = L2(k1k2) - 1.;\n    float b = dot(vec3(k1k2, c14), vec3(B4.n.xy, B4.r));\n    float c = L2(B4.n.xy) - B4.r*B4.r;\n    float r = b / a - sqrt(b * b - a * c) / a;\n    B1 = from_sphere(vec3(k1k2*r, 0.), r);\n    \n    float c02 = c0_234.x;\n    float c03 = c0_234.y;\n    float c04 = c0_234.z;\n    \n    k1k2 = K(c02, c03);\n    B0 = solveBall(B1, B4, k1k2, c01, c04);\n    \n    coclusters = Ball[5] (B0, B1, B2, B3, B4);\n    \n    SECTION_HEIGHT = B0.n.z;\n    \n    //now we process the real balls\n    for (int k = 0; k < 5; k++)\n        clusters[k] = defaultBall();\n        \n    if (isRealBall.x) {\n        clusters[1] = solveBall(B0, B4);\n        clusters[1].isRealBall = true;\n    }\n    if (isRealBall.y) {\n        clusters[2] = solveBall(B0, B1, B4, B3);\n        clusters[2].isRealBall = true;\n    }\n    if (isRealBall.z) {\n        clusters[3] = solveBall(B0, B1, B4, B2);\n        clusters[3].isRealBall = true;\n    }\n   \n    if (isRealBall.w) {\n        clusters[4] = solveBall(B0, B1);\n        clusters[4].isRealBall = true;\n    }\n}\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"dlKyWc","date":"0","viewed":0,"name":"Fork Boyd-Maxwe neozhaolia 911","username":"neozhaoliang","description":"Limit set of rank 4 hyperbolic Coxeter groups, drawn both on the boundary sphere and the stereo-projected plane.","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nBoyd-Maxwell circle packings and limit set of hyperbolic Coxeter groups: rank 4/level 2 case\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor more information check the github repo:\n\n    https://github.com/neozhaoliang/Hyperbolic-Honeycombs\n\nRequired input:\n\nThe Coxeter diagram of a rank 4 Coxeter group G = <A, B, C, D>, with dihedral angles\nm_{s,t} in the order (AB, AC, AD, BC, BD, CD).\n\nNote:\n\n1. CD must be finite\n2. The triangle group <B, C, D> must be hyperbolic\n\nIf you see only a sphere and a small disk under it, try comment out `#define useMouseInvert` below.\n*/\n\n\n#define useMouseInvert\n\n#define shiny        5.\n\n\n//#define config      initLevel2Graph(float[6](4., 2., 7., 4., 2., 5.))\n//#define config      initLevel2Graph(float[6](3., 2., 2., 3., 2., 7.))\n//#define config      initLevel2Graph(float[6](3., 3., 2., 3., 2., 7.))\n#define config      initLevel2Graph(float[6](4., 4., 4., 4., 4., 4.))\n//#define config      initLevel2Graph(float[6](2., 2., 7., inf, 3., 3.))\n//#define config      initLevel2Graph(float[6](3., 3., 2., 7., 2., 3.))\n//#define config      initLevel2Graph(float[6](5., 2., 3., 4., 3., 3.))\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 scenecol = vec3(0.);\n\n// initialize the mirrors\n  \n    config;\n    \n    float lw = 8. / iResolution.y;\n\n// antialiasing loop\n\n    for(int ii=0; ii<AA; ii++) {\n        for(int jj=0; jj<AA; jj++) {\n            vec2 o = vec2(float(ii), float(jj)) / float(AA);\n            vec2 uv = (2. * fragCoord + o - iResolution.xy) / iResolution.y;\n            vec2 p = uv * 1.0;\n            vec3 col = getcolor(p, lw);\n            scenecol += col;\n        }\n    }\n    scenecol /= (float(AA) * float(AA));\n\n    fragColor = vec4(sqrt(max(scenecol, 0.0)), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define inf                 1.0     // Vinberg convention for edge labels\n#define MAX_REFLECTIONS     0\n#define AA                  2\n#define PI                  3.141592653\n#define L2(x)               dot(x, x)\n#define L2XY(x, y)          L2(x - y)\n#define Hyperbolic          -1.0\n#define Euclidean           0.\n#define Spherical           1.\n#define MAX_TRACE_STEPS     500\n#define MIN_TRACE_DIST      0.001\n#define MAX_TRACE_DIST      100.0\n#define PRECISION           0.0001\n#define EdgeSize1           0.0035 \n#define EdgeSize2           0.01\n#define ColorScale          0.8\n\n// Move a vertex of Euclidean type (if there is any) to infinity,\n// so the pattern tiles the entire plane\n#define moveVertexToInf\n\n// 4x4 Cartan matrix for the Coxeter group\nmat4 cartan;\n\n// geometry type of each vertex in the Coxeter diagram\n// -1 for hyerbolic, 0 for Euclidean, 1 for spherial\nvec4 vertexType = vec4(1);\n\n// coordinates of a Euclidean vertex\nvec2 euclideanVertex;\n\n// if we are outside of the unit circle\n// if a point lies outside of unit circle, the distance\n// estimation becomes inaccurate. We use EdgeSize2 to control the edge size for this case.\nbool outside = false;\n\n// if there is an Euclidean vertex, i.e. if remove this vertex, the remain diagram is affine\nbool hasEuclideanVertex;\n\n// compute cos(PI / x), for x = inf this is just inf\nfloat dihedral(float x) {\n    return x == inf ? inf : cos(PI / x);\n}\n\n// complex multiplication\nvec2 cmul(vec2 p, vec2 q) { return vec2(p.x*q.x-p.y*q.y, p.x*q.y+p.y*q.x); }\n\n\n// complex division\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y, -z.x * w.y + z.y * w.x) / dot(w, w);\n}\n\n// compute the vertex type of each vertex.\n// for each vertex in the Coxeter diagram, its vertex type is determined by the triangle group G formed by\n// the remaining three vertices. This vertex is of hyperbolic/spherical/euclidean iff G is\n// hyperbolic/spherical/euclidean, respectively.\n// This can be checked from the determinant of the leading minors of the Cartan matrix.\nvoid checkCartan(mat4 M) {\n    const float e = 0.001;\n    float det;\n    det = determinant(mat3(M[1].yzw, M[2].yzw, M[3].yzw));\n    vertexType.x = step(-e, det) + step(e, det) - 1.;\n        \n    det = determinant(mat3(M[0].xzw, M[2].xzw, M[3].xzw));\n    vertexType.y = step(-e, det) + step(e, det) - 1.;\n    \n    det = determinant(mat3(M[0].xyw, M[1].xyw, M[3].xyw));\n    vertexType.z = step(-e, det) + step(e, det) - 1.;\n    \n    det = determinant(mat3(M[0].xyz, M[1].xyz, M[2].xyz));\n    vertexType.w = step(-e, det) + step(e, det) - 1.;\n}\n\n\n// For spheres cen is the center, r is the radius\n// For planes cen is the normal vector, r is the offset from the origin along the normal. \n// if invert is true then the inside/outside of the sphere is exchanged.\nstruct Ball {\n    vec2 cen;\n    float r;\n    bool isplane;\n    bool invert;\n};\n\n\n// coclusters are mirror balls, they corresponde to root vectors (space-like)\nBall[4] coclusters;\n// clusters are real balls, they corresponde to space-like weight vectors\nBall[4] clusters;\n\n\n// create a default ball (unit circle)\nBall defaultBall() {\n    return Ball(vec2(0), 1., false, false);\n}\n\n\nBall from_plane(vec2 normal, float offset) {\n    return Ball(normal, offset, true, false);\n}\n\nBall from_sphere(vec2 cen, float r) {\n    return Ball(cen, r, false, false);\n}\n\nvoid invertBall(inout Ball B) {\n    B.invert = !B.invert;\n}\n\n\n// try to reflect a point p to the positive half space bounded by a ball\n// if we are already in the positive half space, do nothing and return true,\n// else reflect about the ball and return false\n// if B is a sphere we try to reflect p into the interior of B\nbool try_reflect(inout vec2 p, Ball B, inout int count, inout float scale) {\n    vec2 cen = B.cen;\n    float r = B.r;\n    if (B.isplane) {\n        float k = dot(vec3(p, 1), vec3(cen, r));\n        if (k >= 0.)\n            return true;\n        p -= 2. * k  * cen;\n        count += 1;\n        return false;\n    }\n    else {\n        vec2 q = p - cen;\n        float d2 = dot(q, q);\n        float k = (r * r) / d2;\n        if ( (k < 1.0 && B.invert) || (k > 1. && !B.invert) )\n            return true;\n        p = k * q + cen;\n        scale *= k;\n        count += 1;\n        return false;\n    }\n}\n\n\nvec2 getIntersection(Ball B1, Ball B2, Ball B3) {\n    vec2 dir = vec2(-B3.cen.y, B3.cen.x);\n    float r1 = B1.r, r2 = B2.r;\n    float k = (L2(B1.cen) - L2(B2.cen) - (r1*r1 - r2*r2)) / (2. * dot(B1.cen - B2.cen, dir));\n    return k*dir;\n}\n\nBall solveBall(Ball B1, Ball B2, Ball B3) {\n    vec2 dir = vec2(-B3.cen.y, B3.cen.x);\n    float r1 = B1.r, r2 = B2.r;\n    float k = (L2(B1.cen) - L2(B2.cen) - (r1*r1 - r2*r2)) / (2. * dot(B1.cen - B2.cen, dir));\n    vec2 cen = k * dir; \n    float r = sqrt(L2XY(cen, B1.cen) - r1*r1);\n    return from_sphere(cen, r);\n}\n\n\nfloat sdistanceToBall(vec2 p, Ball B) {\n    if (B.isplane) {\n        float k = dot(vec3(p, 1), vec3(B.cen, B.r));\n        return k;\n    }\n    else {\n        float k = length(p - B.cen) - B.r;\n        return B.invert ? -k : k;\n    }\n}\n\n\nvoid initLevel2Graph(in float[6] diagram) {\n    Ball B0, B1, B2, B3;\n    float c01 = dihedral(diagram[0]);\n    float c02 = dihedral(diagram[1]);\n    float c03 = dihedral(diagram[2]);\n    float c12 = dihedral(diagram[3]);\n    float c13 = dihedral(diagram[4]);\n    float c23 = dihedral(diagram[5]);\n    \n    cartan = mat4(1, -c01, -c02, -c03,\n                  -c01, 1, -c12, -c13,\n                  -c02, -c12, 1, -c23,\n                  -c03, -c13, -c23, 1);\n    checkCartan(cartan);\n    \n    float s23 = sqrt(1. - c23*c23);\n    \n    // The two virtual balls B2, B3 (reflection mirrors) are lines through the origin\n    B2 = from_plane(vec2(1, 0), 0.);\n    B3 = from_plane(vec2(-c23, s23), 0.);\n    \n    // The mirror ball B1(x, y, r) satisfy\n    // Angle with B2: dot((x, y), (1, 0)) / r = c12\n    // Angle with B3: dot((x, y), (-c23, s23)) / r = c13\n    // Orthogonal to the real ball (unit ball) C0: x^2 + y^2 = r^2 + 1\n    float k1 = c12;\n    float k2 = (c13 + c23*c12) / s23;\n    float r = 1. / sqrt(k1*k1 + k2*k2 - 1.);\n    \n    B1 = from_sphere(vec2(k1*r, k2*r), r);\n    \n    // The mirror ball B0(x, y, r) satisfy\n    // Angle with B2: dot((x, y), (1, 0)) / r = c02\n    // Angle with B3: dot((x, y), (-c23, s23)) / r = c03\n    // Angle with B1:\n    //\n    //        r^2 + r1^2 - |(x,y) - (x1,y1)|^2\n    //        --------------------------------  = c01\n    //                   2 * r * r1\n    k1 = c02;\n    k2 = (c03 + c23*c02) / s23;\n    \n    float a = k1*k1 + k2*k2 - 1.;\n    float b = dot(vec3(k1, k2, c01), vec3(B1.cen, B1.r));\n    float c = L2(B1.cen) - B1.r*B1.r;\n    \n    r = b / a - sqrt(b*b - a*c) / a;\n    B0 = from_sphere(vec2(k1*r, k2*r), r);\n    \n    \n    \n    invertBall(B0);\n    invertBall(B1);\n    \n    coclusters = Ball[4] (B0, B1, B2, B3);\n    \n    for (int k = 0; k < 4; k++) {\n        clusters[k] = defaultBall();\n    }\n    \n   \n    invertBall(clusters[0]);\n    \n    if (vertexType.y == Hyperbolic) {\n        float r = sqrt(L2(B0.cen) - B0.r*B0.r);\n        clusters[1] = from_sphere(vec2(0), r);\n    }\n    if (vertexType.z == Hyperbolic) {\n        clusters[2] = solveBall(B0, B1, B3);\n    }\n    if (vertexType.w == Hyperbolic) {\n        clusters[3] = solveBall(B0, B1, B2);\n    }\n    \n    if (vertexType.y == Euclidean) {\n        hasEuclideanVertex = true;\n        euclideanVertex = vec2(0);\n        return;\n    }\n        \n    if (vertexType.z == Euclidean) {\n        hasEuclideanVertex = true;\n        euclideanVertex = getIntersection(B0, B1, B3);\n        return;\n    }\n    \n    if (vertexType.w == Euclidean) {\n        hasEuclideanVertex = true;\n        euclideanVertex = getIntersection(B0, B1, B2);\n        return;\n    }\n}\n\nvec2 applyMobius(vec2 p) {\n    if (hasEuclideanVertex) {\n        vec2 A = euclideanVertex;\n        vec2 B = vec2(0, 0);\n        vec2 C = vec2(1, 0);\n        vec2 D = vec2(4, 0);\n        p = cdiv(cmul(p, A) + B, cmul(C, p) + D);\n    }\n    return p;\n}\n\n\nfloat distanceToMirrors(vec2 p) {\n    float d = abs(sdistanceToBall(p, coclusters[0]));\n    \n    if (length(p) > 1.) {\n        p /= L2(p);\n        outside = true;\n    }\n    \n    for (int k = 1; k < 4; k++) {\n         d = min(d, abs(sdistanceToBall(p, coclusters[k])));\n    }\n    return d;\n}\n\n\nvoid fold(inout vec2 p, inout int count, inout float scale, inout int index) {\n#ifdef moveVertexToInf\n    p = applyMobius(p);\n#endif\n    for (int i = 0; i < MAX_REFLECTIONS; i++) {\n        bool cond = true;\n        for (int k = 0; k < 4; k++) {\n            cond = try_reflect(p, coclusters[k], count, scale) && cond;\n        }\n        if (cond)\n            break;\n    }\n    for (int k = 0; k < 4; k++) {\n        if (vertexType[k] == Hyperbolic && sdistanceToBall(p, clusters[k]) < -0.0001) {\n            index = k;\n            break;\n        }\n    }\n}\n\n// signed distance to unit ball and plane z=-1\nfloat sdSphere(vec3 p) { return length(p) - 1.0; }\nfloat sdPlane(vec3 p) { return p.z + 1.0; }\n\n// project points on the unit ball to plabe z=-1\nvec2 sphereToPlane(vec3 p) {\n    return 2. * p.xy / (1. - p.z);\n}\n\n// 2d rotation\nvec2 rot2d(vec2 p, float a) { return p * cos(a) + vec2(-p.y, p.x) * sin(a); }\n\n// you can implement your color functions here\nvec3 colormap(int index, float t) {\n    float c = float(index) + 1.;\n    return .5 + .45*cos(2.*PI  * pow(t, 0.3) * ColorScale * c + vec3(0, 1, 2));\n}\n\nvec3 getcolor(inout vec2 p, out float ed) {\n    int index = -1;\n    int count = 0;\n    float scale = 1.;\n    fold(p, count, scale, index);\n    float dist = distanceToMirrors(p);\n    float t = clamp(float(count + 1) / float(MAX_REFLECTIONS), 0., 1.);\n    vec3 col = colormap(index, t);\n    float es = outside ? EdgeSize2 : EdgeSize1;\n    float aa = fwidth(dist) / 2.;\n    col = mix(col, vec3(0), 1. - smoothstep(es-aa, es+aa, dist));\n    return col;\n}\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"Ds2XWK","date":"0","viewed":0,"name":"Fork Creative B neozhaolia 503","username":"neozhaoliang","description":"Released in the Executable Graphics compo at Outline 2021.\n\nDownload the executable version here: [url]https://demozoo.org/graphics/294426/[/url]\n\nNote: All comments on how to minify the shader further will be deleted.","likes":0,"published":0,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float seed;\nfloat hash() {\n\tfloat p=fract((seed++)*.1031);\n\tp+=(p*(p+19.19))*3.;\n\treturn fract((p+p)*p);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n \t// seed the RNG (again taken from Devour)\n    seed = float((int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);\n\n\tvec2 uv = gl_FragCoord.xy/iResolution.xy;\n\tvec4 tex = texelFetch(iChannel0,ivec2(gl_FragCoord.xy),0);\n    \n    // divide by sample-count\n\tvec3 color = tex.rgb/tex.a;\n\n\t// vignette to darken the corners\n\tuv-=.5;\n\tcolor *= 1.-dot(uv,uv)*.1;\n\n    // exposure and tonemap\n    color *= 3.5;\n    //color = 1.-exp(color*-2.);\n    color = mix(color,1.-exp(color*-2.),.5);\n\n    // subtle warm grade\n    color = pow(color,vec3(1,1.02,1.05));\n    \n\t// gamma correction as the final step\n\tcolor = pow(color, vec3(.45));\n\n    // grain\n    color += (vec3(hash(),hash(),hash())-.5)*.01;\n\n    // aspect ratio\n    uv*=iResolution.xy/iResolution.yx;\n    color *= step(abs(uv.y),.5/(16./9.));\n    color *= step(abs(uv.x),.5*(16./9.));\n\n    // \"final\" color\n    fragColor = vec4(vec3(color),1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat2 rotate(float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return mat2(c,-s,s,c);\n}\n\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p - vec3(0, r, 0)) - r;\n}\n\n\nfloat sdBox(vec2 p, vec2 b)\n{\n    vec2 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0));\n}\n\n\nfloat sdBox(vec2 p, vec2 b, float r)\n{\n    return sdBox(p,b-r)-r;\n}\n\n\nfloat sdRoundedCylinder(vec3 p, float radius, float halfHeight, float bevel)\n{\n    vec2 p2 = vec2(length(p.xz),p.y);\n    return sdBox(p2,vec2(radius,halfHeight),bevel);\n}\n\n\nvec2 cmul(vec2 z, vec2 w)\n{\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\n\n\n\nvec2 cdiv(vec2 z, vec2 w)\n{\n    return vec2(\n        z.x * w.x + z.y * w.y,\n       -z.x * w.y + z.y * w.x\n    ) / dot(w, w);\n}\n\n\nstruct Mobius\n{\n    vec2 A;\n    vec2 B;\n    vec2 C;\n    vec2 D;\n};\n\n\nconst Mobius mob = Mobius(\n    vec2(-1, 0),\n    vec2(1.2, 0),\n    vec2(-1, 0),\n    vec2(-1.2, 0)\n);\n\n\nvec2 applyMobius(vec2 z)\n{\n    vec2 z1 = cmul(mob.A, z) + mob.B;\n    vec2 z2 = cmul(mob.C, z) + mob.D;\n    return cdiv(z1, z2);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define pi acos(-1.)\n#define tau (pi*2.)\n\nfloat seed;\nfloat hash() {\n\tfloat p=fract((seed++)*.1031);\n\tp+=(p*(p+19.19))*3.;\n\treturn fract((p+p)*p);\n}\nvec2 hash2(){return vec2(hash(),hash());}\n\n\nfloat hexa(vec2 p, float r1, float r2)\n{\n\n    float ang = pi/3.;\n    float x= (r1-r2)/tan(ang)+r2;\n    vec2 v = vec2(x,r1);\n    mat2 rot = rotate(ang);\n    float hex1 = sdBox(p,v,r2); p.xy *= rot;\n    float hex2 = sdBox(p,v,r2); p.xy *= rot;\n    float hex3 = sdBox(p,v,r2);\n    return min(hex1,min(hex2,hex3));\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c is the sin/cos of the angle\n    vec2 q = vec2( length(p.xz), -p.y );\n    float d = length(q-c*max(dot(q,c), 0.0));\n    return d * ((q.x*c.y-q.y*c.x<0.0)?-1.0:1.0);\n}\n\n\n\n\n\nint mat = -1;\nconst int kMatGround = 0;\nconst int kMatPlasticRed = 1;\nconst int kMatWood = 2;\nconst int kMatLead = 3;\n\nbool doWoodDisplacement = true;\n\nfloat scene(vec3 p)\n{\n    vec3 op=p;\n    \n    float ground = p.y - (cos(min(100.,p.z)*.03)-1.)*2.;\n\n   \n    float woodCenter = sdSphere(p, 10.0);\n\n\n    float best = ground;\n    best=min(best,woodCenter);\n\n    \n    if(best==ground)\n    {\n        mat = kMatGround;\n    }\n\n    else if (best==woodCenter)\n    {\n        mat = kMatPlasticRed;\n    }\n    \n    return best;\n}\n\nfloat flip = 1.;\nconst float IOR = 1.584;\n\nvec3 ortho(vec3 a){\n    vec3 b=cross(vec3(-1,-1,-1),a);\n    // assume b is nonzero\n    return (b);\n}\n\n// various bits of lighting code \"borrowed\" from \n// http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec3 getSampleBiased(vec3  dir, float power) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = hash2();\n\tr.x=r.x*2.*pi;\n\tr.y=pow(r.y,1.0/(power+1.0));\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 getConeSample(vec3 dir, float extent) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r =  hash2();\n\tr.x=r.x*2.*pi;\n\tr.y=1.0-r.y*extent;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 sky(vec3 sunDir, vec3 viewDir) {\n    float softlight = max(0.,dot(normalize(sunDir*vec3(-1,1.,-1)),viewDir)+.2);\n    float keylight = pow(max(0.,dot(sunDir,viewDir)-.5),3.);\n    \n    return vec3(\n\t\tsoftlight*.015 + keylight * 10.\n\t)*1.5;\n    \n    /*return vec3(\n\t\tsoftlight*vec3(.03,.06,.1)*2. + keylight * vec3(10,7,4)\n\t)*1.5;*/\n\n    /*float softlight = max(0.,dot(sunDir,viewDir)+.2);\n    float keylight = pow(max(0.,dot(sunDir,viewDir)-.5),3.);\n    \n    return vec3(\n\t\tsoftlight*.5 + keylight * 10.\n\t)*1.5;*/\n}    \n\nbool trace5(vec3 cam, vec3 dir, float nearClip, out vec3 h, out vec3 n, out float k) {\n\tfloat t=nearClip;\n    for(int i=0;i<100;++i)\n    {\n        k = scene(cam+dir*t)*flip;\n        if (abs(k) < .001)\n            break;\n        t += k;\n    }\n\n    h = cam+dir*t;\n\t\n    // if we hit something\n    if(abs(k)<.001)\n    {\n        vec2 o = vec2(.001, 0);\n        n = normalize(vec3(\n            scene(h+o.xyy) - k,\n            scene(h+o.yxy) - k,\n            scene(h+o.yyx) - k \n        ))*flip;\n        return true;\n    }\n    return false;\n}\n\nfloat floorPattern(vec2 uv)\n{\n    float kUnit1 = 10.;\n    float kUnit2 = 5.;\n    float kUnit3 = 1.;\n    float kThick1 = 0.1;\n    float kThick2 = 0.05;\n    float kThick3 = 0.03;\n\n    vec2 uv1 = abs(mod(uv,kUnit1)-kUnit1*.5);\n    vec2 uv2 = abs(mod(uv,kUnit2)-kUnit2*.5);\n    vec2 uv3 = abs(mod(uv,kUnit3)-kUnit3*.5);\n    float lines1 = -max(uv1.x,uv1.y)+kUnit1*.5-kThick1;\n    float lines2 = -max(uv2.x,uv2.y)+kUnit2*.5-kThick2;\n    float lines3 = -max(uv3.x,uv3.y)+kUnit3*.5-kThick3;\n    \n    return min(lines1,min(lines2,lines3));\n}\n\nvec3 trace2(vec3 cam, vec3 dir, float nearClip)\n{\n    const vec3 sunDirection = normalize(vec3(-1.,.8,-.7));\n    //const vec3 sunDirection = normalize(vec3(1.,.7,-.3));\n    //const vec3 sunDirection = normalize(vec3(.5,.3,1));\n    //const vec3 sunDirection = normalize(vec3(0,1,0));\n    \n    vec3 accum = vec3(1);\n    for(int ibounce=0;ibounce<10;++ibounce)\n    {\n        vec3 h,n;\n        float k;\n        if (trace5(cam,dir,ibounce==0?nearClip:0.,h,n,k))\n        {\n            cam = h+n*.01;\n            if (mat == kMatGround)\n            {\n            \tdir=getSampleBiased(n,1.);\n\t\t\t\taccum *= mix(vec3(.25,.3,.35),vec3(.8),step(0.,floorPattern(h.xz)));\n                if (ibounce==0)\n                    doWoodDisplacement=false;\n            }\n            else if (mat == kMatWood)\n            {\n            \tdir=getSampleBiased(n,1.);\n                vec3 col = vec3(211,183,155)/255.;\n\t\t\t\taccum *= col*col*col;\n            }\n            else if (mat == kMatPlasticRed)\n            {\n                float fresnel = pow(1.-min(.99,dot(-dir,n)),5.);\n                fresnel = mix(.04,1.,fresnel);\n                if (hash() < fresnel)\n                {\n                \tdir=reflect(dir,n);\n                }\n                else\n                {\n            \t\tdir=getSampleBiased(n,1.);\n                    accum *= vec3(180,2,1)/255.;\n                }\n            }\n            else if (mat == kMatLead)\n            {\n                float fresnel = pow(1.-min(.99,dot(-dir,n)),5.);\n                fresnel = mix(.04,1.,fresnel);\n                dir=getConeSample(reflect(dir,n),0.3);\n                accum *= .05;\n            }\n        }\n        else if (abs(k) > .1) {\n            return sky(sunDirection, dir) * accum;\n        } else {\n            break;\n        }\n    }\n    \n    return sky(sunDirection, dir) * accum;\n    \n    // deliberately fail the pixel\n    return vec3(-1);\n}\n\nvec2 bokeh(){\n    // hexagon\n    vec2 a = hash2();\n    a.x=a.x*3.-1.;\n    a-=step(1.,a.x+a.y);\n\ta.x += a.y * .5;\n\ta.y *= sqrt(.75);\n    return a;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n\n    if (iMouse.z > 0.) {\n        fragColor = vec4(0.);\n    }\n\n\t// seed the RNG (again taken from Devour)\n    //seed = float(((iFrame*73856093)^int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);\n    seed = float((iFrame*73856093)%38069);\n\n    // get UVs\n    vec2 uv = (gl_FragCoord.xy+hash2()-.5)/iResolution.xy-.5;\n    \n    // correct UVs for aspect ratio\n    float aspect = iResolution.x/iResolution.y;\n    uv.x*=aspect;\n\tuv *= max(1.,(16./9.)/aspect);\n\n    // camera params\n    const vec3 camPos = vec3(140,60.,60)*1.5;\n    const vec3 lookAt = vec3(0,4.,0);\n    const float focusDistance=distance(camPos,lookAt)*.99;\n    const vec2 apertureRadius=vec2(1)*3.;\n    \n    // make a camera\n    vec3 cam = vec3(0);\n    vec3 dir = normalize(vec3(uv,6.5));\n    \n    // add some bokeh\n    vec2 bokehJitter=bokeh();\n    cam.xy+=bokehJitter*apertureRadius;\n    dir.xy-=bokehJitter*apertureRadius*dir.z/focusDistance;\n    \n    // rotate/move the camera\n    vec3 lookDir = lookAt-camPos;\n    float pitch = -atan(lookDir.y,length(lookDir.xz));\n    float yaw = -atan(lookDir.x,lookDir.z);\n    cam.yz *= rotate(pitch);\n    dir.yz *= rotate(pitch);\n    cam.xz *= rotate(yaw);\n    dir.xz *= rotate(yaw);\n    cam += camPos;\n    \n    // compute the pixel color\n\tvec3 pixel = trace2(cam,dir,length(camPos)*.7);\n    \n    fragColor += (!isnan(pixel.r) && pixel.r >= 0.) ? vec4(pixel,1) : vec4(0);\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"DtKcRh","date":"0","viewed":0,"name":"Fork Hyperbolic neozhaolia 147","username":"neozhaoliang","description":"This is similar to Shane's work https://www.shadertoy.com/view/WlBczG but uses a different approach.","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    A mimic of shane's work at https://www.shadertoy.com/view/WlBczG.\n    \n    Show the basic procedure to draw a 2d hyperbolic Poincare tiling.\n    \n    Also can draw paracompact and noncompact tilings (with ideal and hyperideal vertices)\n\n*/\n// show the three reflection mirrors\n//#define debug_mirrors\n\n// comment out this to see the initial pattern\n//#define enableMouseInversion\n\n// change to Klein model\n//#define KleinModel\n\n// set inf = 1.0 for paracompact tiling\n// set inf > 1.0 for noncompact tiling\n#define inf       1.15\n\n#define PI\t\t  3.14159265\n#define TAU\t      6.28318531\n#define MAX_ITER  30\n\n\n// the smaller this value, the larger the black area\n#define BlackRegionSize   0.065\n\n// the first entry in PQR must be finite, other two entries can be either finite or infinite\n// for example (3, inf 4), (3, 4, inf), etc\nconst vec3 PQR = vec3(3, inf, 2);\n\n\n// reflection mirrors\nvec2 A, B;\nvec3 C;\n\n// two vertices of the fundamental triangle, the 3rd one is the origin\nvec2 v0, m0;\n\n// count the number of reflections across each mirror\nfloat count;\n\n// compute cos(PI / x), for x = infiniy this is inf using Vinberg's convention.\nfloat dihedral(float x) { return x == inf ? inf : cos(PI / x); }\n\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\nvoid init() {\n\n    float cAB = dihedral(PQR.x);\n    float sAB = sqrt(1. - cAB*cAB);\n    \n\tA = vec2(1, 0);\n    B = vec2(-cAB, sAB);\n    \n    float cAC = dihedral(PQR.y);\n    float cBC = dihedral(PQR.z);\n    \n    float k1 = cAC;\n    float k2 = (cBC + cAB*cAC) / sAB;\n    float r = 1. / sqrt(k1*k1 + k2*k2 - 1.);\n    \n    C = vec3(k1, k2, 1.)*r;\n    \n    if (r*r >= C.x*C.x)\n        v0 = vec2(0., C.y - sqrt(r*r - C.x*C.x));\n    else\n        v0 = vec2(0, 1);\n        \n    vec2 n = vec2(-B.y, B.x);\n    float b = dot(C.xy, n);\n    float c = dot(C.xy, C.xy) - r*r;\n    float k = -1.0;\n    \n    if (b*b >= c)\n        k = b + sqrt(b*b-c);\n    \n    m0 = k*n;\n}\n\n\nbool try_reflect(inout vec2 p, vec2 mirror, inout float count) {\n    float k = dot(p, mirror);\n    if (k >= 0.)\n        return true;\n    p -= 2. * k  * mirror;\n    count += 1.;\n    return false;\n}\n\n\nbool try_reflect(inout vec2 p, vec3 sphere, inout float count) {\n    vec2 cen = sphere.xy;\n    float r = sphere.z;\n    float d = length(p - cen) - r;\n    if (d >= 0.)\n        return true;\n    p -= cen;\n    p *= r * r/ dot(p, p);\n    p += cen;\n    count += 1.;\n    return false;\n}\n\n\nvoid fold(inout vec2 p, inout float count) {\n    count = 0.;\n    for (int k = 0; k < MAX_ITER; k++) {\n        try_reflect(p, A, count);\n        //try_reflect(p, B, count);\n        try_reflect(p, C, count);\n    }\n}\n\n\nfloat sBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew) {\n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n\nvec2 mouseInversion(vec2 p) {\n    vec2 m = vec2((2.*iMouse.xy - iResolution.xy)/iResolution.y);\n    if(length(m) < 1e-3) m += 1e-3; \n    if(abs(m.x)>.98*.7071 || abs(m.y)>.98*.7071) m *= .98;\n\n    float k = 1./dot(m, m);\n    vec2 invCtr = k*m;\n    float t = (k - 1.)/dot(p -invCtr, p - invCtr);\n    p = t*p + (1. - t)*invCtr;\n    p.x = -p.x;\n    return p;    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    uv *= 1.05;\n    vec2 p = uv;\n    \n#ifdef enableMouseInversion\n    p = mouseInversion(p);\n    p = rot2(iTime/16.)*p;\n#endif\n\n    init();   \n    \n    if(length(p)> 1.)\n        p /= dot(p, p);\n        \n#ifdef KleinModel\n    p = p / (1. + sqrt(1. - dot(p, p)));\n#endif\n  \n    fold(p, count);\n    \n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    ln = min(ln, lBox(p, -v0, v0, .007));    \n    //ln = min(ln, lBox(p, vec2(0), m0, .007));\n    ln = min(ln, length(p-C.xy) - C.z - 0.007);\n\n    ln2 = min(ln2, lBox(p, vec2(0), m0, .007));\n    //pnt = min(pnt, length(p - v0)); \n    //pnt = min(pnt, length(p - m0)); \n    \n    float ssf = (2. - smoothstep(0., .25, abs(length(uv) - 1.) - .25));\n    float sf = 2./iResolution.y*ssf;\n        \n    vec3 oCol = .55 + .45*cos(count*TAU / 8. + vec3(0, 1, 2));\n    //float pat = smoothstep(0., .25, abs(fract(ln2*50. - .2) - .5)*2. -.2);\n   \n    float sh = clamp(.65 + ln/v0.y*4., 0., 1.);\n    \n    vec3 col = min(oCol*(0.*.2 + .9)*sh, 1.);\n    \n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    //col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - BlackRegionSize)));\n    vec3 bg = vec3(1, .2, .4);\n    bg *= .7*(mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .5)*.5 + .5);\n    //pat = smoothstep(0., .25, abs(fract((uv.x - uv.y)*43. - .25) - .5)*2. -.5);\n    bg *= max(1. - length(uv)*.5, 0.)*(0. + .9);\n    \n    float cir = length(uv);\n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf*10., abs(cir - 1.) - .05))*.7);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., abs(cir - 1.) - .01)));\n    //col = mix(col, vec3(.9) + bg, (1. - smoothstep(0., sf, abs(cir - 1.) - .03)));\n    col = mix(col, col*max(1. - length(uv)*.5, 0.), (1. - smoothstep(0., sf, -cir + 1.05)));\n    col = mix(col, bg, (1. - smoothstep(0., sf, -cir + 1.01)));\n    \n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(cir - 1.035) - .03))*.8);\n    col = mix(col, 1. - exp(-col), .35);\n\n#ifdef debug_mirrors\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.01, abs(dot(uv, A)) - 0.01));\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.01, abs(dot(uv, B)) - 0.01));\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.02, abs(length(uv-C.xy) - C.z))-0.01);\n#endif\n\n    fragColor = vec4(sqrt(max(col, 0.)), 1.);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"NlVGRd","date":"0","viewed":0,"name":"Fork Hyperbolic neozhaolia 158","username":"neozhaoliang","description":"This is similar to shane's work https://www.shadertoy.com/view/WlBczG but used a different approach","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    A mimic of shane's work at https://www.shadertoy.com/view/WlBczG.\n    \n    Show the basic procedure to draw a 2d hyperbolic Poincare tiling.\n\n*/\n\n// comment out this to see the initial pattern\n//#define enableMouseInversion\n\n\n\n#define PI\t\t  3.14159265\n#define TAU\t      6.28318531\n#define inf       -1.\n\nint MAX_ITER = 0;\n\n\n// the smaller this value, the larger the black area\n#define BlackRegionSize   0.065\n\n// the first entry in PQR must be finite, other two entries can be either finite or infinite\nconst vec3 PQR = vec3(3, 3, 7);\n\n\n// reflection mirrors\nvec2 A, B;\nvec3 C;\n\n// two vertices of the fundamental triangle, the 3rd one is the origin\nvec2 v0, m0;\n\n// count the number of reflections across each mirror\nfloat count;\n\n\n// compute cos(PI / x), for x = infiniy this is cos(0) = 1.0\nfloat dihedral(float x) { return x == inf ? 1. : cos(PI / x); }\n\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\nvoid init() {\n\n    float cAB = dihedral(PQR.x);\n    float sAB = sqrt(1. - cAB*cAB);\n    \n\tA = vec2(1, 0);\n    B = vec2(-cAB, sAB);\n    \n    float cAC = dihedral(PQR.y);\n    float cBC = dihedral(PQR.z);\n    \n    float k1 = cAC;\n    float k2 = (cBC + cAB*cAC) / sAB;\n    float r = 1. / sqrt(k1*k1 + k2*k2 - 1.);\n    \n    C = vec3(k1, k2, 1.)*r;\n    \n    v0 = vec2(0., C.y - sqrt(r*r - C.x*C.x));\n    vec2 n = vec2(-B.y, B.x);\n    float b = dot(C.xy, n);\n    float c = dot(C.xy, C.xy) - r*r;\n    float k = b + sqrt(b*b-c);\n    m0 = k*n;\n}\n\n\nbool try_reflect(inout vec2 p, vec2 mirror, inout float count) {\n    float k = dot(p, mirror);\n    if (k >= 0.)\n        return true;\n    p -= 2. * k  * mirror;\n    count += 1.;\n    return false;\n}\n\n\nbool try_reflect(inout vec2 p, vec3 sphere, inout float count) {\n    vec2 cen = sphere.xy;\n    float r = sphere.z;\n    float d = length(p - cen) - r;\n    if (d >= 0.)\n        return true;\n    p -= cen;\n    p *= r * r/ dot(p, p);\n    p += cen;\n    count += 1.;\n    return false;\n}\n\n\nbool fold(inout vec2 p, inout float count) {\n    count = 0.;\n    for (int k = 0; k < MAX_ITER; k++) {\n        bool cond = true;\n        cond = cond && try_reflect(p, A, count);\n        cond = cond && try_reflect(p, B, count);\n        cond = cond && try_reflect(p, C, count);\n        if (cond)\n            return true;\n    }\n    return false;\n}\n\nfloat sBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew) {\n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\nfloat darc(vec2 p, float k) {\n   \n   \n    vec2 q = p;\n    float tmp = 0.;\n    bool isout = try_reflect(q, C, tmp);\n    float dp = length(p - C.xy) - C.z;\n    float d = length(q - C.xy) - C.z;\n    float d1 = length(q - v0);\n    float d2 = length(q - m0);\n     if (dot(p, A) < 0.)\n        return d1;\n    if (dot(p, B) < 0.)\n        return d2;\n\n    if (!isout && dot(p, A) < 0.02 && d > 0.02)\n        return d1;\n    if (!isout && dot(p, B) < 0.05 && d > 0.02)\n        return d2;\n        \n\n    return d;\n}\n\n\nvec2 mouseInversion(vec2 p) {\n    vec2 m = vec2((2.*iMouse.xy - iResolution.xy)/iResolution.y);\n    if(length(m) < 1e-3) m += 1e-3; \n    if(abs(m.x)>.98*.7071 || abs(m.y)>.98*.7071) m *= .98;\n\n    float k = 1./dot(m, m);\n    vec2 invCtr = k*m;\n    float t = (k - 1.)/dot(p -invCtr, p - invCtr);\n    p = t*p + (1. - t)*invCtr;\n    p.x = -p.x;\n    return p;    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    uv *= 1.05;\n    vec2 p = uv;\n    \n#ifdef enableMouseInversion\n    p = mouseInversion(p);\n    p = rot2(iTime/16.)*p;\n#endif\n\n    init();\n    \n    if(length(p)> 1.)\n        p /= dot(p, p);\n        \n    MAX_ITER = int(mod(iTime, 20.0));\n  \n    bool found = fold(p, count);\n    \n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    float tm = -0.005;\n    ln = min(ln, lBox(p, vec2(0), v0, .007));\n    ln = min(ln, lBox(p, vec2(0), m0, .007));\n    ln = min(ln, darc(p, tm) + tm);\n\n    \n    ln2 = min(ln2, lBox(p, vec2(0), m0, .007));\n    pnt = min(pnt, length(p - v0)); \n    pnt = min(pnt, length(p - m0)); \n    \n    float ssf = (2. - smoothstep(0., .25, abs(length(uv) - 1.) - .25));\n    float sf = 2./iResolution.y*ssf;\n        \n    vec3 oCol = .55 + .45*cos(count*TAU / 8. + vec3(0, 1, 2));\n    float pat = smoothstep(0., .25, abs(fract(ln2*50. - .2) - .5)*2. -.2);\n   \n    float sh = clamp(.65 + ln/v0.y*4., 0., 1.);\n    \n    vec3 col = min(oCol*(pat*.2 + .9)*sh, 1.);\n    \n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - BlackRegionSize)));\n\n    pnt -= .032;\n    pnt = min(pnt, length(p) - .032);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnt));\n    col = mix(col, vec3(1, .8, .3), 1. - smoothstep(0., sf, pnt + .02));\n    \n    vec3 bg = vec3(1, .2, .4);\n    bg *= .7*(mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .5)*.5 + .5);\n    pat = smoothstep(0., .25, abs(fract((uv.x - uv.y)*43. - .25) - .5)*2. -.5);\n    bg *= max(1. - length(uv)*.5, 0.)*(pat*.2 + .9);\n    \n    float cir = length(uv);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*10., abs(cir - 1.) - .05))*.7);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., abs(cir - 1.) - .05)));\n    col = mix(col, vec3(.9) + bg, (1. - smoothstep(0., sf, abs(cir - 1.) - .03)));\n    col = mix(col, col*max(1. - length(uv)*.5, 0.), (1. - smoothstep(0., sf, -cir + 1.05)));\n    col = mix(col, bg, (1. - smoothstep(0., sf, -cir + 1.05)));\n    \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(cir - 1.035) - .03))*.8);\n    col = mix(col, 1. - exp(-col), .35);\n\n    //debug mirrors\n/*\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.01, abs(dot(uv, A)) - 0.01));\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.01, abs(dot(uv, B)) - 0.01));\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.02, abs(length(uv-C.xy) - C.z))-0.01);\n*/\n    fragColor = vec4(sqrt(max(col, 0.)), 1.);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"DlGyWW","date":"0","viewed":0,"name":"Fork Hyperbolic neozhaolia 396","username":"neozhaoliang","description":"The goal is to render dodecahedral subdivision analogous to sphere subdivision. Precision of float, or, more precisely, the lack of it, starts playing seriously when one leaves vicinity of the origin. ","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*      Regular dodecahedra in hyperbolic 3-space H form a one parameter family up to hyperbolic motions. They are\n    parameterized by, say, the length of their edge. The angle between two adjacent faces takes all the values\n    below the euclidean value of the angle, 2 arctan(ϕ) = 116.56... degrees down the value of the angle if ideal\n    dodecahedron, π/3. There is thus the unique up to motion right-angled dodecahedron D. The face angles of D \n    are also π/2 and exactly three faces meet in one vertex. Reflections in face planes and all the possible \n    combinations of such reflections of D tesselate H. 8 dodecahedra meet at each vertex. Reflections however \n    change space orientation and it is better to use their compositions with reflection about center of D. The \n    discrete subgroup of hyperbolic motions generated by these 12 transformation we will denote by G. Generators \n    of G are pure hyperbolic translations combined with rotation by π along the axis of translation, which joins \n    centers of opposite faces of D. Pure translation (along a geodesic) here means that normal basis is mapped \n    in such a way as it would do by parallel transport defined in riemannian geometry.\n\n        It is a hyperbolic group, meaning that the number of different group elements generated by the words on\n    generators of length <= N grows exponentially with N. This is obvious also from the fact that the volume of a\n    ball of radius R grows exponentially with R, and so does the number of dodecahedra that fit into this ball.\n\n        D is the fundamental domain of the G-action, meaning that if any transformation of G maps D to itself, then\n    it is the identity transformation. If that were not true, smaller part of D would be a fundamental domain. This\n    can be restated as follows: if two transformations of G map D to the same dodecahedron D' then these\n    transformations are equal.\n\n        Call these 12 generators P, p, Q, q, R, r, S, s, T, t, U, u ::\n\n        P = |     -1,      0,      0,      0 |\n            |      0,      0,    phi,  alpha |\n            |      0,    phi,    phi,   beta |\n            |      0,  alpha,   beta,  gamma |\n\n        p = |     -1,      0,      0,      0 |\n            |      0,      0,    phi, -alpha |\n            |      0,    phi,    phi,  -beta |\n            |      0, -alpha,  -beta,  gamma |\n\n        Q = |     -1,      0,      0,      0 |\n            |      0,      0,   -phi, -alpha |\n            |      0,   -phi,    phi,   beta |\n            |      0, -alpha,   beta,  gamma |\n\n        q = |     -1,      0,      0,      0 |\n            |      0,      0,   -phi,  alpha |\n            |      0,   -phi,    phi,  -beta |\n            |      0,  alpha,  -beta,  gamma |\n\n        R = |    phi,      0,    phi,   beta |\n            |      0,     -1,      0,      0 |\n            |    phi,      0,      0,  alpha |\n            |   beta,      0,  alpha,  gamma |\n\n        r = |    phi,      0,    phi,  -beta |\n            |      0,     -1,      0,      0 |\n            |    phi,      0,      0, -alpha |\n            |  -beta,      0, -alpha,  gamma |\n\n        S = |    phi,      0,   -phi,  -beta |\n            |      0,     -1,      0,      0 |\n            |   -phi,      0,      0,  alpha |\n            |  -beta,      0,  alpha,  gamma |\n\n        s = |    phi,      0,   -phi,   beta |\n            |      0,     -1,      0,      0 |\n            |   -phi,      0,      0, -alpha |\n            |   beta,      0, -alpha,  gamma |\n\n        T = |      0,    phi,      0,  alpha |\n            |    phi,    phi,      0,   beta |\n            |      0,      0,     -1,      0 |\n            |  alpha,   beta,      0,  gamma |\n\n        t = |      0,    phi,      0, -alpha |\n            |    phi,    phi,      0,  -beta |\n            |      0,      0,     -1,      0 |\n            | -alpha,  -beta,      0,  gamma |\n\n        U = |      0,   -phi,      0, -alpha |\n            |   -phi,    phi,      0,   beta |\n            |      0,      0,     -1,      0 |\n            | -alpha,   beta,      0,  gamma |\n\n        u = |      0,   -phi,      0,  alpha |\n            |   -phi,    phi,      0,  -beta |\n            |      0,      0,     -1,      0 |\n            |  alpha,  -beta,      0,  gamma |\n\n        alpha = sqrt((sqrt(5) + 1) / 2) = 1.2720196495140690\n        beta  = sqrt(sqrt(5) + 2)       = 2.0581710272714923\n        gamma = (sqrt(5) + 3) / 2       = 2.6180339887498948\n        phi   = (sqrt(5) + 1) / 2       = 1.6180339887498948\n\n        P and p, Q and q, ... etc. are inverse of each other. Another set of relations are commutation relations. Their\n    meaning is that when multiplying 4 generators that subsequently shift D around one of its edges one gets identity at\n    the end, half of these relations follow from the rest:\n\n            Qp = Pq, qP = pQ\n            Rp = Pr, rP = pR\n            Sp = Ps, sP = pS\n            Tp = Pt, tP = pT\n            Up = Pu, uP = pU\n            Rq = Qr, rQ = qR\n            Sq = Qs, sQ = qS\n            tq = QT, TQ = qt\n            uq = QU, UQ = qu\n            sr = RS, SR = rs\n            Tr = Rt, tR = rT\n            ur = RU, UR = ru\n            ts = ST, TS = st\n            Us = Su, uS = sU\n            Ut = Tu, uT = tU\n\n        The number of (unique) dodecahedra generated by k = 0, 1, ... 5 application of generator transforms (and no less) is\n            1, 12, 102, 812, 6402, 50412\n*/\n\n/* helper function :: exchanges the values if necessary so on return we have v0 <= v1 */\nvoid order(inout float v0, inout float v1)\n{\n    float vm = max(v0, v1);\n    v0 = min(v0, v1);\n    v1 = vm;\n}\n\n/* helper function :: smoothed minimum */\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5f + 0.5f * (b - a) / k, 0.0f, 1.0f);\n    return mix(b, a, h) - k * h * (1.0f - h);\n}\n\nfloat arccosh(float q)\n{\n    q = max(q, 1.0f);\n    float s = q + sqrt(q * q - 1.0f);\n    return log(s);\n}\n\nfloat hyp_norm(vec4 v)\n    { return dot(v.xyz, v.xyz) - v.w * v.w; }\n\nfloat hyp_dot(vec4 u, vec4 v)\n    { return dot(u.xyz, v.xyz) - u.w * v.w; }\n\nfloat hyp_distance(vec4 u, vec4 v)\n    { return arccosh(-hyp_dot(u, v)); }\n\n/* time-like vector normalization :: scales the vector to get\n   xx + yy + zz - ww = -1. Points of hyperbolic space H^3 are time-like 4-vectors */\nvec4 normalize_t(vec4 v)\n{\n    float inv_l = 1.0f / sqrt(-hyp_dot(v, v));\n    return inv_l * v;\n}\n\n/* space-like vector normalization :: scales the vector to get\n   xx + yy + zz - ww = +1. Tangent directions to H^3 are space-like 4-vectors */\nvec4 normalize_s(vec4 v)\n{\n    float inv_l = 1.0f / sqrt(hyp_dot(v, v));\n    return inv_l * v;\n}\n\n/* centers of neighbouring domains */\nconst float alpha = 1.2720196495140690f;        /* sqrt((sqrt(5) + 1) / 2)          */\nconst float beta  = 2.0581710272714923f;        /* sqrt(sqrt(5) + 2)                */\nconst float gamma = 2.6180339887498948f;        /* (sqrt(5) + 3) / 2                */\n\n/* face reflection directions */\nconst float mu    = 0.7071067811865475f;        /* 1 / sqrt(2)                      */\nconst float nu    = 1.1441228056353686f;        /* (1 + sqrt(5)) / (2 * sqrt(2))    */\nconst float tau   = 0.8994537199739336f;        /* sqrt(sqrt(5) + 1) / 2            */\n\n/* dodecahedron vertices */\nconst float psi   = 1.8512295868219161f;        /* sqrt(3 * sqrt(5) + 7) / 2       */\nconst float chi   = 1.4553466902253548f;        /* sqrt(2 * sqrt(5) + 4) / 2       */\nconst float rho   = 0.5558929702514212f;        /* sqrt(sqrt(5) - 1) / 2        */\n\n//==========================================================================================================================\n//      The main function: finds the point in the orbit of p under the action of described above hyperbolic isometries\n// group closest to the origin, or, the same, finds point equivalent to p in the main fundamental dodecahedron\n//==========================================================================================================================\nvec4 bounce(vec4 P)\n{\n    int k = 0;\n\n    /*\n        Hyperbolic reflection directions ::\n\n            {  mu,  nu, 0.0, tau }\n            { -mu, -nu, 0.0, tau }\n            { -mu,  nu, 0.0, tau }\n            {  mu, -nu, 0.0, tau }\n            { 0.0,  mu,  nu, tau }\n            { 0.0, -mu, -nu, tau }\n            { 0.0, -mu,  nu, tau }\n            { 0.0,  mu, -nu, tau }\n            {  nu, 0.0,  mu, tau }\n            { -nu, 0.0, -mu, tau }\n            { -nu, 0.0,  mu, tau }\n            {  nu, 0.0, -mu, tau }\n    */\n\n    /* to avoid possible infinite loops for points lying on the faces of the main dodecahedron */\n    while (k < 16)\n    {\n        vec3 q = abs(P.xyz);\n        q = mu * q + nu * q.yzx;\n\n        float W = tau * P.w;\n\n        if (q.x > q.y)\n        {\n            if (q.x > q.z)\n            {\n                /* q.x = mu * |p.x| + nu * |p.y| is maximal */\n                if (q.x > W)\n                {\n                    P = P - 2.0f * (q.x - W) * vec4(mu * sign(P.x), nu * sign(P.y), 0.0f, tau);\n                    P.xyz = -P.xyz;\n                    ++k;\n                    continue;\n                }\n            }\n            else\n            {\n                /* q.z = mu * |p.z| + nu * |p.x| is maximal */\n                if (q.z > W)\n                {\n                    P = P - 2.0f * (q.z - W) * vec4(nu * sign(P.x), 0.0f, mu * sign(P.z), tau);\n                    P.xyz = -P.xyz;\n                    ++k;\n                    continue;\n                }\n            }\n\n        }\n        else    /* q.y >= q.x */\n        {\n            if (q.z > q.y)\n            {\n                /* q.z = mu * |p.z| + nu * |p.x| is maximal */\n                if (q.z > W)\n                {\n                    P = P - 2.0f * (q.z - W) * vec4(nu * sign(P.x), 0.0f, mu * sign(P.z), tau);\n                    P.xyz = -P.xyz;\n                    ++k;\n                    continue;\n                }\n            }\n            else\n            {\n                /* q.y = mu * |p.y| + nu * |p.z| is maximal */\n                if (q.y > W)\n                {\n                    P = P - 2.0f * (q.y - W) * vec4(0.0f, mu * sign(P.y), nu * sign(P.z), tau);\n                    P.xyz = -P.xyz;\n                    ++k;\n                    continue;\n                }\n            }\n        }\n\n        break;\n    }\n\n    return P;\n}\n\nfloat spheric_sdf(vec4 p)\n{\n    p = bounce(p);\n    float d = arccosh(p.w);\n    float sdf0 = d - 0.31f;\n    float sdf1 = 1.01f - d;\n    return min(sdf0, sdf1);\n}\n\nfloat face_sdf(vec4 p)\n{\n    p = bounce(p);\n    float d = arccosh(p.w);\n\n    vec3 q = abs(p.xyz);\n    q = alpha * q + beta * q.yzx;\n\n    float dp = gamma * p.w - max(max(q.x, q.y), q.z);\n    float d1 = arccosh(dp);\n\n\n    float sdf0 = d - 0.31f;\n\n    float b_sdf = 0.98f - d;\n    float f_sdf = 0.5f * (d1 - d - 0.018f);\n    float sdf1 = max(b_sdf, f_sdf);\n\n    return min(sdf0, sdf1);\n}\n\n/*\n    Vertices of the main dodecahedron ::\n\n        { -tau, -tau, -tau, psi }\n        {  tau,  tau,  tau, psi }\n        {  tau, -tau, -tau, psi }\n        { -tau,  tau,  tau, psi }\n        { -tau,  tau, -tau, psi }\n        {  tau, -tau,  tau, psi }\n        {  tau,  tau, -tau, psi }\n        { -tau, -tau,  tau, psi }\n        { -rho,  0.0, -chi, psi }\n        {  rho,  0.0,  chi, psi }\n        {  rho,  0.0, -chi, psi }\n        { -rho,  0.0,  chi, psi }\n        { -chi, -rho,  0.0, psi }\n        {  chi,  rho,  0.0, psi }\n        { -chi,  rho,  0.0, psi }\n        {  chi, -rho,  0.0, psi }\n        {  0.0, -chi, -rho, psi }\n        {  0.0,  chi,  rho, psi }\n        {  0.0, -chi,  rho, psi }\n        {  0.0,  chi, -rho, psi }\n*/\n\nfloat edge_sdf(vec4 p)\n{\n    p = bounce(p);\n\n    vec4 c = vec4(chi, -chi, rho, -rho);\n\n    vec4 A = p.x * c.yxyx + p.y * c.wzzw;\n    vec4 B = p.y * c.xyyx + p.z * c.zzww;\n    vec4 C = p.z * c.yyxx + p.x * c.zwzw;\n    vec4 D = tau * vec4(p.yxz - p.zyx - p.xzy, p.x + p.y + p.z);\n    vec4 E = -D.yxzw;\n\n    vec4 abcd = max(max(A, B), max(C, D));\n\n    E.xy = max(E.xy, E.zw);\n    float e = max(E.x, E.y);\n\n    order(abcd.x, abcd.y);\n    order(abcd.y, abcd.z);\n    order(abcd.z, abcd.w);\n    order(abcd.w, e);\n\n    abcd.xy = max(abcd.xy, abcd.zw);\n\n    vec2 dp = psi * p.w - vec2(max(abcd.x, abcd.y), e);\n\n    float a1 = arccosh(dp.x);\n    float a2 = arccosh(dp.y);\n    float e_sdf = 0.75f * (a1 + a2 - 1.078f);\n    float v_sdf = a2 - 0.197f;\n    float d = smin(e_sdf, v_sdf, 0.005f);\n    return d;\n}\n\nfloat sdf(vec4 p)\n{\n    //return spheric_sdf(p);\n    //return face_sdf(p);\n    return edge_sdf(p);\n}\n\nvec4 raymarch(vec4 origin, vec4 ray, out float dist)\n{\n    const float eps = 0.0005f;\n    dist = -1.0f;\n\n    vec4 p = origin;\n    float d = sdf(p);\n    float t = 0.0f;\n\n    const int MAX_ITERATIONS = 64;\n\n    int i = 0;\n    while ((i < MAX_ITERATIONS) && (d > eps) && (t < 32.0))\n    {\n        t += d;\n        //float s = t;                            /* sh(t) = t + ttt/6 + ttttt/120 + ... */\n        float s = sinh(t);\n        float c = sqrt(1.0f + s * s);\n        p = c * origin + s * ray;\n        d = sdf(p);\n        ++i;\n    }\n\n    if (d < 0.05f)\n        dist = t;\n\n    return p;\n}\n\n//==============================================================================================================================================================\n//      SDF gradient :: standard 6-point evaluation\n//      Standard orthonormal basis at origin parallel translated along the geodesic into a generic point P = { x, y, z, w }\n//  looks like:\n//\n//       X = { 1.0f + (x * x) / (w + 1),        (x * y) / (w + 1),        (x * z) / (w + 1), x },\n//       Y = {        (y * x) / (w + 1), 1.0f + (y * y) / (w + 1),        (y * z) / (w + 1), y },\n//       Z = {        (z * x) / (w + 1),        (z * y) / (w + 1), 1.0f + (z * z) / (w + 1), z },\n//\n//      They are normalized, orthogonal among themselves and orthogonal to P.\n//==============================================================================================================================================================\nvec4 hyperbolic_gradient6(vec4 p)\n{\n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float inv_w = 1.0f / (1.0f + p.w);\n\n    vec4 X = vec4(1.0f + inv_w * x * x,        inv_w * x * y,        inv_w * x * z, x);\n    vec4 Y = vec4(       inv_w * y * x, 1.0f + inv_w * y * y,        inv_w * y * z, y);\n    vec4 Z = vec4(       inv_w * z * x,        inv_w * z * y, 1.0f + inv_w * z * z, z);\n\n    const float eps = 0.00625f;\n\n    float di = sdf(normalize_t(p + eps * X)) - sdf(normalize_t(p - eps * X));\n    float dj = sdf(normalize_t(p + eps * Y)) - sdf(normalize_t(p - eps * Y));\n    float dk = sdf(normalize_t(p + eps * Z)) - sdf(normalize_t(p - eps * Z));\n\n    vec4 g = di * X + dj * Y + dk * Z;\n    return normalize_s(g);\n}\n\n/* distance to origin :: arccosh(2) = 1.316958 */\nconst vec4 light_ws[8] = vec4[]\n(\n    vec4(+1, +1, +1, 2),\n    vec4(+1, +1, -1, 2),\n    vec4(+1, -1, +1, 2),\n    vec4(+1, -1, -1, 2),\n    vec4(-1, +1, +1, 2),\n    vec4(-1, +1, -1, 2),\n    vec4(-1, -1, +1, 2),\n    vec4(-1, -1, -1, 2)\n);\n\n//==============================================================================================================================================================\n//   Computes direction in 4-space hyperbolic-orthogonal to P, A, and B\n//   Note: if P is time-like (e.g. represents a point), and A, B are \n// space-like (e.g. represent directions) then cross-product is also space-like, \n// so is space-like normalizable\n//==============================================================================================================================================================\nvec4 hyp_cross(vec4 P, vec4 A, vec4 B)\n{\n    /* six 2x2 minors constructed from the rows A and B */\n    vec4 det2x2_1 = A * B.yzwx - B * A.yzwx;       /* xy, yz, zw, wx */\n    vec2 det2x2_2 = A.xy * B.zw - B.xy * A.zw;     /* xz, yw */\n\n    return vec4( \n        +P.y * det2x2_1.z - P.z * det2x2_2.y + P.w * det2x2_1.y,\n        -P.z * det2x2_1.w - P.w * det2x2_2.x - P.x * det2x2_1.z,\n        +P.w * det2x2_1.x + P.x * det2x2_2.y + P.y * det2x2_1.w,\n        +P.x * det2x2_1.y - P.y * det2x2_2.x + P.z * det2x2_1.x\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 1.77f * (fragCoord - 0.5f * iResolution.xy) / iResolution.y;\n\n    float t = 1.7f * iTime;\n\n    float t0 = 0.375f * t -  0.213f;\n    float t1 = 0.151f * t +  2.091f;\n    float t2 = 0.253f * t - 11.512f;\n    float t3 = 0.853f * t +  3.277f;\n\n    float c0 = cos(t0);\n    float s0 = sin(t0);\n    float c1 = cos(t1);\n    float s1 = sin(t1);\n    float c2 = cos(t2);\n    float s2 = sin(t2);\n    float c3 = cos(t3);\n    float s3 = sin(t3);\n    \n    float R = 1.32f + 0.32f * c1 + 0.371f * s0;\n    float W = sqrt(1.0f + R * R);\n    vec3 camera_xyz = R * normalize(vec3(-c1 * s0, s1 *  c0 * s2, s0 * c2));\n    vec4 camera_ws = vec4(camera_xyz, W);\n\n    /* compute some random directions in 3 space, lift them to hyperboloid and \n       apply Gram-Schmidt orthogonalization process on the fly */\n\n    float r = 0.75f;                                 /* look at close to origin */\n    vec3 z = camera_xyz + r * vec3(s1 * c0, -s0 * c2, s3 *  c1 * s2); \n    vec4 Z = vec4(z, dot(camera_xyz, z) / W);        /* lift it up to hyperboloid tangent space, Z is orthogonal to camera_ws */\n    Z = normalize_s(Z);                              /* normalize */\n    \n    vec3 x = vec3(s2 * c0, -s1 * c1, c2);            /* generate some random direction */\n    vec4 X = vec4(x, dot(camera_xyz, x) / W);        /* lift it up to hyperboloid tangent space, X is orthogonal to camera_ws */\n    X = X - hyp_dot(X, Z) * Z;                       /* make it hyperbolic-orthogonal to Z, it should remain orthogonal to camera_ws */\n    X = normalize_s(X);                              /* normalize */\n\n    vec4 Y = hyp_cross(camera_ws, Z, X);             /* compute the last basis vector as a cross product */\n    Y = normalize_s(Y);                              /* normalize, should not be needed */\n\n    vec4 view_ray = uv.x * X + uv.y * Y - Z;\n    view_ray = normalize_s(view_ray);\n\n    float dist;\n    vec4 position = raymarch(camera_ws, view_ray, dist);\n    vec3 color = vec3(0.0f);\n\n    if (dist >= 0.0f && dist < 7.2f)\n    {\n        float W = position.w;\n        vec4 n = hyperbolic_gradient6(position);\n        \n        const vec3 hue = vec3(1.41f, 1.73f, 2.72f);\n        float c = 1.0 / (1.0f + 0.175f * sqrt(position.w));\n        vec3 rgb = pow(vec3(c), 4.0f * hue);\n\n        vec3 view = camera_ws.xyz - position.xyz;\n        vec4 v = vec4(view, dot(view, position.xyz) / W);\n        v = normalize_s(v);                                     /* unit view vector at tangent space at position */\n\n        color = 0.225f * rgb;                                   /* ambient */\n\n        for (int i = 0; i < 8; ++i)\n        {\n            vec4 light = light_ws[i];\n            float dp = dot(light.xyz, position.xyz);\n            float hyp_dp = W * light.w - dp;                    /* ch(distance), can be used directly for attenuation */\n\n            /* lift of the light direction to the hyperboloid */\n            vec4 l = vec4(light.xyz - position.xyz, -W + ((dp + 1.0f) / W));\n            l = normalize_s(l);                                 /* unit light vector at tangent space at position */\n\n            float a = 0.75f / (1.0f + 0.025f * hyp_dp);\n\n            float cos_theta = max(hyp_dot(l, n), 0.0f);\n            vec4 h = normalize_s(l + v);\n\n            float cos_alpha = max(hyp_dot(h, n), 0.0f);\n            vec3 diffuse  = (0.475f * cos_theta) * rgb;\n            vec3 specular = vec3(0.562f) * pow(cos_alpha, 88.0f);\n\n            color += a * (diffuse + specular);\n        }\n    }\n\n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Dd33RB","date":"0","viewed":0,"name":"Fork Isometries neozhaolia 602","username":"neozhaoliang","description":"Isometries of hyperbolic space in Poincare's disk model","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI        3.141592654\n\nmat2 rot2d(float a) {\n    float ca = cos(a), sa = sin(a);\n    return mat2(ca, -sa, sa, ca);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x + z.y * w.y,\n        -z.x * w.y + z.y * w.x\n    ) / dot(w, w);\n}\n\nvec2 cconj(vec2 z) {\n    return vec2(z.x, -z.y);\n}\n\nstruct Mobius {\n    vec2 A, B, C, D;\n};\n\nfloat hypot (vec2 z) {\n    float x = abs(z.x);\n    float y = abs(z.y);\n    float t = min(x, y);\n    x = max(x, y);\n    t = t / x;\n    return x * sqrt(1.0 + t * t);\n}\n\n\nfloat e2h(float r) {\n    return 2. * atanh(r);\n}\n\nfloat h2e(float r) {\n    return tanh(0.5 * r);\n}\n\nMobius mobInverse(Mobius m) {\n    return Mobius(\n        m.D, -m.B, -m.C, m.A\n    );\n}\n\nvec2 applyMobius(Mobius m, vec2 z) {\n    return cdiv(cmul(m.A, z) + m.B, cmul(m.C, z) + m.D);\n}\n\nMobius translation(vec2 p) {\n    return Mobius(\n        vec2(1, 0), -p, -cconj(p), vec2(1, 0)\n    );\n}\n\nMobius translation2(vec2 p) {\n    return Mobius(\n        vec2(1, 0), p, cconj(p), vec2(1, 0)\n    );\n}\n\nMobius rotation(float a) {\n    return Mobius(\n        vec2(cos(a), sin(a)), vec2(0), vec2(0), vec2(1, 0)\n    );\n}\n\nMobius composite(Mobius m1, Mobius m2) {\n    vec2 A = cmul(m1.A, m2.A) + cmul(m1.B, m2.C);\n    vec2 B = cmul(m1.A, m2.B) + cmul(m1.B, m2.D);\n    vec2 C = cmul(m1.C, m2.A) + cmul(m1.D, m2.C);\n    vec2 D = cmul(m1.C, m2.B) + cmul(m1.D, m2.D);\n    return Mobius(A, B, C, D);\n}\n\nMobius composite(Mobius m1, Mobius m2, Mobius m3) {\n    return composite(m1, composite(m2, m3));\n}\n\nMobius rotation(vec2 p, float a) {\n    Mobius m1 = translation(-p);\n    Mobius m2 = rotation(a);\n    Mobius m3 = translation(p);\n    return composite(m3, m2, m1);\n}\n\n\nvec2 recGrid(vec2 z, vec2 size) {\n    return mod(z + 0.5 * size, size) - 0.5 * size;\n}\n\nvec2 polarGrid(vec2 z, vec2 size) {\n    float theta = atan(z.y, z.x);\n    float r = e2h(hypot(z));\n    return recGrid(vec2(r, theta), size);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 c = vec2(0.2, 0.4);\n    Mobius m = translation(c);\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv *= 1.1;\n    vec2 p = uv;\n    vec3 col = vec3(1);\n    \n    if (length(p) < 1.) {\n\n        p = applyMobius(m, p);\n        p = rot2d(iTime / 3.) * p;\n        vec2 polar = polarGrid(p, vec2(.5, PI/6.));\n        float d1 = abs(polar.x);\n        float d2 = abs(polar.y);\n        \n                \n        float K = hypot(vec2(dFdx(e2h(length(p))), dFdy(e2h(length(p)))));\n        d1 /= K * iResolution.y / 2.;\n        \n       \n        \n        float L = hypot(vec2(dFdx(atan(p.y, p.x)), dFdy(atan(p.y, p.x))));\n        d2 /= L * iResolution.y / 2.;\n        \n        float d = hypot(vec2(d1, d2));\n\n        float sf = 2. / iResolution.y;\n        col = mix(col, vec3(0), 1. - smoothstep(0.00, sf, d1 - sf));\n        col = mix(col, vec3(0), 1. - smoothstep(0.00, sf, d2 - sf));\n       \n        col = mix(col, vec3(0), 1. - smoothstep(0.00, sf, d - 4.*sf));\n    }\n    \n    vec2 q = vec2(0.1, 0);\n             \n    q = applyMobius(m, q);\n  \n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0.00, 0.01, abs(length(p-q)) - 0.03));\n    col = mix(col, vec3(0), 1. - smoothstep(0.00, 0.01, abs(length(p) - 1.0) - 0.01));\n\n    fragColor = vec4(sqrt(max(col, 0.)), 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Nlcfzj","date":"0","viewed":0,"name":"Fork Jigsaw neozhaolia 803","username":"neozhaoliang","description":"Raymarching an extruded jigsaw pattern.","likes":0,"published":0,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\n#define FAR 10.\n\n\n\n// Raymarching a textured XY-plane, with a bit of distortion thrown in.\nfloat map(vec3 p){\n    \n    // Sampling the 2D jigsaw pattern value from the texture, then passing it\n    // into a relatively cheap 3D extrusion function to give the final distance\n    // value.\n    vec4 jigDist = texture(iChannel0, p.xy/4. + .5);\n    vec2 jig = jigsaw(p - vec3(moveXY(iTime), 0), jigDist);\n    \n    //surf2D = jig.y; // Just the 2D value. Used for some cheap edging.\n \n    return jig.x*.866; // 3D extruded distance field value.\n    \n    \n}\n\n\n// Standard raymarching function.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0., d;\n    \n    for(int i = 0; i<80; i++){\n    \n        d = map(ro + rd*t);\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += d;\n    }\n\n    return min(t, FAR);\n    \n}\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .001;  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    dist += hash31(ro + rd)*.007;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist); //  map(ro + rd*dist + hash31(ro + rd)*dist*.03);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .01, .25); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist > end) break; \n    }\n\n    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also just for kicks. :)\n    return min(max(shade, 0.) + .05, 1.); \n}\n\n\n// An AO routine, tweaked to suit this particular example, and based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 5., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.1/5.; \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 normal(in vec3 p) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n\n// With the spare cycles, I thought I'd splash out and use Dave's more reliable hash function. :)\n//\n// Dave's hash function. More reliable with large values, but will still eventually break down.\n//\n// Hash without Sine.\n// Creative Commons Attribution-ShareAlike 4.0 International Public License.\n// Created by David Hoskins.\n// vec3 to vec3.\nvec3 hash33G(vec3 p){\n\n\tp = fract(p * vec3(.1031, .1030, .0973));\n    p += dot(p, p.yxz + 19.19);\n    p = fract((p.xxy + p.yxx)*p.zyx)*2. - 1.;\n    return p;\n\n}\n\n\n// Gradient noise, or Perlin noise. Break space into cubes, attach random 3D vectors to each of the eight \n// verticies, then smoothly interpolate between them. It's that simple. With the exception of some simple\n// changes and some commentary addition, this is basically IQ's implementation.\n// \nfloat gradN3D(in vec3 p){\n   \n    // Utilility bector.\n    const vec2 e = vec2(0, 1);\n    \n    // Set up the cubic grid.\n    // Integer value - unique to each cube, and used as an ID to generate random vectors for the\n    // cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed\n    // to them.\n    vec3 ip = floor(p); \n    \n    p -= ip; // Fractional position within the cube.\n\n    // Smoothing - for smooth interpolation. Comment it out to see the\n    //vec3 w = p*p*p*(p*(p*6. - 15.) + 10.); // Quintic smoothing. Slower, but derivaties are smooth too.\n    vec3 w = p*p*(3. - 2.*p); // Cubic smoothing. \n    //vec3 w = p*p*p; w = (7. + (w - 7.) * p) * w;\t// Super smooth, but less practical.\n    //vec3 w = .5 - .5*cos(p*3.14159); // Cosinusoidal smoothing.\n    //vec3 w = p; // No smoothing. Gives a blocky appearance. Can look cool under the right conditions.\n    \n    // Smoothly interpolating between the eight verticies of the cube. Due to the shared verticies between\n    // cubes, the result is blending of random values throughout the 3D space.\n    float c = mix(mix(mix(dot(hash33G(ip + e.xxx), p - e.xxx), dot(hash33G(ip + e.yxx), p - e.yxx), w.x),\n                      mix(dot(hash33G(ip + e.xyx), p - e.xyx), dot(hash33G(ip + e.yyx), p - e.yyx), w.x), w.y),\n                  mix(mix(dot(hash33G(ip + e.xxy), p - e.xxy), dot(hash33G(ip + e.yxy), p - e.yxy), w.x),\n                      mix(dot(hash33G(ip + e.xyy), p - e.xyy), dot(hash33G(ip + e.yyy), p - e.yyy), w.x), w.y), w.z);\n    \n    // Taking the final result, and putting it into the zero to one range.\n    return c*.5 + .5; // Range: [0, 1].\n\n}\n\n// Gradient noise fBm.\nfloat fBm3D(in vec3 p){\n    \n    return gradN3D(p)*.57 + gradN3D(p*2.)*.28 + gradN3D(p*4.)*.15;\n}\n\n#ifdef FAKE_ENVIROMENT_REFLECTIONS\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 eMap(vec3 rd, vec3 sn){\n    \n    vec3 sRd = rd; // Save rd, just for some mixing at the end.\n    \n    // Add a time component, scale, then pass into the noise function.\n    rd.xy -= iTime*.25;\n    rd *= 3.;\n    \n    //vec3 tx = tex3D(iChannel0, rd/3., sn);\n    //float c = dot(tx*tx, vec3(.299, .587, .114));\n    \n    float c = fBm3D(rd);\n    c = smoothstep(0.5, 1., c); // Darken and add contast for more of a spotlight look.\n    \n    //vec3 col = vec3(c, c*c, c*c*c*c).zyx; // Simple, warm coloring.\n    //vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)).zyx; // More color.\n    vec3 col = pow(vec3(1.5, 1, 1)*c, vec3(1, 2.5, 12)).zyx; // More color.\n    \n    // Mix in some more red to tone it down and return.\n    return mix(col, col.yzx, sRd*.25 + .25); \n    \n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Unit direction ray.\n    vec3 rd = normalize(vec3(fragCoord - iResolution.xy*.5, min(iResolution.y, 800.)*.5));\n    // Slight lens warping.\n    rd = normalize(vec3(rd.xy, sqrt(rd.z*rd.z - dot(rd.xy, rd.xy)*.03)));\n    \n    //vec3 ro = vec3(0. + iTime/4., 0. + iTime/8., -1.5);\n    // The camera movement is provided via texture scrolling. We're doing it\n    // this way, because it'd be very difficult to wrap this particular \n    // pattern. Not impossible, but compilicated. Therefore, texture area\n    // has to span beyond the canvas borders for the effect to work.\n    vec3 ro = vec3(0, 0, -1.);\n    // Light -- set up somewhere near the camera.\n    vec3 lp = ro + vec3(-.25, .75, 0);\n    \n    \n    // Tilting the camera ever so slightly.\n    #ifdef CAMERA_TWO\n    rd.yz *= rot2(-.2);\n    rd.xy *= rot2(.1);\n    #else\n    rd.yz *= rot2(-.03);\n    rd.xy *= rot2(.03);\n    #endif\n    \n    \n    // Standard raymarching segment. Because of the straight forward setup, very few \n    // iterations are needed.\n    float t = trace(ro, rd);\n    vec4 dcc = dc;\n    \n    // Saving the unique cell ID and the 2D surface value.\n    vec2 svCellID = cellID;\n    //float svSurf2D = surf2D;\n    \n    // Initiate the scene color.\n    vec3 col = vec3(0);\n    \n    // Trivial surface hit. I think all rays would hit this particular surface.\n    if(t<FAR){\n    \n        vec3 sp = ro + rd*t;\n        vec3 sn = normal(sp);\n        vec3 l = lp - sp;\n        float lDist = length(l);\n        l /= max(lDist, .0001);\n\n        //lDist /= 3.;\n        float atten = 1./(1. + lDist*.05);\n\n        // Ambient occlusion and shadows.\n        float ao = calcAO(sp, sn);\n        float sh = softShadow(sp + sn*.002, lp, 4., t); // Set to \"1.,\" if you can do without them.\n        sh = min(sh + ao*.2, 1.);\n\n\n        float dif = max(dot(l, sn), 0.); // Diffuse term.\n        dif *= dif; // Ramping up the diffuse.\n        float spe = pow(max( dot( reflect(-l, sn), -rd ), 0.0 ), 32.); // Specular term.\n        float fre = clamp(1.0 + dot(rd, sn), 0.0, 1.0); // Fresnel reflection term.\n\n        // Schlick appoximation. It tones down the specular term.\n        float Schlick = pow( 1. - max(dot(rd, normalize(rd + l)), 0.), 5.0);\n        float fre2 = mix(.1, 1., Schlick);  //F0 = .2 - Hard clay... or close enough.\n\n        // Texture value. Note that it's moving along XY to match the scrolling \"Buf A\" texture.\n        vec3 tSp = sp;\n        tSp.xy -= moveXY(iTime);\n        \n        // Shadertoy texture, but I went textureless for this one.\n        //vec3 objCol = mix(tex3D(iChannel1, sp/1., sn), tex3D(iChannel1, sp*2., sn), .34);\n        //vec3 objCol = tex3D(iChannel1, tSp/2., sn);//*texture(iChannel0, fract(sp.xy)).xyz;\n        //objCol = smoothstep(-.3, .3, objCol);\n\n        // COLORING THE JIGSAW PIECES.\n        //\n        vec3 objCol = vec3(1);\n        // Some random colors based on the unique jigsaw piece ID. Used for coloring.\n        vec3 rnd = vec3(hash(svCellID + 72.5), hash(svCellID + 37.1), hash(svCellID + 93.7));\n        //vec3 rnd = hash33G(svCellID.xyx + vec3(72, 37, 93))*.5 + .5;\n  \n        // Random base colors. Orange tones, I think.\n        vec3 cellCol = vec3(rnd.x*.2 + .8, rnd.z*.5 + .5, rnd.z*.3 + .3);\n        \n        // Mixing in some fire tones... I'll usually try this out if things aren't working. :)\n        float c = dot(cellCol, vec3(.299, .587, .114));\n        cellCol = cellCol*.5  + pow(min(vec3(1.5, 1, 1)*c, 1.), vec3(1, 3, 16));\n        \n        // Too much orange, so make some of them green for an autumn feel.\n        if(rnd.y<=.5) cellCol = min(cellCol*2., 1.).yxz;\n\n        // Color a portion of the pieces with the autumn palette, but leave some gray. It seemed\n        // like a fun thing to do at the time. :)\n        if(fract(rnd.x*289.97 + .73)>.15) objCol *= cellCol;\n        \n        objCol = mix(objCol, objCol.xzy, .15); // Tone the color down. \n        \n        #ifdef GREY\n        objCol = vec3(.9, 1.05, 1.2);\n        #endif\n        \n        // Blue\n        //objCol = objCol.zyx;\n        // Pink.\n        //objCol = objCol.xzy;\n        // Grey tones.\n        //objCol = vec3(1)*dot(cellCol, vec3(.299, .587, .114));\n \n\n        // Matches the pylon routine in the \"jigsaw\" construction routine called\n        // in the raymarching function.\n        //\n        float cellHeight = getCellHeight(svCellID); // Cell (jigsaw piece) height.\n        \n        // Put edges near the top of the block.\n        objCol *= smoothstep(0., .003, abs(sp.z - cellHeight + .5 - .006) - .00075)*.8 + .2; // Dark edges.\n     \n        // Put a 2D pattern on the top of the block above the dark edge.\n        if((abs(sp.z - cellHeight) - .5 + .006)>0.){\n             //objCol *= smoothstep(0., .0075, max(-svSurf2D, 0.) - .01)*.8 + .2; // Dark edges.\n             //objCol *= (1. - smoothstep(0., .01, -svH2 - .01))*.35 + 1.; // Light edges.\n            \n            // Wavy gradient contour pattern. You could put anything you want here, or nothing\n            // at all if you're super boring. :)\n            objCol *= clamp(-sin(fBm3D(vec3(tSp.xy, 0))*6.2831*96.)*5. + 2.9, 0., 1.)*.2 + .8;\n            \n        }\n        \n        // I originally put the pattern down the sides, but went with the 2D pattern above.\n        //objCol *= clamp(-sin(fBm3D(tSp)*6.2831*96.)*4. + 2.9, 0., 1.)*.2 + .8;\n        \n        // Some gradient fBm sprinkles to break things up and give a slight papery feel.\n        objCol *= fBm3D(tSp*80.)*.4 + .8;\n\n\n        // Very basic lighting. Diffuse, ambient and specular.\n        col = objCol*(dif + .25 + vec3(1, .7, .4)*spe*fre2);\n\n\t\t#ifdef FAKE_ENVIROMENT_REFLECTIONS\n        // Add the fake environmapping. Not as good as a reflective pass, but it gives that\n        // impresssion for just a fraction of the cost.\n        vec3 em = eMap(reflect(rd, sn), sn); // Fake environment mapping.\n        col += col*em*2.;\n        #endif\n\n        // Apply the light attenuation, ambient occlusion and shadows.\n        col *= atten*ao*sh;\n\n    }\n    \n    // Subtle vignette.\n    vec2 uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625) + .1;\n    // Colored variation.\n    //col = mix(col.zyx/2., col, \n              //pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125));\n\n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int N = 4;\n\n#define PI 3.141592653\n\n// N real numbers for the shifts of the grids.\nfloat[N] shifts;\n\n// directions of the grids, will be initialized later\nvec2[N] grids;\n\n\nstruct Rhombus\n{\n    // r, s for the r-th and s-th grids.\n    int r;\n    int s;\n\n    // kr, ks for the lines in the two grids\n    float kr;\n    float ks;\n\n    // center and vertices of the rhombus\n    vec2 cen;\n    vec2[4] verts;\n\n    // vertices of the tunnels, each tunnel contains two pieces.\n    vec2[4] inset1;\n    vec2[4] inset2;\n};\n\nvoid init_grids()\n{\n    float FN = float(N), theta; \n    for(int k = 0; k < N; k++)\n    {\n        theta = (N % 2 == 0) ? PI / FN * float(k) : PI / FN * float(k) * 2.;\n        grids[k] = vec2(cos(theta), sin(theta));\n        // for N=5 (0.2, 0.2, 0.2, 0.2, 0.2) gives the classical Penrose tiling.\n        // set all shifts to 0.5 will give the star pattern which has ten thin rhombus\n        // around a vertex hence is non-Penrose.\n        // shifts[k] = 0.5;\n        shifts[k] = 1./FN;\n    }\n}\n\nfloat cross_prod(vec2 p, vec2 q)\n{\n    return p.x * q.y - p.y * q.x;\n}\n\n// signed distance function to a polygon using winding number\nfloat sdPoly4(in vec2 p, in vec2[4] verts)\n{\n    float d = dot(p - verts[0], p - verts[0]);\n    float s = 1.0;\n    for(int i = 0, j = 3; i < 4; j = i, i++)\n    {\n        vec2 e = verts[j] - verts[i];\n        vec2 w = p - verts[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1.);\n        d = min(d, dot(b, b));\n\n        bvec3 cond = bvec3(p.y >= verts[i].y, p.y < verts[j].y, cross_prod(e, w) > 0.);\n        if (all(cond) || all(not(cond)))\n            s *= -1.0;            \n    }\n    return s * sqrt(d);\n}\n\n// project a vector p to the k-th grid, note each grid line is shifted so we need\n// to add the corresponding shifts.\nfloat project_point_grid(vec2 p, int k)\n{\n    return dot(p, grids[k]) + shifts[k];\n}\n\n// find the vertices of the rhombus corresponding to the intersection point P,\n// where P is the intersection of the kr-th line and ks-th line in the r/s grids.\nvoid solve_rhombus_verts(int r, int s, float kr, float ks, out vec2[4] verts)\n{\n    vec2 P = grids[r] * (ks - shifts[s]) - grids[s] * (kr - shifts[r]);\n    P = vec2(-P.y, P.x) / grids[s - r].y;\n    vec2 sum = kr * grids[r] + ks * grids[s];\n    for(int k = 0; k < N; k++)\n    {\n        if ((k != r) && (k != s))\n            sum += grids[k] * ceil(project_point_grid(P, k));\n    }\n    verts[0] = sum;\n    verts[1] = sum + grids[r];\n    verts[3] = sum + grids[s];\n    verts[2] = verts[1] + grids[s];\n}\n\nvec2 debruijn_transform(vec2 p)\n{\n    vec2 sum = vec2(0.0);\n    for(int k = 0; k < N; k++)\n    {\n        sum += grids[k] * project_point_grid(p, k);\n    }\n    return sum;\n}\n\nRhombus get_mapped_rhombus(vec2 p, out vec2 q)\n{\n    q = debruijn_transform(p);\n    Rhombus rb;\n    float kr, ks;\n    vec2[4] verts;\n    float[N] pindex;\n    for (int i = 0; i < N; i++)\n    {\n        pindex[i] = floor(project_point_grid(p, i));\n    }\n    for(int r = 0; r < N-1; r++)\n    {\n        for(int s = r+1; s < N; s++)\n        {\n            for(float dr = -1.; dr < 2.; dr += 1.0)\n            {\n                for(float ds = -1.; ds < dr+2.; ds += 1.0)\n                {\n                    kr = pindex[r] + dr;\n                    ks = pindex[s] + ds;\n                    solve_rhombus_verts(r, s, kr, ks, verts);\n                    if (sdPoly4(q, verts) < 0.)\n                    {\n                        rb.r = r, rb.s = s, rb.kr = kr, rb.ks = ks;\n                        rb.verts = verts;\n                        rb.cen = (verts[0] + verts[1] + verts[2] + verts[3]) / 4.0;\n                        return rb;\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n// Used for debug purposes, but it does give you a better look at the \n// pattern outline.\n//#define FLAT_PATTERN\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Translational movement.\nvec2 moveXY(float t){\n    return vec2(1./4., -1./12.)*t;\n}\n\n\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\nvec4 dc = vec4(1e5);\n\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n// vec2 to float hash.\nfloat hash(vec2 p){\n    return fract(sin(dot(p, vec2(41.71, 112.97)))*43758.5453);\n}\n\n// vec3 to float hash.\nfloat hash31(vec3 p){\n   \n    float n = dot(p, vec3(13.163, 157.247, 7.951)); \n    return fract(sin(n)*43758.5453); \n}\n\n// Unique jigsaw piece cell ID.\nvec2 cellID;\n\n/*\n// Random stepped height field.\nfloat getCellHeight(vec2 id){\n    \n    float cellHeight = hash(id);\n    cellHeight = floor(cellHeight*7.999)/7.;\n    return cellHeight*.075;\n    \n}\n*/\n\n// Sinusoidal stepped height field.\nfloat getCellHeight(vec2 p){\n    float cellHeight = (dot(sin(p*2.2 - cos(p.yx*1.4)), vec2(.25)) + .5);\n    return floor(cellHeight*7.999)/90.;\n}\n\n\nfloat jigsawPiece(vec2 p, vec2 ip){\n    // Random ID threshold.\n    const float rnd = .5;    \n    \n    // Four random border IDs.\n    vec4 idJoinNSEW = vec4(hash(ip + vec2(0, .5)), hash(ip + vec2(0, -.5)), \n                           hash(ip + vec2(.5, 0)), hash(ip + vec2(-.5, 0)));\n    \n    \n    const float ew = .025; // Jigsaw edge width.\n    const float cw = .14; // Jigsaw connector circle width.\n    // Jigsaw circle offset perpendicularly from the border. If you change this,\n    // find the \"sR\" varialbe below, and make adjustments there too.\n    vec4 sR = vec4(.07); \n\n    vec4 sNSEW = vec4(idJoinNSEW.x>rnd? 1.: -1., idJoinNSEW.y>rnd? 1.: -1., \n                      idJoinNSEW.z>rnd? 1.: -1., idJoinNSEW.w>rnd? 1.: -1.);\n\n   \n    float checkerPat = (mod(ip.x + ip.y, 2.)<.5)? 1. : -1.;\n    // Used to reorient tiles, depending on the checkerboard setup.\n    vec2 e = checkerPat>0.? vec2(1, 0) : vec2(0, 1); \n    \n    vec2 lROffs = vec2(2); // Large circle offset away from the center.\n\n    float lR = length(vec2(.5, .5) -  vec2(0, -lROffs.y));\n    \n    // Move the point perpendicularly away from the border, then construct a large\n    // circle equal in radius from the new central point to the corner of the square\n    // side. In this case, due to symmetry, all circles will have the same radius.\n    //\n\n    float c2N = length(p + lROffs.y*e.yx) - lR + ew/2.;\n    float c2S = length(p - lROffs.y*e.yx) - lR + ew/2.; //画一个比 lR 再小一点的圆\n    float c2E = length(p + (1. + lROffs.x)*e.xy) - lR - ew/2.;\n    float c2W = length(p - (1. + lROffs.x)*e.xy) - lR - ew/2.;\n    float d = max(c2N, c2S);\n    d = smax(d, -min(c2E, c2W), .05);\n\n    // Equivalent to the lines above, just less work for the GPU.\n    //float c2NS = length(abs(p) + lROffs.y*e.yx) - lR + ew/2.;\n    //float c2EW = length(abs(p) - (1. + lROffs.x)*e.xy) - lR - ew/2.;\n    //float d = smax(c2NS, -c2EW, .05);\n    \n    \n    \n    // Damn logic. If you switch the points based on checker pattern convexity, you have\n    // to rotate the unique border IDs with them. So obvious, but this mistake cost me more time \n    // than I care to admit. Oh, and why I'm at it, I put this line below the unique rotation\n    // block, so those went haywire too. :)\n    idJoinNSEW = checkerPat<0.? idJoinNSEW.zwxy : idJoinNSEW; \n    sNSEW = checkerPat<0.? sNSEW.zwxy : sNSEW; \n    sR = checkerPat>0.? sR.zwxy : sR; \n    \n\n    // I wanted to edge out the connector circles \n    if(idJoinNSEW.x<=rnd) sR.x = .1;\n    if(idJoinNSEW.y>rnd) sR.y = .1;\n    if(idJoinNSEW.z>rnd) sR.z = .1;\n    if(idJoinNSEW.w<=rnd) sR.w = .1;    \n\n    \n    // With straight edges, you can simply translate the jigsaw connecter bits along the X and Y borders.\n    // However, with curved edges, they need to follow the curves subtented from the main cirecles pivotal\n    // point - Don't worry, I groaned about it too. :D \n    \n    // Clamped to stop the circles from overlapping the edges.\n    vec4 rAng = clamp((idJoinNSEW - .5), - .35, .35)*3.14159/20.; \n    mat2 rotN = rot2(rAng.x);\n    mat2 rotS = rot2(rAng.y);\n    mat2 rotE = rot2(rAng.z);\n    mat2 rotW = rot2(rAng.w);\n\n\n    const float sf = .05; // Smoothing factor. The effect is subtle, but rounds the pieces a little.\n    \n    // The connector circles run along the out curved edges of the jigsaw pieces. They're rotionally \n    // offset by a unique amount (based on unique border ID).\n    float cN = length(rotN*(p + lROffs.y*e.yx) - (lR - ew - .0 - sNSEW.x*sR.x)*e.yx) - cw;\n    float cS = length(rotS*(p - lROffs.y*e.yx) + (lR - ew - .0 + sNSEW.y*sR.y)*e.yx) - cw;\n    float cE = length(rotE*(p -  (1. + lROffs.x)*e.xy) + (lR - ew - .0 + sNSEW.z*sR.z)*e.xy) - cw;\n    float cW = length(rotW*(p +  (1. + lROffs.x)*e.xy) - (lR - ew - .0 - sNSEW.w*sR.w)*e.xy) - cw;\n\n    \n    // As explained above, test the unique random border number against a threshold\n    // and either smoothly add or take away the connector circles. Make sure to do the exact\n    // opposite with the border directly opposite.\n    d = (idJoinNSEW.x>rnd)? smax(d, -(cN - ew), sf) : smin(d, cN, sf);\n    d = (idJoinNSEW.y<=rnd)? smax(d, -(cS - ew), sf) : smin(d, cS, sf);\n    d = (idJoinNSEW.z>rnd)? smax(d, -(cE - ew), sf) : smin(d, cE, sf);\n    d = (idJoinNSEW.w<=rnd)? smax(d, -(cW - ew), sf) : smin(d, cW, sf);\n    \n    // Return the 2D distance field value.\n    return d;\n}\n\n\n\n// \"jigDist\" contains four 2D jigsaw values, so we find the height for each \n// of the pieces and return the minimum 3D and 2D distance. By the way, I \n// left it in 2x2 loop form for informative purposes. I could easily have\n// unrolled it.\n//\nvec2 jigsaw(vec3 p3, vec4 jigDist){\n    \n    const float jSc = 4.; // I had to tweak the scale to get things right.\n    vec2 p = p3.xy*jSc;    \n    const vec2 sc = vec2(2, 2);\n    \n    // The 3D and 2D distance values.\n    float d = 1e5, d2 = 1e5;\n\n    // The height of each object.\n    float cellHeight = 0.;\n    \n    // Iterating through four repeat grids of objects - each spaced out to skip the\n    // object in between. This way the individual grid objects will easily fit in\n    // their cells.\n    // \n    // G1 G2 G1 G2 G1 G2\n    // G3 G4 G3 G4 G3 G4\n    // G1 G2 G1 G2 G1 G2\n    // G3 G4 G3 G4 G3 G4 // Etc.\n    //\n    for(int j = 0; j<=1; j++){\n        for(int i = 0; i<=1; i++){\n        \n\n            vec2 ip = floor((p - vec2(i, j))/sc)*sc;\n     \n            // The main calculation. Normally expensive, but it's been precalculated\n            // so is just being read out.\n            //float c = jigDist[j*2 + i]; \n            //float c = jigsawPiece(mod(p + vec2(i, j), sc) - sc/2., ip + vec2(i, j));\n            \n            // Swizzling to avoid the switch statement generated by \"dynamic vector indexing\".\n            // The following two lines are equivalent to the indexed line above.\n            // Thanks to Cyberjax for this suggestion. It helps the compiler out a bit.\n            float c = jigDist.x;\n            jigDist.xyzw = jigDist.yzwx;\n\n            // Record the minimum object's cell ID.\n            if(c<d2) {\n                cellID = ip + vec2(i, j);\n            }\n            \n            // Minimum 2D field value.\n            d2 = min(d2, c);\n            \n            // The height of the object.\n            cellHeight = getCellHeight(ip + vec2(i, j));\n\n            // Minimum 3D field value.\n            d = min(d, smax(c/jSc, abs(p3.z - cellHeight - .0) - .5, .0115));\n            \n\n\n        }\n    }\n    \n    // Return the 3D and 2D field values.\n    return vec2(d, d2);\n    \n}\n\n// The 2D jigsaw pattern value. Called via \"Buf A\" once per frame. See the function above\n// for an explanation. By the way, if you're only interested in a 2D jigsaw value, this\n// function will suffice.\nvec4 jigsaw4(vec3 p3){\n    \n    const float jSc = 4.;\n    vec2 p = p3.xy*jSc; // I had to tweak the scale to get things right.\n    const vec2 sc = vec2(2, 2);\n    \n    vec4 d4 = vec4(0);\n    \n    for(int j = 0; j<=1; j++){\n        for(int i = 0; i<=1; i++){\n\n            vec2 ip = floor((p - vec2(i, j))/sc)*sc;\n            vec2 q = mod(p + vec2(i, j), sc) - sc/2.;\n\n            float c = jigsawPiece(q, ip + vec2(i, j));\n            \n\n            // Swizzling to avoid the switch statement generated by \"dynamic vector indexing\".\n            // Thanks to Cyberjax for this suggestion. It helps the compiler out a bit.\n            //d4[j*2 + i] = c;\n            d4.x = c;\n            d4.xyzw = d4.yzwx;\n\n        }\n    }\n    \n    // Return the four 2D texture values. We'll use them later -- in the raymarching \n    // equation -- to determine the minimum 3D extruded block field value.\n    return d4;\n    \n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // The 2D jigsaw piece function is by far the most expensive, but it's \n    // only called once per frame, then passed to the raymarching function\n    // via the \"Buf A\" texture, which is a huge saving. Without this step,\n    // attempting to raymarch this in realtime would stop a lot of systems \n    // in their tracks.\n    //\n      init_grids();\n    vec2 p = fragCoord.xy/iResolution.xy;\n    \n    // The camera movement is provided via texture scrolling. We're doing it\n    // this way, because it'd be difficult to wrap this particular pattern. \n    // Not impossible, but compilicated. Therefore, the texture area has to \n    // span beyond the canvas borders to keep it withing the camera's field\n    // of view. Otherwise, the effect wouldn't work.\n    //\n    fragColor = jigsaw4(vec3(p*4. - moveXY(iTime), 0));\n    \n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"McjXWy","date":"0","viewed":0,"name":"Fork Jigsaw neozhaolia 875","username":"neozhaoliang","description":"Raymarching an extruded jigsaw pattern.","likes":0,"published":0,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n\tJigsaw\n\t------\n \n\tI saw a few jigsaw images on the net and thought to myself that I'd set aside a few minutes\n\tto code one up. I wasn't aware of it until a few hours later, but it turns out that jigsaw\n\tpatterns aren't as straight forward as you'd think... or I'm not particulary good at coding \n\tjigsaw patterns. Either way, an embarrassing amount of time later, and here it is. :D\n\n\tCreating a 2D square jigsaw pattern requires a bit of finesse. Putting a wavy pattern together\n    is more frustrating, but it can be done -- Constructing dissimilar interlocked asymmetrical \n    objects requires some thought. However, I started to realize that I might be in for more work \n    than I anticipated when I attempted to raymarch the pattern at a decent frame rate. :)\n\n\tI really try not to complicate things, but sometimes, it can't be avoided. Anyone familiar\n\twith rendering objects of varying heights across a repeat grid will know that rendering them \n    adjacent to one another isn't generally possible due to cell overlap artifacts. The only way \n\taround it is to render every second grid cell across two dimensions (ensuring no object overlap), \n\tthen render three other grid combinations to fill in the spaces -- The return value being the \n\tminimum distance of the four individual grid objects. Essentially, this means everything needs \n\tto be rendered four times over, so even a mildy complicated object -- like a jigsaw piece -- \n\twon't be feasible in real time... unless you can find a way to store calculations in a buffer.\n\n\tSo, that's what I've done here. Luckily, the jigsaw pieces are extruded, so the 2D distance \n\tfield calculations can be precalculated and stored in a 2D texture, then read back. Even better, \n\tall four calculations can be stored in each of the texture channels, which means just one call \n\tin the distance field function. After that, there's still some extruded object construction\n    and minimums to determine, but it involves significantly less calculation. In fact, my laptop\n\tcan run this in fullscreen quite easily.\n\t\n\tI decided to jitter the shadows, ever so slightly. It definitely improves banding issues on \n\tlong shadow casts, but adds a slight amount of unecessary jitter to shadows that are in close\n\tproximity to the object. Overall, however, I felt it improved things significantly.\n\n\tIn regard to the lighting and coloring, the scene is supposed to have a cardboard kind of \n\tconsistency... Not sure if it does entirely, but it turned out roughly the way I wanted.\n\n\n    Interlocking Asymmetrical Examples:\n\n\t// Awesome example: This involves repetition of a single object and is achieved in realtime \n\t// by reading the precalculated contour points from an array. Ultra also has a smooth\n\t// version of this.\n\tShaded Horses - Ultraviolet\n\thttps://www.shadertoy.com/view/lsXfDf\n\n\t// As above, it involves a single object, but is calculated on the fly.\n\tescherized tiling 2 (WIP) - FabriceNeyret2\n\thttps://www.shadertoy.com/view/lsdBR7\n\n*/\n\n\n#define FAR 10.\n\n// Gives a sheeny appearance. Intereting, but I prefer the flat look.\n//#define FAKE_ENVIROMENT_REFLECTIONS\n\n// Debug color overide. If you look in the \"Common\" tab, there's also a \"FLAT_PATTERN\" \n// define that will level the height out, effectively putting the pieces on a flat plane.\n//#define GREY\n\n// There's a slight perspective tilt on the camera, but this has a bit more -- to keep Dr2\n// happy and give it less of a scrolling texture look. :)\n//#define CAMERA_TWO\n\n\n\n/*\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001); //max(abs(n) - .2, 0.001); // etc.\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n*/\n\n \n// Global 2D surface value. It's poor programming practice putting it here. I'll \n// tidy this up later.\n//float surf2D;\n\n\n// Raymarching a textured XY-plane, with a bit of distortion thrown in.\nfloat map(vec3 p){\n    \n    // Sampling the 2D jigsaw pattern value from the texture, then passing it\n    // into a relatively cheap 3D extrusion function to give the final distance\n    // value.\n    vec4 jigDist = texture(iChannel0, p.xy/4. + .5);\n    vec2 jig = jigsaw(p - vec3(moveXY(iTime), 0), jigDist);\n    \n    //surf2D = jig.y; // Just the 2D value. Used for some cheap edging.\n \n    return jig.x*.866; // 3D extruded distance field value.\n    \n    \n}\n\n\n// Standard raymarching function.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0., d;\n    \n    for(int i = 0; i<80; i++){\n    \n        d = map(ro + rd*t);\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += d;\n    }\n\n    return min(t, FAR);\n    \n}\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .001;  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    dist += hash31(ro + rd)*.007;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist); //  map(ro + rd*dist + hash31(ro + rd)*dist*.03);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .01, .25); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist > end) break; \n    }\n\n    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also just for kicks. :)\n    return min(max(shade, 0.) + .05, 1.); \n}\n\n\n// An AO routine, tweaked to suit this particular example, and based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 5., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.1/5.; \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 normal(in vec3 p) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n/*\n// Standard 2x2 hash algorithm.\nvec2 hash22G(vec2 p, float repScale) {\n\n    p = mod(p, repScale);\n    // Faster, but probaly doesn't disperse things as nicely as other methods.\n    float n = sin(dot(p, vec2(27, 57)));\n    return fract(vec2(2097152, 262144)*n)*2. - 1.;\n\n}\n\n// Gradient noise: Ken Perlin came up with it, or a version of it. Either way, this is\n// based on IQ's implementation. It's a pretty simple process: Break space into squares, \n// attach random 2D vectors to each of the square's four vertices, then smoothly \n// interpolate the space between them.\nfloat gradN2D(in vec2 f, float repScale){\n  \n   f *= repScale;\n    \n    // Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy. \n   const vec2 e = vec2(0, 1);\n   \n    // Set up the cubic grid.\n    // Integer value - unique to each cube, and used as an ID to generate random vectors for the\n    // cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed\n    // to them.\n    vec2 p = floor(f);\n    f -= p; // Fractional position within the cube.\n    \n\n    // Smoothing - for smooth interpolation. Use the last line see the difference.\n    //vec2 w = f*f*f*(f*(f*6.-15.)+10.); // Quintic smoothing. Slower and more squarish, but derivatives are smooth too.\n    vec2 w = f*f*(3. - 2.*f); // Cubic smoothing. \n    //vec2 w = f*f*f; w = ( 7. + (w - 7. ) * f ) * w; // Super smooth, but less practical.\n    //vec2 w = .5 - .5*cos(f*3.14159); // Cosinusoidal smoothing.\n    //vec2 w = f; // No smoothing. Gives a blocky appearance.\n    \n    // Smoothly interpolating between the four verticies of the square. Due to the shared vertices between\n    // grid squares, the result is blending of random values throughout the 2D space. By the way, the \"dot\" \n    // operation makes most sense visually, but isn't the only metric possible.\n    float c = mix(mix(dot(hash22G(p + e.xx, repScale), f - e.xx), dot(hash22G(p + e.yx, repScale), f - e.yx), w.x),\n                  mix(dot(hash22G(p + e.xy, repScale), f - e.xy), dot(hash22G(p + e.yy, repScale), f - e.yy), w.x), w.y);\n    \n    // Taking the final result, and converting it to the zero to one range.\n    return c*.5 + .5; // Range: [0, 1].\n}\n\n// Gradient noise fBm.\nfloat fBm(in vec2 p, float repScale){\n    \n    return gradN2D(p, repScale)*.57 + gradN2D(p, repScale*2.)*.28 + gradN2D(p, repScale*4.)*.15;\n    \n}\n\n*/\n\n\n// With the spare cycles, I thought I'd splash out and use Dave's more reliable hash function. :)\n//\n// Dave's hash function. More reliable with large values, but will still eventually break down.\n//\n// Hash without Sine.\n// Creative Commons Attribution-ShareAlike 4.0 International Public License.\n// Created by David Hoskins.\n// vec3 to vec3.\nvec3 hash33G(vec3 p){\n\n\tp = fract(p * vec3(.1031, .1030, .0973));\n    p += dot(p, p.yxz + 19.19);\n    p = fract((p.xxy + p.yxx)*p.zyx)*2. - 1.;\n    return p;\n /*   \n    // Note the \"mod\" call. Slower, but ensures accuracy with large time values.\n    mat2  m = rot2(mod(iTime, 6.2831853));\t\n\tp.xy = m * p.xy;//rotate gradient vector\n    p.yz = m * p.yz;//rotate gradient vector\n    //p.zx = m * p.zx;//rotate gradient vector\n\treturn p;\n*/\n}\n\n\n\n/*\n// Cheap vec3 to vec3 hash. I wrote this one. It's much faster than others, but I don't trust\n// it over large values.\nvec3 hash33G(vec3 p){ \n   \n    //float n = sin(dot(p, vec3(7, 157, 113)));    \n    //p = fract(vec3(2097152, 262144, 32768)*n)*2. - 1.; \n    \n    //mat2  m = rot2(iTime);//in general use 3d rotation\n\t//p.xy = m * p.xy;//rotate gradient vector\n    ////p.yz = m * p.yz;//rotate gradient vector\n    ////p.zx = m * p.zx;//rotate gradient vector\n\t//return p;\n    \n    float n = sin(dot(p, vec3(27, 57, 111)));    \n    return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.; \n\n    \n    //float n = sin(dot(p, vec3(7, 157, 113)));    \n    //p = fract(vec3(2097152, 262144, 32768)*n); \n    //return sin(p*6.2831853 + iTime); \n}\n*/\n\n\n// Gradient noise, or Perlin noise. Break space into cubes, attach random 3D vectors to each of the eight \n// verticies, then smoothly interpolate between them. It's that simple. With the exception of some simple\n// changes and some commentary addition, this is basically IQ's implementation.\n// \nfloat gradN3D(in vec3 p){\n   \n    // Utilility bector.\n    const vec2 e = vec2(0, 1);\n    \n    // Set up the cubic grid.\n    // Integer value - unique to each cube, and used as an ID to generate random vectors for the\n    // cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed\n    // to them.\n    vec3 ip = floor(p); \n    \n    p -= ip; // Fractional position within the cube.\n\n    // Smoothing - for smooth interpolation. Comment it out to see the\n    //vec3 w = p*p*p*(p*(p*6. - 15.) + 10.); // Quintic smoothing. Slower, but derivaties are smooth too.\n    vec3 w = p*p*(3. - 2.*p); // Cubic smoothing. \n    //vec3 w = p*p*p; w = (7. + (w - 7.) * p) * w;\t// Super smooth, but less practical.\n    //vec3 w = .5 - .5*cos(p*3.14159); // Cosinusoidal smoothing.\n    //vec3 w = p; // No smoothing. Gives a blocky appearance. Can look cool under the right conditions.\n    \n    // Smoothly interpolating between the eight verticies of the cube. Due to the shared verticies between\n    // cubes, the result is blending of random values throughout the 3D space.\n    float c = mix(mix(mix(dot(hash33G(ip + e.xxx), p - e.xxx), dot(hash33G(ip + e.yxx), p - e.yxx), w.x),\n                      mix(dot(hash33G(ip + e.xyx), p - e.xyx), dot(hash33G(ip + e.yyx), p - e.yyx), w.x), w.y),\n                  mix(mix(dot(hash33G(ip + e.xxy), p - e.xxy), dot(hash33G(ip + e.yxy), p - e.yxy), w.x),\n                      mix(dot(hash33G(ip + e.xyy), p - e.xyy), dot(hash33G(ip + e.yyy), p - e.yyy), w.x), w.y), w.z);\n    \n    // Taking the final result, and putting it into the zero to one range.\n    return c*.5 + .5; // Range: [0, 1].\n\n}\n\n// Gradient noise fBm.\nfloat fBm3D(in vec3 p){\n    \n    return gradN3D(p)*.57 + gradN3D(p*2.)*.28 + gradN3D(p*4.)*.15;\n}\n\n#ifdef FAKE_ENVIROMENT_REFLECTIONS\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 eMap(vec3 rd, vec3 sn){\n    \n    vec3 sRd = rd; // Save rd, just for some mixing at the end.\n    \n    // Add a time component, scale, then pass into the noise function.\n    rd.xy -= iTime*.25;\n    rd *= 3.;\n    \n    //vec3 tx = tex3D(iChannel0, rd/3., sn);\n    //float c = dot(tx*tx, vec3(.299, .587, .114));\n    \n    float c = fBm3D(rd);\n    c = smoothstep(0.5, 1., c); // Darken and add contast for more of a spotlight look.\n    \n    //vec3 col = vec3(c, c*c, c*c*c*c).zyx; // Simple, warm coloring.\n    //vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)).zyx; // More color.\n    vec3 col = pow(vec3(1.5, 1, 1)*c, vec3(1, 2.5, 12)).zyx; // More color.\n    \n    // Mix in some more red to tone it down and return.\n    return mix(col, col.yzx, sRd*.25 + .25); \n    \n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Unit direction ray.\n    vec3 rd = normalize(vec3(fragCoord - iResolution.xy*.5, min(iResolution.y, 800.)*.5));\n    // Slight lens warping.\n    rd = normalize(vec3(rd.xy, sqrt(rd.z*rd.z - dot(rd.xy, rd.xy)*.03)));\n    \n    //vec3 ro = vec3(0. + iTime/4., 0. + iTime/8., -1.5);\n    // The camera movement is provided via texture scrolling. We're doing it\n    // this way, because it'd be very difficult to wrap this particular \n    // pattern. Not impossible, but compilicated. Therefore, texture area\n    // has to span beyond the canvas borders for the effect to work.\n    vec3 ro = vec3(0, 0, -1.);\n    // Light -- set up somewhere near the camera.\n    vec3 lp = ro + vec3(-.25, .75, 0);\n    \n    \n    // Tilting the camera ever so slightly.\n    #ifdef CAMERA_TWO\n    rd.yz *= rot2(-.2);\n    rd.xy *= rot2(.1);\n    #else\n    rd.yz *= rot2(-.03);\n    rd.xy *= rot2(.03);\n    #endif\n    \n    \n    // Standard raymarching segment. Because of the straight forward setup, very few \n    // iterations are needed.\n    float t = trace(ro, rd);\n    \n    // Saving the unique cell ID and the 2D surface value.\n    vec2 svCellID = cellID;\n    //float svSurf2D = surf2D;\n    \n    // Initiate the scene color.\n    vec3 col = vec3(0);\n    \n    // Trivial surface hit. I think all rays would hit this particular surface.\n    if(t<FAR){\n    \n        vec3 sp = ro + rd*t;\n        vec3 sn = normal(sp);\n        vec3 l = lp - sp;\n        float lDist = length(l);\n        l /= max(lDist, .0001);\n\n        //lDist /= 3.;\n        float atten = 1./(1. + lDist*.05);\n\n        // Ambient occlusion and shadows.\n        float ao = calcAO(sp, sn);\n        float sh = softShadow(sp + sn*.002, lp, 4., t); // Set to \"1.,\" if you can do without them.\n        sh = min(sh + ao*.2, 1.);\n\n\n        float dif = max(dot(l, sn), 0.); // Diffuse term.\n        dif *= dif; // Ramping up the diffuse.\n        float spe = pow(max( dot( reflect(-l, sn), -rd ), 0.0 ), 32.); // Specular term.\n        float fre = clamp(1.0 + dot(rd, sn), 0.0, 1.0); // Fresnel reflection term.\n\n        // Schlick appoximation. It tones down the specular term.\n        float Schlick = pow( 1. - max(dot(rd, normalize(rd + l)), 0.), 5.0);\n        float fre2 = mix(.1, 1., Schlick);  //F0 = .2 - Hard clay... or close enough.\n\n        // Texture value. Note that it's moving along XY to match the scrolling \"Buf A\" texture.\n        vec3 tSp = sp;\n        tSp.xy -= moveXY(iTime);\n        \n        // Shadertoy texture, but I went textureless for this one.\n        //vec3 objCol = mix(tex3D(iChannel1, sp/1., sn), tex3D(iChannel1, sp*2., sn), .34);\n        //vec3 objCol = tex3D(iChannel1, tSp/2., sn);//*texture(iChannel0, fract(sp.xy)).xyz;\n        //objCol = smoothstep(-.3, .3, objCol);\n\n        // COLORING THE JIGSAW PIECES.\n        //\n        vec3 objCol = vec3(1);\n        // Some random colors based on the unique jigsaw piece ID. Used for coloring.\n        vec3 rnd = vec3(hash(svCellID + 72.5), hash(svCellID + 37.1), hash(svCellID + 93.7));\n        //vec3 rnd = hash33G(svCellID.xyx + vec3(72, 37, 93))*.5 + .5;\n  \n        // Random base colors. Orange tones, I think.\n        vec3 cellCol = vec3(rnd.x*.2 + .8, rnd.z*.5 + .5, rnd.z*.3 + .3);\n        \n        // Mixing in some fire tones... I'll usually try this out if things aren't working. :)\n        float c = dot(cellCol, vec3(.299, .587, .114));\n        cellCol = cellCol*.5  + pow(min(vec3(1.5, 1, 1)*c, 1.), vec3(1, 3, 16));\n        \n        // Too much orange, so make some of them green for an autumn feel.\n        if(rnd.y<=.5) cellCol = min(cellCol*2., 1.).yxz;\n\n        // Color a portion of the pieces with the autumn palette, but leave some gray. It seemed\n        // like a fun thing to do at the time. :)\n        if(fract(rnd.x*289.97 + .73)>.15) objCol *= cellCol;\n        \n        objCol = mix(objCol, objCol.xzy, .15); // Tone the color down. \n        \n        #ifdef GREY\n        objCol = vec3(.9, 1.05, 1.2);\n        #endif\n        \n        // Blue\n        //objCol = objCol.zyx;\n        // Pink.\n        //objCol = objCol.xzy;\n        // Grey tones.\n        //objCol = vec3(1)*dot(cellCol, vec3(.299, .587, .114));\n \n\n        // Matches the pylon routine in the \"jigsaw\" construction routine called\n        // in the raymarching function.\n        //\n        float cellHeight = getCellHeight(svCellID); // Cell (jigsaw piece) height.\n        \n        // Put edges near the top of the block.\n        objCol *= smoothstep(0., .003, abs(sp.z - cellHeight + .5 - .006) - .00075)*.8 + .2; // Dark edges.\n     \n        // Put a 2D pattern on the top of the block above the dark edge.\n        if((abs(sp.z - cellHeight) - .5 + .006)>0.){\n             //objCol *= smoothstep(0., .0075, max(-svSurf2D, 0.) - .01)*.8 + .2; // Dark edges.\n             //objCol *= (1. - smoothstep(0., .01, -svH2 - .01))*.35 + 1.; // Light edges.\n            \n            // Wavy gradient contour pattern. You could put anything you want here, or nothing\n            // at all if you're super boring. :)\n            objCol *= clamp(-sin(fBm3D(vec3(tSp.xy, 0))*6.2831*96.)*5. + 2.9, 0., 1.)*.2 + .8;\n            \n        }\n        \n        // I originally put the pattern down the sides, but went with the 2D pattern above.\n        //objCol *= clamp(-sin(fBm3D(tSp)*6.2831*96.)*4. + 2.9, 0., 1.)*.2 + .8;\n        \n        // Some gradient fBm sprinkles to break things up and give a slight papery feel.\n        objCol *= fBm3D(tSp*80.)*.4 + .8;\n\n\n        // Very basic lighting. Diffuse, ambient and specular.\n        col = objCol*(dif + .25 + vec3(1, .7, .4)*spe*fre2);\n\n\t\t#ifdef FAKE_ENVIROMENT_REFLECTIONS\n        // Add the fake environmapping. Not as good as a reflective pass, but it gives that\n        // impresssion for just a fraction of the cost.\n        vec3 em = eMap(reflect(rd, sn), sn); // Fake environment mapping.\n        col += col*em*2.;\n        #endif\n\n        // Apply the light attenuation, ambient occlusion and shadows.\n        col *= atten*ao*sh;\n         \n    }\n    \n    // Subtle vignette.\n    vec2 uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625) + .1;\n    // Colored variation.\n    //col = mix(col.zyx/2., col, \n              //pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125));\n\n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int N = 5;\n\n// control hole size\nconst float hs = 3.33;\n\n// N real numbers for the shifts of the grids.\nfloat[N] shifts;\n\n// directions of the grids, will be initialized later\nvec2[N] grids;\n\nstruct Rhombus\n{\n    // r, s for the r-th and s-th grids.\n    int r;\n    int s;\n\n    // kr, ks for the lines in the two grids\n    float kr;\n    float ks;\n\n    // center and vertices of the rhombus\n    vec2 cen;\n    vec2[4] verts;\n};\n\n#define PI 3.141592653\n\n// initialize the grid directions, for N = 5 they are the five fifth roots of unity\nvoid init_grids()\n{\n    float FN = float(N), theta; \n    for(int k = 0; k < N; k++)\n    {\n        theta = (N % 2 == 0) ? PI / FN * float(k) : PI / FN * float(k) * 2.;\n        grids[k] = vec2(cos(theta), sin(theta));\n        // for N=5 (0.2, 0.2, 0.2, 0.2, 0.2) gives the classical Penrose tiling.\n        // set all shifts to 0.5 will give the star pattern which has ten thin rhombus\n        // around a vertex hence is non-Penrose.\n        // shifts[k] = 0.5;\n        shifts[k] = 1./FN;\n    }\n}\n\n// distance from a 2d point p to a 2d segment (a, b)\nfloat dseg(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 v = b - a;\n    p -= a;\n    float t = clamp(dot(p, v)/dot(v, v), 0., 1.);\n    return length(p - t * v);\n}\n\n// iq's hash function, for randomly flip the tunnels and open/closed faces\nfloat hash21(vec2 p)\n{\n    return fract(sin(dot(p, vec2(141.13, 289.97))) * 43758.5453);\n}\n\nfloat cross_prod(vec2 p, vec2 q)\n{\n    return p.x * q.y - p.y * q.x;\n}\n\n// signed distance function to a polygon using winding number\nfloat sdPoly4(in vec2 p, in vec2[4] verts)\n{\n    float d = dot(p - verts[0], p - verts[0]);\n    float s = 1.0;\n    for(int i = 0, j = 3; i < 4; j = i, i++)\n    {\n        vec2 e = verts[j] - verts[i];\n        vec2 w = p - verts[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1.);\n        d = min(d, dot(b, b));\n\n        bvec3 cond = bvec3(p.y >= verts[i].y, p.y < verts[j].y, cross_prod(e, w) > 0.);\n        if (all(cond) || all(not(cond)))\n            s *= -1.0;            \n    }\n    return s * sqrt(d);\n}\n\n// project a vector p to the k-th grid, note each grid line is shifted so we need\n// to add the corresponding shifts.\nfloat project_point_grid(vec2 p, int k)\n{\n    return dot(p, grids[k]) + shifts[k];\n}\n\n// find the vertices of the rhombus corresponding to the intersection point P,\n// where P is the intersection of the kr-th line and ks-th line in the r/s grids.\nvoid solve_rhombus_verts(int r, int s, float kr, float ks, out vec2[4] verts)\n{\n    vec2 P = grids[r] * (ks - shifts[s]) - grids[s] * (kr - shifts[r]);\n    P = vec2(-P.y, P.x) / grids[s - r].y;\n    vec2 sum = kr * grids[r] + ks * grids[s];\n    for(int k = 0; k < N; k++)\n    {\n        if ((k != r) && (k != s))\n            sum += grids[k] * ceil(project_point_grid(P, k));\n    }\n    verts[0] = sum;\n    verts[1] = sum + grids[r];\n    verts[3] = sum + grids[s];\n    verts[2] = verts[1] + grids[s];\n}\n\n// this is the \"continous\" version of de Bruijn's transformation that maps a pixel\n// to its position in the tiling.\nvec2 debruijn_transform(vec2 p)\n{\n    vec2 sum = vec2(0.0);\n    for(int k = 0; k < N; k++)\n    {\n        sum += grids[k] * project_point_grid(p, k);\n    }\n    return sum;\n}\n\n// a bit lengthy computation to find after the transformation p --> q,\n// which rhombus q lies in. we simply iterate over all possible combinations:\n// for each pair 0 <= r < s < 5, we find (kr, ks) so that p lies in the (kr, kr+1)\n// strip in the r-th grid and (ks, ks+1) strip in the s-th grid, and check which of\n// the four rhombus (r, s, kr, ks), (r, s, kr, ks+1), (r, s, kr+1, ks), (r, s, kr+1, ks+1)\n// contains q.\n// Sadly due to float rounding errors, we have to search from (r, s, kr-1, ks-1).\nRhombus get_mapped_rhombus(vec2 p, out vec2 q)\n{\n    q = debruijn_transform(p);\n    Rhombus rb;\n    float kr, ks;\n    vec2[4] verts;\n    float[N] pindex;\n    for (int i = 0; i < N; i++)\n    {\n        pindex[i] = floor(project_point_grid(p, i));\n    }\n    for(int r = 0; r < N-1; r++)\n    {\n        for(int s = r+1; s < N; s++)\n        {\n            for(float dr = -1.; dr < 2.; dr += 1.0)\n            {\n                for(float ds = -1.; ds < dr+2.; ds += 1.0)\n                {\n                    kr = pindex[r] + dr;\n                    ks = pindex[s] + ds;\n                    solve_rhombus_verts(r, s, kr, ks, verts);\n                    if (sdPoly4(q, verts) < 0.)\n                    {\n                        rb.r = r, rb.s = s, rb.kr = kr, rb.ks = ks;\n                        rb.verts = verts;\n                        rb.cen = (verts[0] + verts[1] + verts[2] + verts[3]) / 4.0;\n                        return rb;\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Translational movement.\nvec2 moveXY(float t){\n    return vec2(1./4., -1./12.)*t;\n}\n\n/*\n// IQ's smooth minium function. \nfloat smin(float a, float b , float s){\n    \n    float h = clamp(.5 + .5*(b-a)/s, 0., 1.);\n    return mix(b, a, h) - h*(1. - h)*s;\n}\n\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n*/\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n// vec2 to float hash.\nfloat hash(vec2 p){\n    return fract(sin(dot(p, vec2(41.71, 112.97)))*43758.5453);\n}\n\n// vec3 to float hash.\nfloat hash31(vec3 p){\n   \n    float n = dot(p, vec3(13.163, 157.247, 7.951)); \n    return fract(sin(n)*43758.5453); \n}\n\n// Unique jigsaw piece cell ID.\nvec2 cellID;\n\n/*\n// Random stepped height field.\nfloat getCellHeight(vec2 id){\n    \n    float cellHeight = hash(id);\n    cellHeight = floor(cellHeight*7.999)/7.;\n    return cellHeight*.075;\n    \n}\n*/\n\n// Sinusoidal stepped height field.\nfloat getCellHeight(vec2 p){\n    \n    #ifdef FLAT_PATTERN\n    // Handy for debug purposes.\n    return .0375;\n    #else\n    // Any kind of cheap flowing height field will do. \n    float cellHeight = (dot(sin(p*2.2 - cos(p.yx*1.4)), vec2(.25)) + .5);\n    cellHeight = floor(cellHeight*7.999)/7.;\n    return cellHeight*.075;\n    #endif\n}\n\n\n// It can be annoying trying to follow someone's esoteric code logic, but trust me, the\n// idea behind it is pretty simple... even if it took me way too long to realize how simple\n// it was. :) Anyway, construct a four sided shape with curved sides (using circles), identify \n// all four neighbors, then add a little circle to the edge of one, and take away a circle \n// from its neighbor.\n//\n// By the way, the nice straight square version is \"much\" simpler, but doesn't quite have that \n// jigsaw feel. I wish it did, because I could have saved a lot of small headaches. :)\n//\nfloat jigsawPiece(vec2 p, vec2 ip){\n    \n    // Random ID threshold.\n    const float rnd = .5;\n    \n    // The four border IDs: As an example, take the northern, or upper, border.\n    // The currect cell ID is \"ip.\" The upper cell wil have ID \"ip + vec2(0, 1).\"\n    // The unique \"border\" ID will be the average of the two, which will be\n    // \"(ip + ip + vec2(0, 1))/2.\" which is \"ip + vec2(0, .5).\" This means the \n    // current cell's upper border ID will always match the lower border ID of the\n    // cell above.\n    //\n    // The idea is to use the unique cell border ID to generate the random number.\n    // If it is above a certain threshold add, or take, a circle, then -- and this\n    // is the bit that confused me -- do the opposite with the opposite border. In\n    // pseudo code:\n    //\n    // if (hash(IDNorth)>thresshold) addCircle();\n    // if (hash(IDSouth)<=thresshold) takeCircle();\n    //\n    // It still confuses me if I think about it too much, but it works. In fact, you\n    // could use this process to fit any random shapes together.\n    \n    \n    // Four random border IDs.\n    vec4 idJoinNSEW = vec4(hash(ip + vec2(0, .5)), hash(ip + vec2(0, -.5)), \n                           hash(ip + vec2(.5, 0)), hash(ip + vec2(-.5, 0)));\n    \n    \n    const float ew = .015; // Jigsaw edge width.\n    const float cw = .14; // Jigsaw connector circle width.\n    // Jigsaw circle offset perpendicularly from the border. If you change this,\n    // find the \"sR\" varialbe below, and make adjustments there too.\n    vec4 sR = vec4(.07); \n\n   \n    // Unfortunately, the \"sign\" function returns -1, 1 and 0, but we don't want \n    // zero. :) Hence, the line below. Although, there's probably a more efficient \n    // WebGL specific way to do it.\n    //\n    //vec4 sNSEW = sign(vec4(idJoinN, idJoinS, idJoinE, idJoinW) - rnd);\n    vec4 sNSEW = vec4(idJoinNSEW.x>rnd? 1.: -1., idJoinNSEW.y>rnd? 1.: -1., \n                      idJoinNSEW.z>rnd? 1.: -1., idJoinNSEW.w>rnd? 1.: -1.);\n\n    \n    // Used to check alternating tiles in the checkerboard pattern. Tiles are either\n    // vertically convex and horizontally concave, or vice versa. By the way, I proabably\n    // could have gone with quarter rotation (p = p.yx) logic, but I was allowing for\n    // assymetrical varations at the time.\n    //\n    float checkerPat = (mod(ip.x + ip.y, 2.)<.5)? 1. : -1.;\n    // Used to reorient tiles, depending on the checkerboard setup.\n    vec2 e = checkerPat>0.? vec2(1, 0) : vec2(0, 1); \n    \n    // Main tile slab construction.\n    // The large circle is used to add curvature to the square sides to give even \n    // more of a jigsaw pattern feel.\n    vec2 lROffs = vec2(2); // Large circle offset away from the center.\n\n    // Large circle radius. Equal to the distance from the translated central circle\n    // point to the corner of the border in question. This is a northern border\n    // calculation.\n    //float lRConvex = length(vec2(.5, .5) -  vec2(0, -r2.y));\n    //float lRConcave = length(vec2(.5, .5) -  vec2(0, 1. + r2.y));\n    float lR = length(vec2(.5, .5) -  vec2(0, -lROffs.y));\n    \n    // Move the point perpendicularly away from the border, then construct a large\n    // circle equal in radius from the new central point to the corner of the square\n    // side. In this case, due to symmetry, all circles will have the same radius.\n    //\n    // I left the following lines so you could see the logic behind the construction.\n    // Obviously, I went with shorter \"abs\" version.\n    //float c2N = length(p + lROffs.y*e.yx) - lR + ew/2.;\n    //float c2S = length(p - lROffs.y*e.yx) - lR + ew/2.;\n    //float c2E = length(p + (1. + lROffs.x)*e.xy) - lR - ew/2.;\n    //float c2W = length(p - (1. + lROffs.x)*e.xy) - lR - ew/2.;\n    //float d = max(c2N, c2S);\n    //d = smax(d, -min(c2E, c2W), .05);\n\n    // Equivalent to the lines above, just less work for the GPU.\n    float c2NS = length(abs(p) + lROffs.y*e.yx) - lR + ew/2.;\n    float c2EW = length(abs(p) - (1. + lROffs.x)*e.xy) - lR - ew/2.;\n    float d = smax(c2NS, -c2EW, .05);\n    \n    \n    \n    // Damn logic. If you switch the points based on checker pattern convexity, you have\n    // to rotate the unique border IDs with them. So obvious, but this mistake cost me more time \n    // than I care to admit. Oh, and why I'm at it, I put this line below the unique rotation\n    // block, so those went haywire too. :)\n    idJoinNSEW = checkerPat<0.? idJoinNSEW.zwxy : idJoinNSEW; \n    sNSEW = checkerPat<0.? sNSEW.zwxy : sNSEW; \n    sR = checkerPat>0.? sR.zwxy : sR; \n    \n\n    // I wanted to edge out the connector circles \n    if(idJoinNSEW.x<=rnd) sR.x = .1;\n    if(idJoinNSEW.y>rnd) sR.y = .1;\n    if(idJoinNSEW.z>rnd) sR.z = .1;\n    if(idJoinNSEW.w<=rnd) sR.w = .1;    \n\n    \n    // With straight edges, you can simply translate the jigsaw connecter bits along the X and Y borders.\n    // However, with curved edges, they need to follow the curves subtented from the main cirecles pivotal\n    // point - Don't worry, I groaned about it too. :D \n    \n    // Clamped to stop the circles from overlapping the edges.\n    vec4 rAng = clamp((idJoinNSEW - .5), - .35, .35)*3.14159/20.; \n    mat2 rotN = rot2(rAng.x);\n    mat2 rotS = rot2(rAng.y);\n    mat2 rotE = rot2(rAng.z);\n    mat2 rotW = rot2(rAng.w);\n\n\n    const float sf = .05; // Smoothing factor. The effect is subtle, but rounds the pieces a little.\n    \n    // The connector circles run along the out curved edges of the jigsaw pieces. They're rotionally \n    // offset by a unique amount (based on unique border ID).\n    float cN = length(rotN*(p + lROffs.y*e.yx) - (lR - ew - .0 - sNSEW.x*sR.x)*e.yx) - cw;\n    float cS = length(rotS*(p - lROffs.y*e.yx) + (lR - ew - .0 + sNSEW.y*sR.y)*e.yx) - cw;\n    float cE = length(rotE*(p -  (1. + lROffs.x)*e.xy) + (lR - ew - .0 + sNSEW.z*sR.z)*e.xy) - cw;\n    float cW = length(rotW*(p +  (1. + lROffs.x)*e.xy) - (lR - ew - .0 - sNSEW.w*sR.w)*e.xy) - cw;\n\n    \n    // As explained above, test the unique random border number against a threshold\n    // and either smoothly add or take away the connector circles. Make sure to do the exact\n    // opposite with the border directly opposite.\n    d = (idJoinNSEW.x>rnd)? smax(d, -(cN - ew), sf) : smin(d, cN, sf);\n    d = (idJoinNSEW.y<=rnd)? smax(d, -(cS - ew), sf) : smin(d, cS, sf);\n    d = (idJoinNSEW.z>rnd)? smax(d, -(cE - ew), sf) : smin(d, cE, sf);\n    d = (idJoinNSEW.w<=rnd)? smax(d, -(cW - ew), sf) : smin(d, cW, sf);\n    \n\n    // Return the 2D distance field value.\n    return d;\n    \n}\n\n\n\n// \"jigDist\" contains four 2D jigsaw values, so we find the height for each \n// of the pieces and return the minimum 3D and 2D distance. By the way, I \n// left it in 2x2 loop form for informative purposes. I could easily have\n// unrolled it.\n//\nvec2 jigsaw(vec3 p3, vec4 jigDist){\n    \n    const float jSc = 4.; // I had to tweak the scale to get things right.\n    vec2 p = p3.xy*jSc;    \n    const vec2 sc = vec2(2, 2);\n    \n    // The 3D and 2D distance values.\n    float d = 1e5, d2 = 1e5;\n\n    // The height of each object.\n    float cellHeight = 0.;\n    \n    // Iterating through four repeat grids of objects - each spaced out to skip the\n    // object in between. This way the individual grid objects will easily fit in\n    // their cells.\n    // \n    // G1 G2 G1 G2 G1 G2\n    // G3 G4 G3 G4 G3 G4\n    // G1 G2 G1 G2 G1 G2\n    // G3 G4 G3 G4 G3 G4 // Etc.\n    //\n    for(int j = 0; j<=1; j++){\n        for(int i = 0; i<=1; i++){\n        \n\n            vec2 ip = floor((p - vec2(i, j))/sc)*sc;\n     \n            // The main calculation. Normally expensive, but it's been precalculated\n            // so is just being read out.\n            //float c = jigDist[j*2 + i]; \n            //float c = jigsawPiece(mod(p + vec2(i, j), sc) - sc/2., ip + vec2(i, j));\n            \n            // Swizzling to avoid the switch statement generated by \"dynamic vector indexing\".\n            // The following two lines are equivalent to the indexed line above.\n            // Thanks to Cyberjax for this suggestion. It helps the compiler out a bit.\n            float c = jigDist.x;\n            jigDist.xyzw = jigDist.yzwx;\n\n            // Record the minimum object's cell ID.\n            if(c<d2) {\n                cellID = ip + vec2(i, j);\n            }\n            \n            // Minimum 2D field value.\n            d2 = min(d2, c);\n            \n            // The height of the object.\n            cellHeight = getCellHeight(ip + vec2(i, j));\n\n            // Minimum 3D field value.\n            d = min(d, smax(c/jSc, abs(p3.z - cellHeight - .0) - .5, .0115));\n            \n\n\n        }\n    }\n    \n    // Return the 3D and 2D field values.\n    return vec2(d, d2);\n    \n}\n\n// The 2D jigsaw pattern value. Called via \"Buf A\" once per frame. See the function above\n// for an explanation. By the way, if you're only interested in a 2D jigsaw value, this\n// function will suffice.\nvec4 jigsaw4(vec3 p3, Rhombus rb){\n    \n    const float jSc = 4.;\n    vec2 p = p3.xy*jSc; // I had to tweak the scale to get things right.\n    const vec2 sc = vec2(2, 2);\n    \n    vec4 d4 = vec4(0);\n    \n    for(int j = 0; j<=1; j++){\n        for(int i = 0; i<=1; i++){\n\n            vec2 ip = floor((p - vec2(i, j))/sc)*sc;\n            vec2 q = mod(p + vec2(i, j), sc) - sc/2.;\n\n            float c = jigsawPiece(q, ip + vec2(i, j));\n            \n\n            // Swizzling to avoid the switch statement generated by \"dynamic vector indexing\".\n            // Thanks to Cyberjax for this suggestion. It helps the compiler out a bit.\n            //d4[j*2 + i] = c;\n            d4.x = c;\n            d4.xyzw = d4.yzwx;\n\n        }\n    }\n    \n    // Return the four 2D texture values. We'll use them later -- in the raymarching \n    // equation -- to determine the minimum 3D extruded block field value.\n    return d4;\n    \n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    init_grids();\n\n    \n    // The 2D jigsaw piece function is by far the most expensive, but it's \n    // only called once per frame, then passed to the raymarching function\n    // via the \"Buf A\" texture, which is a huge saving. Without this step,\n    // attempting to raymarch this in realtime would stop a lot of systems \n    // in their tracks.\n    //\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 p, q;\n        \n    Rhombus rb = get_mapped_rhombus(uv - moveXY(iTime), p);\n    \n    // The camera movement is provided via texture scrolling. We're doing it\n    // this way, because it'd be difficult to wrap this particular pattern. \n    // Not impossible, but compilicated. Therefore, the texture area has to \n    // span beyond the canvas borders to keep it withing the camera's field\n    // of view. Otherwise, the effect wouldn't work.\n    //\n    fragColor = jigsaw4(vec3(p, 0), rb);\n    \n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"sddyRl","date":"0","viewed":0,"name":"Fork Lots of ps neozhaolia 847","username":"neozhaoliang","description":"Boyd-Maxwell ball packings 3d version","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2 // Make it 3 if you have a fast machine\n#endif\n\nfloat map(vec3 p, inout int index) {\n    float scale = 3.;\n    orb = vec4(1000.0); \n    for (int i = 0; i < MAX_ITER; i++) {\n        bool cond = true;\n        for (int k = 0; k < 5; k++) {\n            cond = try_reflect(p, coclusters[k], scale) && cond;\n            orb = min( orb, vec4(abs(p), dot(p, p)));\n        }\n\n        if (cond)\n            break;\n    }\n    index = 0;\n\n    float d = p.z;\n    for (int j = 1; j < 5; j++) {\n        if (clusters[j].isRealBall) {\n            float d1 = sdistanceToBall(p, clusters[j]);\n            if (d1 < d) { d = d1; index = j; }\n        }\n    }\n    return d / scale;\n}\n\n\n\nfloat trace( in vec3 ro, in vec3 rd, inout int index )\n{\n\tfloat maxd = 30.0;\n    float t = 0.001;\n    for( int i=0; i<512; i++ )\n    {\n\t    float precis = 0.001;\n        \n\t    float h = map( ro+rd*t, index );\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    float precis = 0.0001 ;\n    int index;\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy, index) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, index ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, index ) + \n                      e.xxx*map( pos + e.xxx, index ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float anim )\n{\n    // trace\t\n    vec3 col = vec3(0.0);\n    int index = 0;\n    float t = trace( ro, rd, index);\n    if( t>0.0 )\n    {\n        vec4 tra = orb;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t );\n\n        // lighting\n        vec3  light1 = vec3(  0.577, 0.577, 0.577 );\n        vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n        float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n        float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n        float amb = (0.7+0.3*nor.z);\n        float ao = pow( clamp(tra.w*2.0,0.0,1.0), 1.2 );\n\n        vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*ao;\n        brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n        brdf += 1.0*vec3(0.40,0.40,0.40)*bac*ao;\n\n        // material\t\t\n        vec3 rgb = vec3(1.0);\n        rgb = mix( rgb, vec3(1.0,0.80,0.2), clamp(6.0*tra.z,0.0,1.0) );\n        rgb = mix( rgb, vec3(1.0,0.55,0.0), pow(clamp(1.0-2.0*tra.z,0.0,1.0),8.0) );\n\n        // color\n        col = rgb*brdf*exp(-0.2*t);\n    }\n\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init(333, vec3(2, 2, 3), vec3(3, 4, 2), inf, bvec4(1, 0, 0, 0));\n    float time = iTime*0.05 + 0.01*iMouse.x;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 1, jj = 1;\n    #endif\n    {\n        vec2 q = fragCoord.xy+vec2(float(ii),float(jj))/float(AA);\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n\n        // camera\n        vec3 ro = vec3( 2.8*cos(0.1+.33*time), 0.4 + 0.30*cos(0.37*time), 1.2+1.2*cos(0.5+0.35*time) );\n        vec3 ta = vec3( 1.9*cos(1.2+.41*time), 0.4 + 0.10*cos(0.27*time), 1.5 + 1.*cos(2.0+0.38*time) );\n        float roll = 0.2*cos(0.1*time);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(0, 0, 1);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        tot += render( ro, rd, anim );\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_ITER         40\n#define PI               3.141592653\n#define L2(x)            dot(x, x)\n#define ZOOM             3.\n#define inf              -1.05\n\nvec4 orb; \n\n// uncomment this to show the vertice sections\n//#define DrawVerticalSections\n\nfloat dihedral(float x) {\n    return x == inf ? 1. : cos(PI / x);\n}\n\nvec3 dihedral(vec3 v) {\n    return vec3(dihedral(v.x), dihedral(v.y), dihedral(v.z));\n}\n\n\n// For spheres n is the center, r is the radius\n// For planes n is the normal vector, r is the distance between the plane and the origin\n// if invert is true then the inside/outside of the sphere is interchanged (not used in this program)\n// if hasRealBall is true then this virtual ball has a real ball correspondes to it\nstruct Ball {\n    bool isplane;\n    vec3 n;\n    float r;\n    bool invert;\n    bool isRealBall;\n};\n\n// coclusters are mirror balls, they corresponde to root vectors (space-like)\nBall[5] coclusters;\n// clusters are real balls, they corresponde to space-like weight vectors\nBall[5] clusters;\n\n\n// create a ball. by default it's the z=0 plane with normal points to the negative half\nBall defaultBall() {\n    return Ball(false, vec3(0, 0, -1), 0., false, false);\n}\n\n// Distance from a point to a ball\nfloat sdistanceToBall(vec3 p, Ball B) {\n    if (B.isplane) {\n        float k = dot(vec4(p, 1), vec4(B.n, B.r));\n        return k;\n    }\n    else\n        return length(p - B.n) - B.r;\n}\n\nBall from_plane(vec3 n, float d) {\n    return Ball(true, n, d, false, false);\n}\n\nBall from_sphere(vec3 cen, float r) {\n    return Ball(false, cen, r, false, false);\n}\n\nvoid invertBall(inout Ball B) {\n    B.invert = !B.invert;\n}\n\n// try to reflect a point p to the positive half space bounded by a ball\n// if we are already in the positive half space, do nothing and return true,\n// else reflect about the ball and return false\n// if B is a sphere we try to reflect p into the interior of B\nbool try_reflect(inout vec3 p, Ball B, inout float scale) {\n    if (B.isplane) {\n        float k = dot(vec4(p, 1), vec4(B.n, B.r));\n        if (k >= 0.)\n            return true;\n        p -= 2. * k  * B.n;\n        return false;\n    }\n    else {\n        vec3 cen = B.n;\n        float r = B.r;\n        vec3 q = p - cen;\n        float d2 = dot(q, q);\n        float k = (r * r) / d2;\n        if ( (k < 1.0 && B.invert) || (k > 1. && !B.invert) )\n            return true;\n        p = k * q + cen;\n        scale *= k;\n        return false;\n    }\n}\n\n// return distance to the scene, and get the index of the real ball hitted\n\n\n// solve M*v = b, where v = (x, y, r) is the xy-coordinate of the center of the ball,\n// r is the radius of the ball.\nBall solveBall(mat3 M, vec3 b) {\n    vec3 p = b * inverse(M);\n    return from_sphere(vec3(p.xy, 0.), p.z);\n}\n\n// Solve a ball with its center has xy-coordinates P, and is orthogonal to other two Balls B0, B1.\n// Here B0 may be either a sphere or a plane, B1 is always a sphere. \nBall solveBall(vec2 P, Ball B0, Ball B1) {\n    if (B0.isplane) {\n        float z = B0.r;\n        vec3 cen = vec3(P, z);\n        float R = sqrt(L2(cen - B1.n) - B1.r*B1.r);\n        return from_sphere(cen, R);\n    }\n    else {\n        float r1 = B1.r;\n        float r0 = B0.r;\n        float z0 = B0.n.z;\n        float k0 = L2(P - B0.n.xy);\n        float k1 = L2(P - B1.n.xy);\n        float z = (r1*r1 - r0*r0 + z0*z0 + k0 - k1) / (2.*z0);\n        float R = sqrt(k1 + z*z - r1*r1);\n        return from_sphere(vec3(P, z), R);\n    }\n    \n}\n\n// triangleType: must be one of 236, 244 or 333\n// dihedralAngles0: labels of the edges between v0 and (v2, v3, v4)\n// dihedralAngles1: labels of the edges between v1 and (v2, v3, v4)\n// dihedralAngles0_1: label of the edge between (v0, v1)\n// isRealBall: specify which of (v1, v2, v3, v4) has real balls\nvoid init(int triangleType,\n          vec3 dihedralAngles0,\n          vec3 dihedralAngles1,\n          float dihedralAngle0_1,\n          bvec4 isRealBall) {\n    const float s2 = sqrt(2.);\n    const float s3 = sqrt(3.);\n    mat3 M0, M1;\n    vec3 b;\n    Ball B0, B1, B2, B3, B4;\n    vec3 t0 = dihedral(dihedralAngles0);\n    vec3 t1 = dihedral(dihedralAngles1);\n    float t01 = dihedral(dihedralAngle0_1);\n    // A, B, C are the vertices of the triangle formed by mirror plane v2, v3, v4 and z=0 plane\n    vec2 A, B, C;\n\n    // the 236 case\n    if (triangleType == 236) {\n        A = vec2(0, 0), B = vec2(0, s3), C = vec2(1, 0);\n        B2 = from_plane(vec3(1, 0, 0), 0.);\n        B3 = from_plane(vec3(-s3/2., -0.5, 0), s3/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(1, 0, -t1.x), vec3(s3/2., 0.5, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(1, 0, -t0.x), vec3(s3/2., 0.5, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(0, s3/2., 0);\n    }\n    \n    // the 244 case\n    else if (triangleType == 244) {\n        A = vec2(0, 0), B = vec2(0, 1), C = vec2(1, 0);\n        B2 = from_plane(vec3(1, 0, 0), 0.);\n        B3 = from_plane(vec3(-s2/2., -s2/2., 0), s2/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(1, 0, -t1.x), vec3(1./s2, 1./s2, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(1, 0, -t0.x), vec3(1./s2, 1./s2, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(0, s2/2., 0);\n    }\n    \n    // the 333 case\n    else {\n        A = vec2(-1, 0), B = vec2(0, s3), C = vec2(1, 0);\n        B2 = from_plane(vec3(s3/2., -.5, 0), s3/2.);\n        B3 = from_plane(vec3(-s3/2., -.5, 0), s3/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(-s3/2., 0.5, t1.x), vec3(s3/2., .5, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(-s3/2., 0.5, t0.x), vec3(s3/2., .5, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(s3, s3, 0)/2.;\n    }\n    \n    // now we solve the virtual ball B1, this can't be a plane\n    B1 = solveBall(M1, b);\n    invertBall(B1);\n    \n    // now we solve the virtual ball B0, this can be either a plane or a sphere\n    // this depends on if all entries in dihedralAngles0 are all 2\n    if (dot(dihedralAngles0, vec3(1)) == 6.) {\n        B0 = from_plane(vec3(0, 0, -1), B1.r*t01);\n    }\n    else {\n        B0 = solveBall(M0, b);\n        float r1 = B1.r, r0 = B0.r;\n        B0.n.z = sqrt(r0*r0 + r1*r1 + 2.*r0*r1*t01 - L2(B1.n.xy - B0.n.xy));\n        invertBall(B0);\n    }\n    coclusters = Ball[5] (B0, B1, B2, B3, B4);\n\n    //now we process the real balls\n    for (int k = 0; k < 5; k++)\n        clusters[k] = defaultBall();\n        \n    if (isRealBall.x) {\n        clusters[1] = from_plane(vec3(0, 0, -1.), B0.n.z);\n        clusters[1].isRealBall = true;\n    }\n    if (isRealBall.y) {\n        clusters[2] = solveBall(C, B0, B1);\n        clusters[2].isRealBall = true;\n    }\n    if (isRealBall.z) {\n        clusters[3] = solveBall(A, B0, B1);\n        clusters[3].isRealBall = true;\n    }\n   \n    if (isRealBall.w) {\n        clusters[4] = solveBall(B, B0, B1);\n        clusters[4].isRealBall = true;\n    }\n}\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"7td3zH","date":"0","viewed":0,"name":"Fork Mandelbox  neozhaolia 441","username":"neozhaoliang","description":"License CC0: Mandelbox variant no 1E6\nAnother variant of Mandelbox by Evilryu: https://www.shadertoy.com/view/XdlSD4\n","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License CC0: Mandelbox variant no 1E6\n//  Another variant of Mandelbox by Evilryu: https://www.shadertoy.com/view/XdlSD4\n\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  8.0\n#define MAX_RAY_MARCHES 100\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\nconst float fixed_radius2 = 1.9;\nconst float min_radius2   = 0.5;\nconst vec3  folding_limit = vec3(1.0);\nconst float scale         = -2.8;\nconst int   max_iter      = 120;\nconst vec3  bone          = vec3(0.89, 0.855, 0.788);\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvec3 pmin(vec3 a, vec3 b, vec3 k) {\n  vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvoid sphere_fold(inout vec3 z, inout float dz) {\n    float r2 = dot(z, z);\n    if(r2 < min_radius2) {\n        float temp = (fixed_radius2 / min_radius2);\n        z *= temp;\n        dz *= temp;\n    } else if(r2 < fixed_radius2) {\n        float temp = (fixed_radius2 / r2);\n        z *= temp;\n        dz *= temp;\n    }\n}\n\nvoid box_fold(float k, inout vec3 z, inout float dz) {\n  vec3 zz = sign(z)*pmin(abs(z), folding_limit, vec3(k));\n  z = zz * 2.0 - z;\n}\n\nfloat sphere(vec3 p, float t) {\n  return length(p)-t;\n}\n\nfloat boxf( vec3 p, vec3 b, float e)\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat mb(vec3 z) {\n    vec3 offset = z;\n    float dr = 1.0;\n    float fd = 0.0;\n    const float k = 0.05;\n    for(int n = 0; n < 5; ++n) {\n        box_fold(k/dr, z, dr);\n        sphere_fold(z, dr);\n        z = scale * z + offset;\n        dr = dr * abs(scale) + 1.0;        \n        float r1 = sphere(z, 5.0);\n        float r2 = boxf(z, vec3(5.0), 0.5);\n        float r = n < 4 ? r2 : r1;\n        float dd = r / abs(dr);\n        if (n < 3 || dd < fd) {\n          fd = dd;\n        }\n    }\n    return fd;\n}\n\nfloat df(vec3 p) { \n    const float z = 0.3;\n    p.y -= 1.0;\n    float d1 = mb(p/z)*z;\n    return d1; \n} \n\nfloat rayMarch(in vec3 ro, in vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float distance = df(ro + rd*t);\n    if (distance < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += distance;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(in vec3 pos) {\n  vec3  eps = vec3(.0005,0.0,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(in vec3 pos, in vec3 ld, in float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<24; i++) {\n    float distance = df(pos + ld*t);\n    res = min(res, k*distance/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, distance);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 postProcess(in vec3 col, in vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n  vec3 lightPos = 2.0*vec3(1.5, 3.0, 1.0);\n\n  vec3 skyCol = vec3(0.0);\n\n  int iter = 0;\n  float t = rayMarch(ro, rd, iter);\n\n  float ifade = 1.0-tanh_approx(3.0*float(iter)/float(MAX_RAY_MARCHES));\n\n  vec3 pos = ro + t*rd;    \n  vec3 nor = vec3(0.0, 1.0, 0.0);\n  \n  vec3 color = vec3(0.0);\n  \n  float h = fract(TIME/30.0);\n  \n  if (t < MAX_RAY_LENGTH && pos.y > 0.0) {\n    // Ray intersected object\n    nor       = normal(pos);\n    vec3 hsv  = (vec3(fract(h - 0.6 + 0.4+1.75*t), 1.0-ifade, 1.0));\n    color     = hsv2rgb(hsv);\n  } else if (pos.y > 0.0) {\n    // Ray intersected sky\n    return skyCol*ifade;\n  } else {\n    // Ray intersected plane\n    t   = -ro.y/rd.y;\n    pos = ro + t*rd;\n    nor = vec3(0.0, 1.0, 0.0);\n    vec2 pp = pos.xz*1.5;\n    float m = 0.5+0.25*(sin(3.0*pp.x+TIME*2.1)+sin(3.3*pp.y+TIME*2.0));\n    m *= m;\n    m *= m;\n    pp = fract(pp+0.5)-0.5;\n    float dp = pmin(abs(pp.x), abs(pp.y), 0.025);\n    vec3 hsv = vec3(0.4+mix(0.15,0.0, m), tanh_approx(mix(100.0, 10.0, m)*dp), 1.0);\n    color = 5.5*hsv2rgb(hsv)*exp(-mix(30.0, 10.0, m)*dp);\n  }\n\n  vec3 lv   = lightPos - pos;\n  float ll2 = dot(lv, lv);\n  float ll  = sqrt(ll2);\n  vec3 ld   = lv / ll;\n  float sha = softShadow(pos, ld, ll, 0.01, 64.0);\n\n  float dm  = min(1.0, 40.0/ll2);\n  float dif = max(dot(nor,ld),0.0)*dm;\n  float spe = pow(max(dot(reflect(-ld, nor), -rd), 0.), 10.);\n  float l   = dif*sha;\n\n  float lin = mix(0.2, 1.0, l);\n\n  vec3 col = lin*color + spe*sha;\n\n  float f = exp(-20.0*(max(t-3.0, 0.0) / MAX_RAY_LENGTH));\n    \n  return mix(skyCol, col , f)*ifade;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q=fragCoord.xy/RESOLUTION.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 ro = 0.4*vec3(2.0, 0, 0.2)+vec3(0.0, 1.25, 0.0);\n  float tm = mix(10.33, 11.7, 0.5+0.5*sin(TIME*TAU/60.0));\n  ro.xz *= ROT(sin(tm));\n  ro.yz *= ROT(sin(tm*sqrt(0.5))*0.25);\n\n  vec3 ww = normalize(vec3(0.0, 1.0, 0.0) - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + (2.0+0.5*tanh_approx(length(p)))*ww);\n\n  vec3 col = render(ro, rd);\n  col = clamp(col, 0.0, 1.0);\n  fragColor = vec4(postProcess(col, q),1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"NlcGRM","date":"0","viewed":0,"name":"Fork Motion Twe neozhaolia 288","username":"neozhaoliang","description":"Creating a looping magnetized block animation using basic motion tweening techniques. ","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n\n\tMotion Tweening\n\t---------------\n\n\tCreating a looping animation with magnetized blocks utilizing basic motion \n    tweening techniques. The animation sequence itself is a rough recreation \n    of a sequence I've seen around in GIF form on the internet. I'm not sure \n    where the original came from, but if I were to take a guess, I'd say it was \n    created by Andreas Wannerstedt, who produces a lot of mesmerizing looping \n    animations... but I wouldn't quote me on it.\n\n    I've been away for a while, so wanted to start with something relatively\n\tsimple. Motion tweening requires a bit of effort, but is relatively easy\n\trepetitive work. Demosceners do stuff like this all the time, but for those \n\tnot familar with the process, you just choose a total looping time \n    (tm = mod(iTime, totalTime)), then partition it into individual time segments \n    using a case statement, or some if-elseif statements. The segment intervals \n    themselves are filled with interpolated motion, distortion, morphing, etc.\n\n    As you can see, none of the individual movements are particularly complex;\n    rotations, pivots, translations, etc -- A lot of it was made up on the fly,\n\tso I'd imagine there'd be more efficient ways to achieve the same. One thing\n\tto note is that the colored cube moves in conjunction with the larger one, \n    which might throw some people off, but that's just a simple case of moving \n    the chrome looking box, setting the cube coordinates to the chrome box \n\tcoordinate system (p = pPrevious), then peforming more simple operations.\n\t\n    I seem to say this a lot, but apologies in advance for the extended compile\n\ttime. This should run pretty quickly, but the lengthy decision-making logic\n\tinside the raymarching loop taxes the compiler, which is amplified with the \n\treflection pass. By the way, you could simplify the objects and use IQ's \n    raytraced rounded-box intersection formulas to make this way, way more\n\tefficient. However, keeping track of the rotations for normal calculations, \n    and so forth, would get pretty tiresome... It's the kind of thing I'll leave \n    for Dr2 to do. :)\n\n\n\n    Other examples:\n\n\n    // This is one of the most clever and innovative examples on here.\n    [SH18] Human Document - reinder\n    https://www.shadertoy.com/view/XtcyW4\n\n*/\n\n#define FAR 30.\n\nvec4 vObjID;\nint objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n// Time variables.\nfloat tm, t, t2;\n\n// Animation segment ID.\nint segID = 0;\n\n\n\n\n// Distance function: This one is pretty simple.\nfloat map(vec3 p){\n\n\n    // Floor.\n    float fl = p.y;  //-sBoxS(p - vec3(0, 3, 0), vec3(6, 3, 6),.04);//min(p.y, -p.y + 3.8);\n    \n    \n\n   \n    const vec3 bDim = vec3(.25, .5, .25);\n    const vec3 bDim2 = vec3(.25, .25, .25);\n    vec3 svDim = bDim;\n\n    vec3 q = p, q2 = p;\n \n    \n    // The rendering portion is the easy bit; Just some standard distance\n    // field operations with IQ's box formula.\n    \n    \n    // The chrome box.\n    float obj = sdSponge(q);\n    \n    // The colored cube.\n    float obj2 = sierpinski(q); \n    \n\n\n    // Store the floor, chrome box and gold cube positions for sorting\n    // and surface identification outside the loop.\n    vObjID = vec4(fl, obj, obj2, 0);\n    \n    \n    // Return the minimum object.\n    return min(min(fl, obj), obj2);\n}\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i = min(0, iFrame); i<80; i++){\n\n        d = map(ro + rd*t);\n        \n        // Using the hacky \"abs,\" trick, for more accuracy. \n        if(abs(d)<.001 || t>FAR) break;        \n        \n        t += d;  // Using more accuracy, in the first pass.\n    }\n    \n    return t;\n}\n\n// Second pass, which is the first, and only, reflected bounce. \n// Virtually the same as above, but with fewer iterations and less \n// accuracy.\n//\n// The reason for a second, virtually identical equation is that \n// raymarching is usually a pretty expensive exercise, so since the \n// reflected ray doesn't require as much detail, you can relax things \n// a bit - in the hope of speeding things up a little.\nfloat traceRef(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i = min(0, iFrame); i<48; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.001 || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return t;\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing repeat objects - in a setting like this - with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(0, iFrame); i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, .2), \n        // clamp(h, .02, stepDist*2.), etc.\n        dist += clamp(h, .01, .25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist>end) break; \n        //if (h<.001 || dist > end) break; // If you're prepared to put up with more artifacts.\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me.\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 1.5, occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.25/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n// The floor, chrome cube, and colored cube materials. These ones are pretty\n// basic, but you could put more effort in.\n//\nvec3 getObjectColor(vec3 p, vec3 r, vec3 n){\n    \n    \n    vec3 col;\n        \n    if(objID == 0) {\n       \n        // The floor.\n        vec3 tx = texture(iChannel0, p.xz/4.).xyz; tx *= tx;\n        col = tx*vec3(1, .7, .5)*.5;\n        \n    }\n    else if(objID == 2) {\n        \n        // The chrome colored box. It's something I tend to get, but tinging\n        // things blue can help bring about a metallic color... kind of. :)\n        col = vec3(.65, .85, 1);\n    }\n    else {\n        \n        // The cube. \n        col = vec3(2, 2, .45); // Redish gold.\n        //col = vec3(.7, 1.2, .3); // Green.\n        //col = vec3(2, .35, .85); // Pink.\n        //col = vec3(.3, 1, 2.5); // Blue.\n        //col = vec3(.3); // Grey\n    }\n    \n\n    // Adding some fake cube mapping information. The science is terrible, but it \n    // adds a bit of shine. :)\n    vec3 cTx = tex3D(iChannel0, reflect(r, n)/1.5, n);\n    cTx *= vec3(1, .8, .6);\n    \n    // Add a dose of fake reflection to the box and cube, and just a bit to the floor.\n    if(objID>0) col *= cTx*2.;\n    else col += cTx*.1;\n    \n    return col;\n\n}\n\n// Using the hit point, unit direction ray, etc, to color the \n// scene. Diffuse, specular, falloff, etc. It's all pretty \n// standard stuff.\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float t){\n    \n    \n    // Initiate the scene color to zero.\n    vec3 sceneCol = vec3(0);\n    \n    if(t<FAR){\n        \n        vec3 ld = lp - sp; // Light direction vector.\n        float lDist = max(length(ld), .0001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light vector.\n        \n        float ao = calcAO(sp, sn);\n\n        // Attenuating the light, based on distance.\n        float atten = 1./(1. + lDist*.2 + lDist*lDist*.05);\n\n        // Standard diffuse term.\n        float diff = max(dot(sn, ld), 0.);\n        // Standard specualr term.\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 8.);\n        \n        // Ramp up the diffuse value. Sometimes, it can help things look metallic.\n        diff = pow(diff, 4.)*2.;\n\n        // Coloring the object. You could set it to a single color, to\n        // make things simpler, if you wanted.\n        vec3 objCol = getObjectColor(sp, rd, sn);\n        \n\n        // Combining the above terms to produce the final scene color.\n        sceneCol = objCol*((diff + ao*.2) + vec3(1, .97, .92)*spec*4.);\n        \n        // Apply the attenuation and ambient occlusion.\n        sceneCol *= atten*ao;\n        \n    }\n    \n    \n    // Fog factor -- based on the distance from the camera.\n    float fogF = smoothstep(0., .9, t/FAR);\n    //\n    // Applying the background fog. Just black, in this case, but you could\n    // render sky, etc, as well.\n    sceneCol = mix(sceneCol, vec3(0), fogF); \n\n    \n    // Return the color. Performed once every pass... of which there are\n    // only two, in this particular instance.\n    return sceneCol;\n    \n}\n\n\nvec3 getRd(vec2 u, vec3 ro){\n   \n    // Camera Setup.     \n    vec3 lk = vec3(0, .5, 0);  // \"Look At\" position.\n\n \n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159265/3.; // FOV - Field of view.\n    vec3 fw = normalize(lk - ro);\n    vec3 rt = normalize(vec3(fw.z, 0, -fw.x )); \n    vec3 up = cross(fw, rt);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(fw + (u.x*rt + u.y*up)*FOV);\n    // Warping the ray to give that curved lens effect.\n    //rd = normalize(vec3(rd.xy, rd.z*(1. - length(rd.xy)*.25)));\n    \n    return rd;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\n    // Aspect correct screen coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    \n    // Slight barrel distortion.\n    float r = dot(uv, uv);\n    uv *= 1. + .2*(r*r + r);\n    \n    float cTm = iTime/2.;\n    vec3 ro = vec3(sin(cTm)*2.65, cos(tm)*sin(cTm)*.25 + 2.25, cos(cTm)*2.65);//vec3(0, 0, 0);\n    //vec3 ro = vec3(sin(cTm)*.75, cos(tm)*sin(cTm)*.25 + 2.25, -2.65);//vec3(0, 0, 0);\n \n    \n    vec3 rd = getRd(uv, ro);\n    \n    // Ray origin. Doubling as the surface position, in this particular example.\n    // I hope that doesn't confuse anyone.\n\n    vec3 lp = vec3(1, 3, -1); // Light position. Set in the vicinity the ray origin.\n    \n    \n    // FIRST PASS.\n    \n    // Raymarch.\n    float t = trace(ro, rd);\n \n    // Obtain the current object ID.\n    objID = vObjID.x < vObjID.y && vObjID.x < vObjID.z? 0 : vObjID.y < vObjID.z? 1 : 2;\n    \n    // Advancing the ray origin, \"ro,\" to the new hit point.\n    ro += rd*t;\n    \n    // Retrieving the normal at the hit point.\n    vec3 sn = getNormal(ro);\n    \n    // Retrieving the color at the hit point, which is now \"ro.\" I agree, reusing \n    // the ray origin to describe the surface hit point is kind of confusing. The reason \n    // we do it is because the reflective ray will begin from the hit point in the \n    // direction of the reflected ray. Thus the new ray origin will be the hit point. \n    // See \"traceRef\" below.\n    vec3 sceneColor = doColor(ro, rd, sn, lp, t);\n    \n    // Checking to see if the surface is in shadow. Ideally, you'd also check to\n    // see if the reflected surface is in shadow. However, shadows are expensive, so\n    // it's only performed on the first pass. If you pause and check the reflections,\n    // you'll see that they're not shadowed. OMG! Better call the shadow police. :)\n    float sh = softShadow(ro +  sn*.0015, lp, 12.);\n    sh = min(sh + .3, 1.);\n    \n    \n    // SECOND PASS - REFLECTED RAY\n    \n    // Standard reflected ray, which is just a reflection of the unit\n    // direction ray off of the intersected surface. You use the normal\n    // at the surface point to do that. Hopefully, it's common sense.\n    rd = reflect(rd, sn);\n    \n    \n    // The reflected pass begins where the first ray ended, which is the suface\n    // hit point, or in a few cases, beyond the far plane. By the way, for the sake\n    // of simplicity, we'll perform a reflective pass for non hit points too. Kind\n    // of wasteful, but not really noticeable. The direction of the new ray will\n    // obviously be in the direction of the reflected ray. See just above.\n    //\n    // To anyone who's new to this, don't forgot to nudge the ray off of the \n    // initial surface point. Otherwise, you'll intersect with the surface\n    // you've just hit. After years of doing this, I still forget on occasion.\n    t = traceRef(ro +  sn*.003, rd);\n    \n\n    // Obtain the current object ID.\n    objID = vObjID.x < vObjID.y && vObjID.x < vObjID.z? 0 : vObjID.y < vObjID.z? 1 : 2;\n    \n    // Advancing the ray origin, \"ro,\" to the new reflected hit point.\n    ro += rd*t;\n    \n    // Retrieving the normal at the reflected hit point.\n    sn = getNormal(ro);\n    \n    // Coloring the reflected hit point, then adding a portion of it to the final scene color.\n    // How much you add, and how you apply it is up to you, but I'm simply adding 35 percent.\n    //sceneColor += doColor(ro, rd, sn, lp, t)*.5;\n    // Other combinations... depending what you're trying to achieve.\n    vec3 rCol = doColor(ro, rd, sn, lp, t);\n    sceneColor = sceneColor + rCol*.75;\n    \n    \n    // APPLYING SHADOWS\n    //\n    // Multiply the shadow from the first pass by the final scene color. Ideally, you'd check to\n    // see if the reflected point was in shadow, and incorporate that too, but we're cheating to\n    // save cycles and skipping it. It's not really noticeable anyway. By the way, ambient\n    // occlusion would make it a little nicer, but we're saving cycles and keeping things simple.\n    sceneColor *= sh;\n    \n    \n    // Extra coloring.\n    //sceneColor *= vec3(1.1, 1, .9);\n\n    // Clamping the scene color, performing some rough gamma correction (the \"sqrt\" bit), then \n    // presenting it to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0., 1.)), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Easing functions are their own topic, but a lot of it is straight forward.\n// Usage is easy. Normalize the time between zero and one, then choose the \n// one you're after.\n\nconst float PI = 3.14159265358979;\n\n// Robert Penner's easing functions in GLSL.\n// Available as a module for glslify. http://stack.gl/glsl-easings/\n\nfloat easeInOutCubic(float t){\n\n    return t<0.5 ? 4.*t*t*t : (t - 1.)*(2.*t - 2.)*(2.*t - 2.) + 1.;\n}\n\nfloat easeInOutQuint(float t){\n\n    return t<.5 ? 16.*t*t*t*t*t : 1. +16.*(--t)*t*t*t*t;\n}\n\nfloat easeOutQuad(float t) {\n    return -1. * t * (t - 2.);\n}\n\nfloat easeInQuad(float t) {\n    return t * t;\n}\n\n \nfloat bounceOut(float t) {\n    \n  const float a = 4.0 / 11.0;\n  const float b = 8.0 / 11.0;\n  const float c = 9.0 / 10.0;\n\n  const float ca = 4356.0 / 361.0;\n  const float cb = 35442.0 / 1805.0;\n  const float cc = 16061.0 / 1805.0;\n\n  float t2 = t * t;\n\n  return t < a\n    ? 7.5625 * t2\n    : t < b\n      ? 9.075 * t2 - 9.9 * t + 3.4\n      : t < c\n        ? ca * t2 - cb * t + cc\n        : 10.8 * t * t - 20.52 * t + 10.72;\n}\n\nfloat bounceInOut(float t) {\n  return t < 0.5\n    ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))\n    : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\n}\n\nfloat bounceIn(float t) {\n  return 1.0 - bounceOut(1.0 - t);\n}\n\n\nfloat elasticOut(float t) {\n  return sin(-13.0 * (t + 1.0) * PI/2.) * pow(2.0, -10.0 * t) + 1.0;\n}\n\nfloat circularInOut(float t) {\n  return t < 0.5\n    ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n    : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nfloat exponentialIn(float t) {\n  return t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\n}\n\nfloat exponentialInOut(float t) {\n  return t == 0.0 || t == 1.0\n    ? t\n    : t < 0.5\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\n\n// IQ's unsigned box formula.\nfloat sBox(in vec3 p, in vec3 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n// IQ's unsigned rectangle formula.\nfloat sBox(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n\n\n\nfloat sdSponge(vec3 z) {\n    const float s = 1.8;\n    z *= s;\n    z.y -= 1.;\n    const int SPONGE_ITERATIONS = 5;\n    for(int i = 0; i < SPONGE_ITERATIONS; i++) {\n        z = abs(z);\n        z.xy = (z.x < z.y) ? z.yx : z.xy;\n        z.xz = (z.x < z.z) ? z.zx : z.xz;\n        z.zy = (z.y < z.z) ? z.yz : z.zy;\n        z = z * 3.0  - 2.0 ;\n        z.z += (z.z < -1.0) ? 2.0 : 0.0;\n    }\n    //distance to cube\n    z = abs(z) - vec3(1);\n    float dis = min(max(z.x, max(z.y, z.z)), 0.0) + length(max(z, 0.0));\n    //scale cube size to iterations\n    dis =  dis * pow(3.0, -float(SPONGE_ITERATIONS)) ;\n    return dis / s;\n\n}\n\n\n\nfloat sierpinski( vec3 z )\n{\n    z *= 1.5;\n    z -= vec3(2, 1, 2);\n   const float Phi = 1.61803398875;\nconst vec3 n1   = normalize(vec3(-Phi   , Phi-1.0, 1.0    ));\nconst vec3 n2   = normalize(vec3(1.0    , -Phi   , Phi+1.0));\nconst vec3 o    = normalize(vec3(-Phi, -1.   , 0      ));\n\n    float s = 1.;\n    float orbit = 1e20;\n       \n    z = abs(z);      \n    z -= 2.*max(0.,dot(z,n2))*n2;\n    z.z = abs(z.z); \n    z -= 2.*max(0.,dot(z,n2))*n2;\n    const int ITERATIONS = 10;\n    const float SCALE = 2.;\n    for(int n=0;n < ITERATIONS;n++) {\n\t\torbit = min(orbit,dot(z,z));\n         \n        z = abs(z);             \n        z -= 2.*max(0.,dot(z,n1))*n1; \n        \n\t\tz *= SCALE;\n        s *= SCALE;\n        \n        z += o;\n    }\n    \n    //dis & descale\n    \n    return (length(z)-1.) / s / 1.5; \n\n\n}","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"dlGyRm","date":"0","viewed":0,"name":"Fork Neo three  neozhaolia 512","username":"neozhaoliang","description":"Motivated by Escher's artwork \"three worlds\", try to combine spherical, Euclidean, hyperbolic geometry in one scene. See three worlds through the mirrors at the same time.","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 get_floor_color(vec2 z) {\n    // Modify P, Q, R to change the tiling\n    const float P = 2.;\n    const float Q = 3.;\n    const float R = 7.;\n    const float cp = cos(PI / P), sp = sin(PI / P);\n    const vec2 mB = vec2(-cp, sp);\n    const float k1 = cos(PI / Q);\n    const float k2 = (cos(PI / R) + cp * k1) / sp;\n    const float rad = 1. / sqrt(k1 * k1 + k2 * k2 - 1.);\n    const vec2 cen = vec2(k1 * rad, k2 * rad);\n    const vec2 v0 = vec2(0, cen.y - sqrt(rad * rad - cen.x * cen.x));\n    const vec2 n_ = vec2(-mB.y, mB.x);\n    const float b_ = dot(cen, n_);\n    const float c_ = dot(cen, cen) - rad * rad;\n    const float k_ = b_ + sqrt(b_ * b_ - c_);\n    const vec2 m0 = k_ * n_;\n\n    vec2 p = square_to_disc(z);\n    vec2 invCtr = vec2(1);\n    float t = 1. / dot(p -invCtr, p - invCtr);\n    p = mix(invCtr, p, t);\n    p.x = -p.x;\n    p = rot2(iTime/12.)*p;\n\n    if (length(p) > 1.)\n        p /= dot(p, p);\n\n    float count = 0.;\n    for (int i = 0; i < MAX_TILING_REFLECTIONS; i++) {\n        if (p.x < 0.) {\n            p.x = -p.x;\n            count += 1.;\n        }\n        float k = dot(p, mB);\n        if (k < 0.) {\n            p -= 2. * k * mB;\n            count += 1.;\n        }\n        \n        float d = length(p - cen) - rad;\n        if (d < 0.) {\n            p -= cen;\n            p *= rad * rad / dot(p, p);\n            p += cen;\n            count += 1.;\n        }\n    }\n    \n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    ln = min(ln, lBox(p, vec2(0), v0, .007));    \n    ln = min(ln, lBox(p, vec2(0), m0, .007));\n    ln = min(ln, length(p - cen) - rad - 0.007);\n\n    ln2 = min(ln2, lBox(p, vec2(0), m0, .007));\n    pnt = min(pnt, length(p - v0)); \n    pnt = min(pnt, length(p - m0)); \n    \n    float sf = 2. / iResolution.y;\n    float rnd = smoothstep(.8, .97, sin(iTime*.5 + count)*.5 + .5);\n        \n    vec3 oCol = .55 + .45*cos(count * PI / 4. + vec3(0, 1, 2));\n    oCol = mix(oCol*.1, clamp(oCol*3.5, 0., 1.), rnd);\n     \n    float pat = smoothstep(0., .25, abs(fract(ln2*50. - .2) - .5)*2. -.2);\n   \n    float sh = clamp(.65 + ln/v0.y*4., 0., 1.);\n    vec3 col = min(oCol*(pat*.2 + .9)*sh, 1.);\n\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - BlackRegionSize)));\n\n    pnt -= .032;\n    pnt = min(pnt, length(p) - .032);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnt));\n    \n    rnd = smoothstep(.8, .97, sin(iTime * 1.5)*.5 + .5);\n    vec3 blink = vec3(1.3, 0.25, 0.35);\n    blink = mix(blink * 0.5, blink * 2.2, rnd);\n    col = mix(col, blink, 1. - smoothstep(0., sf, pnt + .02));\n    return col;\n}\n\nvec3 get_ceil_color(vec2 p) {\n    const float P = 3.;\n    const float Q = 3.;\n    const float R = 3.;\n    const float cp = cos(PI / P), sp = sin(PI / P);\n    const float cq = cos(PI / Q), cr = cos(PI / R);\n    const vec2 mB = vec2(-cp, sp);\n    const vec3 mC = vec3(-cr, -(cq + cr * cp) / sp, 1.);\n    const vec2 v0 = vec2(0, -1./mC.y);\n    const float k_ = mB.x / mB.y;\n    const float x_ = 1. / (k_ * mC.y - mC.x);\n    const float y_ = -k_ * x_;\n    const vec2 m0 = vec2(x_, y_);\n    \n    p = rot2(iTime/12.)*p;\n\n    float count = 0.;\n    for (int i = 0; i < MAX_TILING_REFLECTIONS; i++) {\n        if (p.x < 0.) {\n            p.x = -p.x;\n            count += 1.;\n        }\n        float k = dot(p, mB);\n        if (k < 0.) {\n            p -= 2. * k * mB;\n            count += 1.;\n        }\n        \n        k = dot(vec3(p, 1.), mC);\n        if (k < 0.) {\n            p -= 2. * k * mC.xy;\n            count += 1.;\n        }\n    }\n    \n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    //ln = min(ln, lBox(p, vec2(0), v0, .05));    \n    //ln = min(ln, lBox(p, vec2(0), m0, .05));\n    ln = min(ln, lBox(p, v0, m0, .05));\n\n    ln2 = min(ln2, lBox(p, vec2(0), m0, .007));\n    pnt = min(pnt, length(p - v0)); \n    pnt = min(pnt, length(p - m0)); \n    \n    float sf = 2. / iResolution.y;\n    float rnd = smoothstep(.8, .97, sin(iTime + count * PI)*.5 + .5);\n        \n    vec3 oCol = .55 + .45*cos(count * PI / 8. + vec3(0, 1, 2)).yzx;\n    oCol = mix(oCol*.1, clamp(oCol*1.5, 0., 1.), rnd);\n     \n    float pat = smoothstep(0., .25, abs(fract(ln2*15. - .2) - .5)*2. -.2);\n   \n    float sh = clamp(.65 + ln/v0.y*4., 0., 1.);\n    vec3 col = min(oCol*(pat*.2 + .9)*sh, 1.);\n\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - BlackRegionSize * 16.)));\n\n    pnt -= .15;\n    pnt = min(pnt, length(p) - .15);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnt));\n    \n    rnd = smoothstep(.4, .5, sin(iTime)*.5 + .5);\n    vec3 blink = vec3(1.3, 0.25, 0.35);\n    blink = mix(blink * 0.5, blink * 2.2, rnd);\n    col = mix(col, blink, 1. - smoothstep(0., sf, pnt + .02));\n    return col;\n}\n\n// distance to the four sides of mirrors \nfloat sdMirror(vec3 p) {\n    vec2 d = RoomSize.xz - abs(p.xz);\n    return min(d.x, d.y);\n}\n\n// the floor and the ceil\nfloat sdFloor(vec3 p) {\n    return RoomSize.y - abs(p.y);\n}\n\n// wood framework\nfloat sdRoomFrame(vec3 p) {\n    return sdBoxFrame(p, RoomSize, vec3(RoomFrameSize));\n}\n\nfloat sdMirrorFrame(vec3 p) {    \n    float d1 = sdBoxFrame(p, RoomSize, WindowFrameSize.xyy);\n    float d2 = sdBoxFrame(p, RoomSize, WindowFrameSize.yxy);\n    float d3 = sdBoxFrame(p, RoomSize, WindowFrameSize.yyx);\n    return min(d1, min(d2, d3));\n}\n\n// polyhedra with faces and edges\nvec2 sdPolyhedra(vec3 p) {\n    p *= RotObj;\n    p = fold_spherical(p);\n    p -= v0S;\n    float d1 = sdPolyhedraFaces(p);\n    float d2 = sdPolyhedraEdges(p);\n    float d = min(d1, d2);\n    float id = d1 < d2 ? 1. : 2.;\n    return vec2(d, id);\n}\n\nfloat sdScene(vec3 p) {\n    float d1 = sdMirror(p);\n    float d2 = sdFloor(p);\n    float d3 = sdRoomFrame(p);\n    float d4 = sdMirrorFrame(p);\n    float d5 = sdPolyhedra(p).x;\n    return min(d1, min(d2, min(d3, min(d4, d5))));\n}\n\nvec3 trace(vec3 pos, vec3 rd) {\n    float h = 1.0;\n    for (int i = 0; i < MAX_TRACE_STEPS; i++) {\n        if (h < PRECISION)\n            break;\n        h = sdScene(pos);\n        pos += rd * min(h, MAX_MARCH_STEP);\n    }\n    return pos;\n}\n\nfloat soft_shadow(vec3 pos, vec3 lp) {\n    const float softness = 16.;\n    const float shadowStartDistance = .1;\n    const int shadowLoopCount = 16;\n\n    vec3 ld = lp - pos;\n    float ldist = max(length(lp), 0.001);\n    ld /= ldist;\n    float epsilon = .001;\n    float t = shadowStartDistance;\n    float h = 1.;\n    float shade = 1.0;\n    for (int i=0; i < shadowLoopCount; i++ ) {\n        if (h < epsilon || t > ldist)\n            break;\n        h = sdScene(pos + ld * t);\n        shade = min(shade, smoothstep(0.0, 1.0, softness*h/t));\n        t += h;\n    }\n    return clamp(shade + 0.25, 0., 1.);\n}\n\nvec3 get_normal(vec3 p) {\n    const vec2 d = vec2(-1, 1) * .001;\n    return normalize(\n            sdScene(p + d.xxx)*d.xxx +\n            sdScene(p + d.yyx)*d.yyx +\n            sdScene(p + d.yxy)*d.yxy +\n            sdScene(p + d.xyy)*d.xyy);\n}\n\nstruct Light {\n    vec3 pos;\n    vec3 col;\n};\n\nLight lights[] = Light[] (\n    Light(vec3(2.5, 2.2, 2.5), vec3(1) * 5.),\n    Light(vec3(-1, -.5, -1), vec3(1))\n);\n\nvoid ray_bounce(in vec3 p,\n                in vec3 rd,\n                out vec3 diffuse,\n                out vec3 ref_dir,\n                out vec3 bounceTint,\n                in vec3 normal) {\n\n    vec3 bCol = vec3(0);\n    for( int i=0; i < lights.length(); i++ ) {\n        vec3 ld = lights[i].pos - p;\n        float ldist = max(length(ld), 0.001);\n        ld /= ldist;\n        float diff = max(0., dot(normal, ld));\n        float at = 1.5 / (1. + ldist * 0.3 + ldist * ldist * 0.1);\n        float sh = soft_shadow(p, lights[i].pos);\n        bCol += lights[i].col * sh * (.2 + diff) * at;\n    }\n    // ambient light\n    vec3 ao = vec3(.03,.05,.07);\n    // sample SDF to approximate occlusion\n    ao *= exp2(min(0., sdScene(p + normal * 0.3) / 0.3 - 1.));\n    ao *= exp2(min(0., sdScene(p + normal * .15) / .15 - 1.));\n    ao *= exp2(min(0., sdScene(p + normal * .07) / .07 - 1.));\n    bCol += ao;\n    \n    // https://www.shadertoy.com/view/tlBGR1\n    vec3 albedo = vec3(.3,.5,.6) * .4;\n    vec4 specLevel = vec4(0.9, 0.9, 0.9, 1);\n\n    float d1 = sdMirror(p);\n    float d2 = sdFloor(p);\n    float d3 = sdRoomFrame(p);\n    float d4 = sdMirrorFrame(p);\n    vec2 sdPoly = sdPolyhedra(p);\n    float d5 = sdPoly.x, id = sdPoly.y;\n    float d = min(d1, min(min(d2, d3), min(d4, d5)));\n    \n    if (d == d3) {  // room frame\n        albedo = vec3(.25);\n        specLevel = vec4(0.08);\n    }\n    else if (d == d4) {  // mirror border\n        albedo = vec3(0.01);\n        specLevel = vec4(0.2, 0.2, 0.2, 1.);\n    }\n    else if (d == d5) {  // polyhedra\n        if (id == 2.) {  // polyhedra edges\n            albedo = vec3(0.15, 0.3, 0.8);\n            specLevel = vec4(vec3(0.05), 1.);\n        }\n        else {  // polyhedra faces\n            specLevel = vec4(0.7);\n        }\n    }\n    else if (d == d2) {  // floor and ceil\n        vec2 uv = p.xz;\n        albedo = p.y < 0. ? get_floor_color(uv / (RoomSize.x - RoomFrameSize))\n                          : get_ceil_color(uv * 2.);\n        float ior = 1.33;\n        float schlick = pow((ior - 1.) / (ior + 1.), 2.);\n\t    specLevel = vec4(vec3(schlick), 1);\n    \tspecLevel *= mix(.2, .7, p.x);\n    \tnormal = normalize(normal + (texture(iChannel0, vec2(p.xz) /2.).rgb - .5) * .005);\n    }\n    \n    float fresnel = pow(dot(normal, rd) + 1., 5.);\n    vec3 spec = mix(specLevel.xyz, specLevel.www, fresnel);\n    \n    bounceTint = spec;\n    diffuse = albedo * (vec3(1) - spec) * bCol;\n    ref_dir = reflect(rd, normal);\n}\n\nvec3 get_ray_color(vec3 ro, vec3 rd) {\n    vec3 pos = ro;\n    vec3 tint = vec3(1);\n\n    vec3 col = vec3(0);\n    for (int i = 0; i < MAX_RAY_BOUNCES; i++) {\n        pos = trace(pos, rd);\n        vec3 normal = get_normal(pos);\n        vec3 bounceTint, diffuse;\n        ray_bounce(pos, rd, diffuse, rd, bounceTint, normal);\n        pos += normal * PRECISION * 2.;\n        col += diffuse * tint;\n        tint *= bounceTint;\n        if (length(tint) < .01)\n            break;\n    }\n    return col;\n}\n\nmat3 camera_matrix(vec3 eye, vec3 lookat, vec3 up) {\n    vec3 forward = normalize(lookat - eye);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    return mat3(right, up, -forward);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init_spherical();\n\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 movement = vec2(iTime * 0.2, sin(iTime * 0.2) * 0.5);\n    vec3 eye = 2.5 * vec3(\n        cos(movement.x) * cos(movement.y),\n        0.5*sin(movement.y),\n        sin(movement.x) * cos(movement.y));\n    eye += vec3(1, 0.3, 1) * cos(vec3(0.75, 0.3, 0.2) * iTime);\n   \n    vec2 mouse = vec2(0);\n    if (iMouse.x > 0.) {\n        mouse = 2. * iMouse.xy / iResolution.y - 1.;\n        eye = rot_y(mouse.x) * rot_x(mouse.y) * eye;\n    }\n    vec3 lookat = vec3(0);\n    vec3 up = vec3(0, 1, 0);\n    mat3 M = camera_matrix(eye, lookat, up);\n    \n    vec3 ray = M * normalize(vec3(uv, -2.));\n    vec3 col = get_ray_color(eye, ray);\n    fragColor = vec4(clamp(sqrt(col), 0., 1.), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI  3.141592654\n#define BlackRegionSize  0.03\n#define L2(x)  dot(x, x)\n#define RotObj  rot_x(iTime/2.)*rot_z(iTime/3.)\n#define PolyhedraEdgeSize  0.02\n#define PolyhedraFaceOffset  0.\n#define RoomSize  vec3(5, 2.5, 5)\n#define RoomFrameSize  0.5\n#define WindowFrameSize vec2(RoomFrameSize*1.2, 0)\n#define MAX_TILING_REFLECTIONS 12\n#define MAX_TRACE_STEPS  128\n#define MAX_RAY_BOUNCES  15\n#define PRECISION        1e-3\n#define MAX_MARCH_STEP   1.0\n#define min3(x, y, z)     (min(x, min(y, z)))\n#define max3(x, y, z)     (max(x, max(y, z)))\n\n\nconst vec3 pqr_wythoff = vec3(5, 2, 3);\nconst vec3 bary = vec3(1, 1, 1);\n\nmat3 matS, triS;\nvec3 v0S;\n\nvoid init_spherical() {\n    vec3 c = cos(PI / pqr_wythoff);\n    float sp = sin(PI / pqr_wythoff.x);\n    vec3 m1 = vec3(1, 0, 0);\n    vec3 m2 = vec3(-c.x, sp, 0);\n    float x3 = -c.z;\n    float y3 = -(c.y + c.x*c.z)/sp;\n    float z3 = sqrt(1.0 - x3*x3 - y3*y3);\n    vec3 m3 = vec3(x3, y3, z3);\n    matS = mat3(m1, m2, m3);\n    triS[0] = normalize(cross(m2, m3));\n    triS[1] = normalize(cross(m3, m1));\n    triS[2] = normalize(cross(m1, m2));\n    v0S = normalize(bary * inverse(matS));\n}\n\nvec3 fold_spherical(vec3 p) {\n    for (int i = 0; i < 5; i++)\n    for (int j = 0; j < 3; j++) {\n        p -= 2. * min(dot(p, matS[j]), 0.) * matS[j];\n    }\n    return p;\n}\n\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n ) {\n    n = max(n * n, 0.001);\n    n /= (n.x + n.y + n.z ); \n\treturn (\n        texture(tex, p.yz) * n.x +\n        texture(tex, p.zx) * n.y +\n        texture(tex, p.xy) * n.z\n    ).xyz;\n}\n\nmat2 rot2(in float a) {\n    float c = cos(a), s = sin(a); return mat2(c, -s, s, c);\n}\n\nmat3 rot_x(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0,  0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\nmat3 rot_y(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n}\n\nmat3 rot_z(in float t) {\n    float cz = cos(t), sz = sin(t);\n    return mat3(cz, -sz, 0.,\n                sz, cz, 0.,\n                0., 0., 1.);\n}\n\nfloat sBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew) {\n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n// https://www.shadertoy.com/view/3ljcRh\n// I changed e to vec3 so it works for non-uniform edge size\nfloat sdBoxFrame(vec3 p, vec3 b, vec3 e) {\n    p = abs(p) - b;\n    vec3 q = abs(p + e) - e;\n    return min(min(\n        length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n        length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n        length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdPolyhedraEdges(vec3 p) {\n    float d = 1e5;\n    for (int i = 0; i < 3; i++) {\n        d = min(d, L2(p - min(0., dot(p, matS[i])) * matS[i]));\n    }\n\treturn sqrt(d) - PolyhedraEdgeSize;\n}\n\nfloat sdPolyhedraFaces(vec3 p) {\n   return max(dot(p, triS[0]), max(dot(p, triS[1]), dot(p, triS[2]))) - PolyhedraFaceOffset;\n}\n\n//complex multiplication\nvec2 cMul(vec2 a, vec2 b) {\n\treturn vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\n// complex inverse \nvec2 cDiv( vec2 a, vec2 b ) {\n  float d = dot(b, b);\n  return vec2(dot(a, b), a.y*b.x - a.x*b.y ) / d;\n}\n\n// complex inverse \nvec2 cInv(vec2 a) {\n\treturn vec2(a.x, -a.y) / dot(a, a);\n}\n\n// code below taken from @mla's https://www.shadertoy.com/view/Mlsfzs\nvoid sncndn(float u, float k2,\n            out float sn, out float cn, out float dn) {\n    float emc = 1.0 - k2;\n    float a = 1.0, b, c;\n    const int N = 4;\n    float em[N], en[N];\n    dn = 1.0;\n    for (int i = 0; i < N; i++) {\n        em[i] = a;\n        emc = sqrt(emc);\n        en[i] = emc;\n        c = 0.5*(a + emc);\n        emc *= a;\n        a = c;\n    }\n\n    u = c*u;\n    sn = sin(u);\n    cn = cos(u);\n    if (sn != 0.0) {\n        a = cn / sn;\n        c *= a;\n        for(int i = N - 1; i >= 0; i--) {\n            b = em[i];\n            a *= c;\n            c *= dn;\n            dn = (en[i] + a) / (b + a);\n            a = c/b;\n        }\n        a = 1.0 / sqrt(c*c + 1.0);\n        if (sn < 0.0)\n            sn = -a;\n        else\n            sn = a;\n        cn = c * sn;\n    }\n}\n\nvec2 cn(vec2 z, float k2) {\n  float snu, cnu, dnu, snv, cnv, dnv;\n  sncndn(z.x, k2, snu, cnu, dnu);\n  sncndn(z.y, 1.0-k2, snv, cnv, dnv);\n  return vec2(cnu * cnv, -snu*dnu*snv*dnv) / (1. - dnu*dnu*snv*snv);\n}\n\nvec2 square_to_disc(vec2 z) {     \n    z = cDiv(z, vec2(1));\n    z -= vec2(1, 0);\n    z *= 1.854;\n    z = cn(z, 0.5);\n    z = cMul(z, vec2(0.70711));\n    return z;\n}","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"7tVcRK","date":"0","viewed":0,"name":"Fork Pathtraced neozhaolia 255","username":"neozhaoliang","description":"A pathtraced voxel terrain using traversal algorithm.\n\nFeatures:\n- motion blur\n- depth of field\n- antialiasing\n- global illumination\n- reflections","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n#define TAU 6.283185\n#define SAMPLES 4\n#define ANTIALIAS\n#define MOTION_BLUR\n#define DEPTH_OF_FIELD\n\n#define MAX_BOUNCES 12\n#define MAX_DIST 40.\n\nfloat seed;\n\n// hash functions by Nimitz: https://www.shadertoy.com/view/Xt3cDn\n\nuint hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash1(inout float seed) {\n    uint n = hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash2(inout float seed) {\n    uint n = hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat hash31(vec3 p) {\n    p = fract(p*vec3(234.342, 123.432, 432.234));\n    p += dot(p, p+118.432);\n    return fract(p.x*p.y*p.z);\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n// random functions by reinder: https://www.shadertoy.com/view/XlGcWh\n\nvec2 random2D(inout float seed) {\n    vec2 h = hash2(seed) * vec2(1.,TAU);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r * vec2(sin(phi), cos(phi));\n}\n\nvec3 random3D(inout float seed) {\n    vec3 h = hash3(seed) * vec3(2.,TAU,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi), cos(phi)), h.x);\n}\n\nstruct Ray {\n    vec3 o, d; // origin and direction\n};\n\nstruct Camera {\n    vec3 o, d; // origin and direction\n    float z, a; // zoom and aperture\n};\n\n// ray setup function\nRay getRay(vec2 uv, Camera c, float aspect) {\n    float lensRad = c.a * .5;\n    float focDist = length(c.o - c.d);\n    float hh = tan(radians(c.z)*.5);\n    float hw = aspect * hh;\n\n    vec3 f = normalize(c.o - c.d);\n    vec3 s = normalize(cross(vec3(0,1,0), f));\n    vec3 u = cross(f, s);\n    \n    vec3 r = c.o - hw*focDist*s - hh*focDist*u - focDist*f;\n    vec3 h = 2.*hw*focDist*s;\n    vec3 v = 2.*hh*focDist*u;\n    \n    vec2 d = lensRad*random2D(seed);\n    vec3 o = s*d.x + u*d.y;\n    \n    vec3 i = normalize(r + uv.x*h + uv.y*v - c.o - o);\n    \n    return Ray(c.o + o, i);\n}\n\n#define LAMB 0\n#define METAL 1\n\nstruct Material {\n    int type; // metal, lambertian\n    vec3 col; // color of the object\n    float k; // roughness\n};\n\nvec3 intersectPoint(Ray r, vec3 p, vec3 s) {\n    return (p - r.o + .5-.5*s) / r.d;\n}\n\n// intersections function\n\nfloat intersect(Ray r, out vec3 n, out Material mat) {\n    vec3 p = floor(r.o);\n    vec3 m = 1./abs(r.d);\n    \n    vec3 s, q;\n    \n    if (r.d.x < 0.) {s.x = -1.;q.x =    fract(r.o.x);}\n    else {           s.x =  1.;q.x = 1.-fract(r.o.x);}\n    if (r.d.y < 0.) {s.y = -1.;q.y =    fract(r.o.y);}\n    else {           s.y =  1.;q.y = 1.-fract(r.o.y);}\n    if (r.d.z < 0.) {s.z = -1.;q.z =    fract(r.o.z);}\n    else {           s.z =  1.;q.z = 1.-fract(r.o.z);}\n    \n    q *= m;\n    \n    float t = -1.;\n    for (int i = 0; i < 128; i++) {\n        if (q.x < q.y && q.x < q.z) {\n            q.x += m.x;\n            p.x += s.x;\n            t = intersectPoint(r, p, s).x;\n            n = vec3(-sign(r.d.x),0,0);\n        } else if (q.y < q.z) {\n            q.y += m.y;\n            p.y += s.y;\n            t = intersectPoint(r, p, s).y;\n            n = vec3(0,-sign(r.d.y),0);\n        } else {\n            q.z += m.z;\n            p.z += s.z;\n            t = intersectPoint(r, p, s).z;\n            n = vec3(0,0,-sign(r.d.z));\n        }\n        if (p.y*abs(1.*sin(.5*p.y)) < -4.-4.*sin(.35*p.x)*sin(.35*p.z) + 2.5*sin(.5*p.x)*sin(.5*p.z) || p.y < -7. || t > MAX_DIST) {\n            break;\n        }\n    }\n    \n    float v = hash31(p);\n    if (v < .5) {\n        mat = Material(LAMB, vec3(1,.8,.6), 0.);\n    } else if (v > .5) {\n        mat = Material(METAL, vec3(1,.3,.3), 0.);\n    } else {\n        mat = Material(METAL, vec3(.4,.6,1), .5);\n    }\n    if (p.y < -6.) {\n        mat = Material(METAL, vec3(.4,.5,.8), .05);\n    }\n    \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    vec3 tot = vec3(0);\n    for (int i = 0; i < SAMPLES; i++) {\n    \n        // antialiasing code by Reinder: https://www.shadertoy.com/view/llVcDz\n\n        seed = float(hash(floatBitsToUint(fragCoord)))/float(0xffffffffU)+float(i);\n        \n        #ifdef ANTIALIAS\n        vec2 o = hash2(seed) - .5;\n        #else\n        vec2 o = vec2(0);\n        #endif\n        \n        vec2 uv = (fragCoord + o) / iResolution.xy;\n        \n        #ifdef MOTION_BLUR\n        float time = iTime + .025*(hash1(seed)-.5);\n        #else\n        float time = iTime;\n        #endif\n        time += 10.*mouse.x;\n\n        // setup camera\n        \n        #ifdef DEPTH_OF_FIELD\n        Camera c = Camera(vec3(-.5,6.+2.*cos(time),-8), vec3(0,0,0), 90., .5);\n        #else\n        Camera c = Camera(vec3(-.5,6.+2.*cos(time),-8), vec3(0,0,0), 90., .0);\n        #endif\n        \n        c.o.xz *= rot(.25*sin(time));\n\n        Ray r = getRay(uv, c, iResolution.x/iResolution.y);\n        r.o.x += 5.*cos(time);\n        r.o.z += 7.*time;\n\n        vec3 n;\n        Material mat;\n    \n        vec3 col = vec3(1);\n        \n        // pathtrace\n        \n        for (int i = 0; i < MAX_BOUNCES; i++) {\n            float t = intersect(r, n ,mat);\n            if (t < MAX_DIST) {\n                col *= mat.col;\n                r.o += r.d * t;\n            \n                if (mat.type == LAMB) { // diffuse\n                    r.d = normalize(n + random3D(seed));\n                } else if (mat.type == METAL) { // reflection\n                    r.d = normalize(reflect(r.d, n) + mat.k*random3D(seed));\n                }\n            } else { // sky\n                col *= mix(vec3(1), vec3(.4,.6,1), .5+.5*r.d.y);\n            \n                break;\n            }\n        }\n        \n        col = pow(col, vec3(.4545)); // gamma correction\n        col = smoothstep(0.,1.,col); // exposure\n        \n        // vignetting\n        \n        uv = (fragCoord - .5*iResolution.xy) / iResolution.y;\n        col *= 1.-.2*dot(uv,uv);\n        \n        tot += col;\n    }\n    tot /= float(SAMPLES);\n    \n    // output\n    \n    fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"dlsfD4","date":"0","viewed":0,"name":"Fork Rotating S neozhaolia 893","username":"neozhaoliang","description":"Another space flipping experiment, similar to [url]https://www.shadertoy.com/view/Xdf3Rn[/url], [url]https://www.shadertoy.com/view/MsXGRf[/url] and [url]https://www.shadertoy.com/view/4dsGD7[/url]. I used an infinite grid like Kali's Inversion Machine.","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Copyright Inigo Quilez, 2015 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2    // set AA to 1 if you have a slow machine  \n#endif\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nvec3 deform( in vec3 p, in float time, out float sca )\n{\n    float s = 0.34*sqrt(dot(p*p,p*p));\n    //float s = 1.0;\n\n    p = p/s;\n\n    p.xyz += 4.0*sin(0.5*vec3(1.0,1.1,1.3)*time+vec3(0.0,2.0,4.0));\n    \n    sca = s;\n    \n\treturn p;\n}\n\nfloat shape( vec3 p )\n{\n    vec3 q = mod( p+1.0, 2.0 ) -1.0;\n\n    float d1 = udRoundBox(q,vec3(0.10,0.02,1.00),0.02);\n    float d2 = udRoundBox(q,vec3(0.02,1.00,0.10),0.02);\n    float d3 = udRoundBox(q,vec3(1.00,0.10,0.02),0.02);\n    float d4 = udRoundBox(q,vec3(0.30,0.30,0.30),0.02);\n\n    return min( min(d1,d2), min(d3,d4) );\n}\n\n// 2d rotation\nvec2 rot2d(vec2 p, float a) { return cos(a) * p + sin(a) * vec2(p.y, -p.x); }\n\nvoid rot4d(inout vec4 p)\n{\n    p.xy = rot2d(p.xy, iTime*0.2);\n    p.zw = rot2d(p.zw, iTime*0.2);\n}\n\n\nfloat map( vec3 p, float t )\n{\n    float r = length(p);\n    vec4 q = vec4(2.*p, 1.-r*r) / (1.+r*r);\n    rot4d(q);\n    bool found = fold(q);\n    if (found) {\n        float id;\n        float dvert = dVertex(q, r);\n        float dedge = dSegments(q, r, id);\n        id = (dvert < dedge) ? 4. : id;\n        return min(dvert, dedge);\n        }\n        return 1e5;\n}\n\nvec3 calcNormal( in vec3 pos, in float eps, in float t )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy, t ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, t ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, t ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, t ) );\n}\n\nvec3 calcNormal2( in vec3 pos, in float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*shape( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*shape( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*shape( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*shape( pos + e.xxx ) );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        float h = 0.01 + 0.5*float(i)/7.0;\n        occ += (h-shape( pos + h*nor ));\n    }\n    return clamp( 1.0 - 4.0*occ/8.0, 0.0, 1.0 );    \n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float k, in float time )\n{\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<32; i++ )\n    {\n        float h = map(ro + rd*t, time);\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n        t += clamp( h, 0.04, 0.1 );\n\t\tif( res<0.01 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n    vec3 m = pow( abs( n ), vec3(k) );\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}\n\nvec3 shade( in vec3 ro, in vec3 rd, in float t, float time )\n{\n    float eps = 0.001;\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos, eps, time );\n    float kk;\n    vec3 qos = deform( pos, time, kk );\n    vec3 qor = calcNormal2( qos, eps );\n\n    vec3 tex = texcube( iChannel0, qos*0.5, qor, 1.0 ).xyz;\n\n    vec3 lig = normalize( vec3(2.0,1.0,0.2) );\n\n    float fre = pow( clamp(1.0+dot(nor,rd), 0.0, 1.0 ), 2.0 );\n    float occ = calcAO( qos, qor );\n\n    float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n    float sha = softshadow( pos, lig, 64.0, time ); \n    dif *= sha;\n        \n    vec3 col = 2.0*vec3(1.1,0.8,0.6)*dif*(0.5+0.5*occ) + 0.6*vec3(0.1,0.27,0.4)*occ;\n    col += 1.0*fre*(0.5+0.5*dif)*occ;\n    float sh = 4.0 + tex.x*64.0;\n    col += 0.1*sh*pow(clamp(-dot(rd,nor),0.0,1.0),sh)*occ*sha;\n    col *= clamp(2.0*dot(pos,pos),0.0,1.0);\n\n    col *= 6.0*tex;\n    \n    col *= exp( -1.5*t );\n\n    return col;        \n}\n\nfloat intersect( in vec3 ro, in vec3 rd, const float maxdist, float time )\n{\n    float res = -1.0;\n    vec3 resP = vec3(0.0);\n    float t = 0.1;\n    for( int i=0; i<100; i++ )\n    {\n        vec3 p = ro + t*rd;\n        float h = map( p, time );\n        res = t;\n\n        if( h<(0.001*t) || t>maxdist ) break;\n        \n        t += h*0.5;\n    }\n\treturn res;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, float time )\n{\n    vec3 col = vec3(0.0);\n    \n    const float maxdist = 32.0;\n    float t = intersect( ro, rd, maxdist, time );\n    if( t < maxdist )\n    {\n        col = shade( ro, rd, t, time );\n    }\n\n    return pow( col, vec3(0.55) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nfloat hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\ninit();\n#if AA>1\n    vec3 col = vec3(0.0);\n    \n    float r = texture( iChannel1, fragCoord/iChannelResolution[1].xy ).x;\n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        vec2 p = (2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y;\n\n        float time = iTime + (r+float(AA*j + i))/float(AA*AA) * (0.4/30.0);\n        \n        time = 41.73 + time;\n        \n        float an = 6.0 + 0.1*time;\n\n        vec3 ro = vec3(0.0,1.0,0.5) + 2.0*vec3(cos(an),0.0,sin(an));\n        vec3 ta = vec3(0.0,0.0,0.0);\n        mat3 ca = setCamera( ro, ta, 0.3 );\n        vec3 rd = normalize( ca * vec3(p,-1.5) );\n        \n        col += render( ro, rd, time );\n    }\n    col /= float(AA*AA);\n#else\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float time = iTime;// + (hash1(iRands.x+px.x+px.y*31U))*0.1*(1.0/24.0);\n    time = 41.73 + time;\n    float an = 6.0 + 0.1*time;\n\n    vec3 ro = vec3(0.0,1.0,0.5) + 2.0*vec3(cos(an),0.0,sin(an));\n    vec3 ta = vec3(0.0,0.0,0.0);\n    mat3 ca = setCamera( ro, ta, 0.3 );\n    vec3 rd = normalize( ca * vec3(p,-1.5) );\n\n    vec3 col = render( ro, rd, time );\n#endif    \n\tfragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI    3.141592653\nconst float[6] diagram = float[6](3.0, 2.0, 2.0, 3.0, 2.0, 5.0);\n\n// active mirrors, 1 for active, 0 for non-active. This determines the position\n// of the initial vertex hence the truncation type of the honeycomb.\nconst vec4 active_mirrors = vec4(1.0, 0.0, 0.0, 0.0);\n\n// normal vectors of the four mirrors\nmat4 M;\n\n// the initial vertex\nvec4 v0;\n\n// size of the vertex and segments\nconst float vradius = 0.035;\nconst float sradius = 0.01;\n\nfloat cvr = cos(vradius), svr = sin(vradius);\nfloat csr = cos(sradius), ssr = sin(sradius);\n\n// reflection about a plane with normal `n`\nfloat ref(inout vec4 p, in vec4 n)\n{\n    float k = min(0., dot(p, n));\n    p -= 2. * k * n;\n    return k;\n}\n\n\n\nfloat knightyDD(float ca, float sa, float r)\n{\n    float x = 1. - r * r;\n    float y = 2. - x;\n    return r - (2. * r * ca - x * sa) / (x * ca + 2. * r * sa + y);\n}\n\n\nvoid init()\n{\n    // Cartan matrix of the Coxeter group:\n    // ( -1  c01  c02  c03)\n    // (c01   -1  c12  c13)\n    // (c02  c12   -1  c23)\n    // (c03  c13  c23   -1)\n    // cij = -cos(PI / (Coxeter label bewteen i-th and j-th mirror))\n    float c01 = -cos(PI / diagram[0]);\n    float c02 = -cos(PI / diagram[1]);\n    float c03 = -cos(PI / diagram[2]);\n    float c12 = -cos(PI / diagram[3]);\n    float c13 = -cos(PI / diagram[4]);\n    float c23 = -cos(PI / diagram[5]);\n\n    vec4 A, B, C, D;\n    // find the reflection mirrors A, B, C, D.\n    // A can be always chosen as x-axis\n    A = vec4(1., 0., 0., 0.);\n    B = vec4(c01, sqrt(1. - c01*c01), 0., 0.);\n    C = vec4(c02, 0., 0., 0.);\n    C.y = (c12 - C.x * B.x) / B.y;\n    C.z = sqrt(abs(1. - dot(C.xy, C.xy))); // avoid rounding error in paracompact case\n    D = vec4(c03, 0., 0., 0.);\n    D.y = (c13 - D.x * B.x) / B.y;\n    D.z = (c23 - dot(D.xy, C.xy) ) / C.z;\n    D.w = -sqrt(abs(1. - dot(D.xyz, D.xyz))); // !important: - sign is used here\n\n    M = mat4(A, B, C, D);\n    v0 = normalize(active_mirrors * inverse(M));\n    \n}\n\n// fold a point p in 4d up to a given maximum of steps, return true if\n// we successfully transformed p into the fundamental domain else return false.\nbool fold(inout vec4 p)\n{\n    float k;\n    for(int i=0; i<20; i++)\n    {\n        k = 0.;\n        p.x = abs(p.x);\n        k += ref(p, M[1]);\n        k += ref(p, M[2]);\n        k += ref(p, M[3]);\n        // break as soon as we find it's already in the fundamental domain\n        if(k == 0.) return true;\n    }\n    return false;\n}\n\n// if distance between p and q is a, C is a circle with radius VR centered at q,\n// then the distance from p to C is a - VR, hence\n// cosh(a - VR) = cosh(a)cosh(VR) - sinh(a)sinh(VR)\n// sinh(a - VR) = sinh(a)cosh(VR) - cosh(a)sinh(VR)\nfloat dVertex(vec4 p, float r)\n{\n    float ca = dot(p, v0);\n    float sa = 0.5 * length(p-v0) * length(p+v0);\n    return knightyDD(ca * cvr + sa * svr, sa * cvr - ca * svr, r);\n}\nfloat dSegment(vec4 p, vec4 n, float r)\n{\n    float pn = dot(p, n);\n    float pv = dot(p, v0);\n    float nv = dot(n, v0);\n\n    float a = pv - pn*nv;\n    float b = pn - pv*nv;\n    vec4 pj = normalize(min(b, 0.) * n + a * v0);\n    float ca = dot(p, pj);\n    float sa = 0.5 * sqrt(1.-ca*ca);\n    return knightyDD(ca * csr + sa * ssr, sa * csr - ca * ssr, r);\n}\n\nfloat dSegments(vec4 p, float r, inout float index)\n{\n    float d = 1.0;\n    for(int i=0; i<4; i++)\n    {\n        float dseg = dSegment(p, M[i], r);\n        if (dseg < d)\n        {\n            d = dseg;\n            index = float(i);\n        }\n    }\n    return d;\n}\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"4cBSzD","date":"0","viewed":0,"name":"Fork Rouché - w neozhaolia 011","username":"neozhaoliang","description":"Rouché's theorem in complex analysis","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nWinding number theorem:\n\nA man is walking his dog along closed paths represented by f(z) and g(z),\nrespectively. If the man holds the leash tight enough to prevent the dog\nfrom touching the tree throughout their walk, they will circle the tree the\nsame number of times when they return to their initial positions.\n\nRouché's theorem:\n\nWhen f and g are analytic functions in a region that encloses the unit circle S\nand |f(z)| > |f(z) - g(z)| whenever z in S (here |f-g| is the length of the leash),\nthen f(S) and g(S) will circle the origin the same number of times, and this number\nequals the number of their zeros inside S.\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = (fragCoord - iResolution.xy*.5) / iResolution.y;\n    \n    vec2 p = uv * 9.;\n    p -= vec2(1.5, .5); // adjust the postion of the curves\n    vec2 O = vec2(0.5);\n\n    // Smoothing factor.\n    float sf = 8./iResolution.y;\n\n    // background color\n    vec3 col = vec3(1, .92, .75);\n    float hatch = doHatch(uv, iResolution.y);\n    col *= hatch*.2 + .8;\n    \n    vec2 e = vec2(.015, .03);\n    float le = length(e);\n\n    // curve width\n    float lw = .02;\n\n    float dc1 = dcurve(p, 0);\n    float dc2 = dcurve(p, 1);\n\n    float tA = mod(iTime*.2, 2.*PI);\n    float tB = max(0., tA + sin(iTime) * .1 - .1);\n    vec2 A0 = map1(0.), B0 = map2(0.);\n   \n    vec2 A = map1(tA);\n    vec2 B = map2(tB);\n    float dA = length(p - A) ;\n    float dB = length(p - B) ;\n\n    // dash grid lines\n    vec2 p1 = uv * 6.;\n    p1 -= floor(p1) + 0.5;\n    float bord = max(abs(p1.x), abs(p1.y))-0.49;\n    vec2 q1 = abs(mod(p1, 1./8.) - .5/8.);\n    float lines = (min(q1.x, q1.y) - .5/8./3.);\n    bord = min(bord, lines);\n    bord = step(0., bord);\n    \n    float dlink = dSegment(p, A, B);\n    // noisy background pattern\n    col *= fbm(p*48.)*.4 + .6;\n    // draw the grid lines\n    col = mix(col, vec3(0), bord*.8);\n\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*16., dc2))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*8., dc2 - lw*2.4));\n    col = mix(col, colorB, (1. - smoothstep(0., sf*4., dc2 - lw*1.6))*.8);\n\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*16., dc1))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*8., dc1 - lw*2.4));\n    col = mix(col, colorA, 1. - smoothstep(0., sf*4., dc1 - lw*1.6));\n\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*.7, dlink - 0.005))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*.7, dlink - .008));\n    col = mix(col, vec3(1, 1, .3), 1. - smoothstep(0., sf*.7, dlink));\n\n    lw *= 12.;\n\n    dA -= lw;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dA - 0.02))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dA - 0.04));\n\tcol = mix(col, colorA, 1. - smoothstep(0., sf, dA));\n    dA += .12;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dA - .03));\n\tcol = mix(col, vec3(1, .8, .6), 1. - smoothstep(0., sf, dA)); \n    dA += .08;\n\tcol = mix(col, vec3(0), (1. - smoothstep(0., sf, dA))); \n\n    dB -= lw;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dB - 0.02))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dB - 0.04));\n\tcol = mix(col, colorB, 1. - smoothstep(0., sf, dB));\n    dB += .12;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dB - .03));\n\tcol = mix(col, vec3(1, .8, .6), 1. - smoothstep(0., sf, dB)); \n    dB += .08;\n\tcol = mix(col, vec3(0), (1. - smoothstep(0., sf, dB)));\n    \n    float dA0 = length(p - A0);\n    dA0 -= lw * .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dA0 - 0.02))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dA0 - 0.04));\n\tcol = mix(col, colorA, 1. - smoothstep(0., sf, dA0));\n    dA0 += .06;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dA0));\n    \n    float dB0 = length(p - B0);\n    dB0 -= lw * .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dB0 - 0.02))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dB0 - 0.04));\n\tcol = mix(col, colorB, 1. - smoothstep(0., sf, dB0));\n    dB0 += .06;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dB0));\n \n    vec2 q = p - O;\n    float ci = length(q) - .7;\n    float sh = max(.75 - ci*4., 0.);\n    col = mix(col, vec3(0), (ss(sf*6., ci - .04))*.5);\n    col = mix(col, vec3(0), ss(sf, ci));\n    col = mix(col, vec3(1, .7, .4)*(ci + sh*sh*.1 + .5), ss(sf, ci + .03));\n    col = mix(col, col*1.6, ss(sf*4., ci + .15));\n   \tcol = mix(col, vec3(0), ss(sf, abs(ci + .1) - .01));   \n    col = mix(col, vec3(0), (ss(sf, length(q) - .18))*.5);\n    col = mix(col, vec3(0), ss(sf, abs(length(q) - .12) - .01));\n    col = mix(col, vec3(0), ss(sf, length(q) - .05));\n        \n    A -= O;\n    B -= O;\n    vec2 qA = rot2(atan(A.y, A.x-.5) -PI/2.) * q;\n    vec2 qB = rot2(atan(B.y, B.x)-PI/2.) * q;\n    float indA = distLine(qA - vec2(0, -.005), qA - vec2(0, .46)) - .01;\n    float indB = distLine(qB - vec2(0, -.005), qB - vec2(0, .3)) - .01;\n    \n    const float rad = .45;\n    const float aNum = 12.;\n    q = rot2(3.14159/aNum)*q;\n    float a = atan(q.y, q.x);\n    float ia = floor(a/6.283*aNum) + .5; // .5 to center cell.\n    ia = ia*6.283/aNum;\n    q = rot2(ia)*q;\n    q.x -= rad;\n        \n    // Markings.\n    float mark = sBox(q, vec2(.04, .022), 0.);\n    col = mix(col, vec3(.5), ss(sf, mark - .015));\n    col = mix(col, vec3(0), ss(sf, mark));\n        \n    // Indicator.        \n    col = mix(col, vec3(0), ss(sf, indA - .025));\n    col = mix(col, colorA, ss(sf, indA));\n    col = mix(col, vec3(0), ss(sf, indB - .025));\n    col = mix(col, colorB, ss(sf, indB));\n    \n    p -= vec2(-7.5, -3.);\n    p *= .8;\n    float ds1 = min(abs(length(p) - 1.), sqrt(dSegment(p, vec2(0), vec2(1, 0))));\n    col = mix(col, vec3(0.2), ss(sf, ds1 - 0.025));\n    float dr = distRoots(p);\n    col = mix(col, vec3(0.5, 0, 0), ss(sf, dr - .05));\n    col = mix(col, vec3(0.2), ss(sf, length(p - vec2(1, 0)) - .1));\n    \n    vec2 P = vec2(cos(tA), sin(tA));\n    float dP = length(p - P);\n    \n    dP -= lw * .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dP - 0.02))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dP - 0.04));\n\tcol = mix(col, colorA, 1. - smoothstep(0., sf, dP));\n\n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./16.)*1.05;\n\n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define NUM_SEGMENTS  100\n#define PI            3.141592653\n#define ss(a, b)      (1. - smoothstep(0., a, b))\n#define colorA   vec3(1, 0.2, 0.2)\n#define colorB   vec3(0.3, 1., .6)\n\n\nmat2 rot2(in float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n// complex multiplication\nvec2 cmul(vec2 p, vec2 q) {\n    return vec2(p.x*q.x-p.y*q.y, p.x*q.y+p.y*q.x);\n}\n\n// complex division\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y, -z.x * w.y + z.y * w.x) / dot(w, w);\n}\n\nvec2 transform(vec2 z, vec2 a) {\n    return cdiv(z - a, vec2(1, 0) - cmul(vec2(a.x, -a.y), z));\n}\n\nfloat n2D(vec2 p) {\n    const vec2 s = vec2(1, 113);\n    vec2 ip = floor(p); p -= ip;\n    vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);\n    p = p*p*(3. - 2.*p);\n    h = fract(sin(h)*43758.5453);\n    h.xy = mix(h.xy, h.zw, p.y);\n    return mix(h.x, h.y, p.x);\n}\n\nfloat fbm(vec2 p) {\n    return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\nfloat distLine(vec2 a, vec2 b) {\n    b = a - b;\n    float h = clamp(dot(a, b)/dot(b, b), 0., 1.);\n    return length(a - b*h);\n}\n\nfloat sBox(vec2 p, vec2 b, float r) {\n    vec2 d = abs(p) - b + r;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - r;\n}\n\nfloat dot2(in vec2 v) {\n    return dot(v, v);\n}\n\nfloat dSegment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return dot2(pa - ba*clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0));\n}\n\nvec2 map1(float t) {\n    const float s = 2.;\n    vec2 p = vec2(cos(t), sin(t));\n    vec2 z = transform(p, vec2(.5, .7));\n    z = cmul(z, transform(p, vec2(-.6, 0.5)));\n    z = cmul(z, transform(p, vec2(-0.4)));\n    z = cmul(z, p - vec2(s, s));\n    return z;\n}\n\nfloat distRoots(vec2 p) {\n    float d = length(p - vec2(.5, .7));\n    d = min(d, length(p - vec2(-0.6, 0.5)));\n    d = min(d, length(p - vec2(-0.4)));\n    return d;\n}\n\nvec2 map2(float t) {\n    return map1(t) + vec2(cos(t) * 1.6, sin(t) * 1.2);\n}\n\nfloat dcurve(vec2 p, int index) {\n    float h = 0.05;\n    float t = 0.0;\n\n    vec2  a = index == 0 ? map1(t) : map2(t);\n    float d = dot2(p - a);\n\n    for(int i = 0; i < NUM_SEGMENTS; i++) {\n        vec2  b = index == 0 ? map1(t) : map2(t);\n        d = min(d, dSegment(p, a, b));\n        t += clamp(0.01*length(a-p)/length(a-b), 0.01, 0.15);\n        a = b;\n    }\n    return sqrt(d);\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453);\n}\n\nfloat doHatch(vec2 p, float res) {\n    p *= res/16.;\n    float hatch;\n    float hRnd = hash21(floor(p*6.) + .73);\n    if(hRnd>.66) hatch = hRnd;\n    else if (hRnd > 0.33) hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.);\n    else hatch = clamp(sin((p.x + p.y)*3.14159*200.)*2. + .5, 0., 1.);\n    return hatch;\n}\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"DddfRH","date":"0","viewed":0,"name":"Fork Simple Dot neozhaolia 669","username":"neozhaoliang","description":"Using a grid and very basic keyframing concepts to create a simple repetitive dot animation.","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Simple Dot Animation\n    --------------------\n    \n    I love those cute geometric keyframe-based animations that pop up all \n    over the internet, often in gif form. They exist on Shadertoy too, and\n    some are amazing, but they're not what I'd call common.\n    \n    I guess one of the reasons is that pixelshaders can be restrictive,\n    since there's generally no random pixel access and calculations occur \n    on a per-pixel basis. Basically pixelshaders are not really designed for \n    motion tweening. However, it's all pretty doable. This particular \n    animation didn't require too much effort at all. There's also nothing\n    original about it. I've seen similar ones all over the place.\n    \n    I remember back in the day when democoders finally started giving people \n    a look at the code magic behind the productions and I was amazed at how \n    simple the key framing component was: Divide time up into time blocks,\n    each with their own start and end node markers. Determine which time  \n    block you're in, set some start time entities (like position, color, \n    orientation, etc.), set the corresponding end time entities, interpolate \n    all entities over the block's time period, then proceed to the next time \n    block.\n    \n    Anyway, for this particular animation sequence, I'm breaking time into \n    three blocks, then interpolating the object position between the first \n    two, then position and rotation on the last. The process is repeated ad \n    infinitum, and is all pretty straight forward. The details are below.\n    \n    The animation rendering itself was put together pretty quickly. This is\n    a 2D example, so speed wasn't really a consideration, but I did it in a\n    way that would allow me to extrude it at a later date. Therefore, there\n    are more than likely cleverer ways to render this, which I'll leave to \n    the code golfing crowd. :)\n    \n    \n    \n    Other examples:\n    \n    // Animated squares. 104 makes a lot of cool shaders. I've only \n    // skimmed the code, but I'm pretty sure this was created using \n    // similar principles.\n    90's Mirrored Squares - 104\n    https://www.shadertoy.com/view/3lBSzW\n    \n    \n    // You can't mention keyframes without referencing this one. \n    // Clever on so many levels.\n    [SH18] Human Document - reinder\n    https://www.shadertoy.com/view/XtcyW4\n\n*/\n\n// Showing the background grid pattern can spoil the illusion, but it\n// helps show how the animation is made.\n//#define GRID\n\n\n// Total running time, tmID, and time segment.\nfloat tmTotal, tmID, tmSeg;\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n \n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    //f = mod(f, 4.); // The would work with wrapped elements too.\n    \n    // The first line relates to ensuring that icosahedron vertex identification\n    // points snap to the exact same position in order to avoid hash inaccuracies.\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n \n\n// Animated dots.\nfloat dots(vec2 p, vec2 ip, vec2 sc){\n\n   \n    // Vertices: Clockwise from the bottom left.\n    mat4x2 v = mat4x2(vec2(-1), vec2(-1, 1), vec2(1), vec2(1, -1));\n    // Edges.\n    mat4x2 e = mat4x2(vec2(-1, 0), vec2(0, 1), vec2(1, 0), vec2(0, -1));\n    \n     // Fractional time segment: Same as fract(tmTotal).\n    float fTm = tmTotal - tmID; // Range: [0. 1].\n    \n    // Using smoothstep to smoothly interpolate the time period between\n    // zero and one. You could also use any number of easing functions, \n    // but I'm trying to keep things simple. The following roughly\n    // emulates a fast-in-the-middle motion... Not the technical term. :D\n    fTm = smoothstep(.25, .75, fTm);\n   \n    \n    // Object position and direction.\n    vec2 pos = vec2(0), dir;\n    \n    // Object (dot) size. \n    float sz = .2*min(sc.x, sc.y);\n    \n    // The resultant field distance.\n    float d;\n    \n    \n    if(tmSeg<.001){\n    \n        // Verticle direction.\n        dir = vec2(0, 1);\n \n        \n        vec2 di;\n        // Left wall semi-circle moving up from v[0].\n        di.x = length(p - (v[0] + dir*fTm)*sc/2.) - sz;\n        di.x = max(di.x, -(p.x + sc.x/2.));\n        \n        // Right wall semi-circle moving down from v[2].\n        di.y = length(p - (v[2] - dir*fTm)*sc/2.) - sz;\n        di.y = max(di.y, (p.x - sc.x/2.));\n            \n            \n        d = min(di.x, di.y);\n \n     \n    }\n    else if(tmSeg<1.001){\n    \n        // Horizontal direction.\n        dir = vec2(1, 0);\n         \n        // Splitting a semi circle running between \n        // the left and right edge midpoints and\n        // moving them in opposite directions.\n        \n        vec2 di;\n        // Moving left from e[2].\n        di.x = length(p - (e[2] - dir*fTm)*sc/2.) - sz;\n        di.x = max(di.x, p.y);\n        \n        // Moving right from e[0].\n        di.y = length(p - (e[0] + dir*fTm)*sc/2.) - sz;\n        di.y = max(di.y, -p.y);\n            \n            \n        d = min(di.x, di.y);\n \n  \n    }\n    else {\n    \n        // Instead of rendering four quarter circles in the center then moving\n        // them to the corners, we're saving some rendering (kind of), but splitting\n        // the cell into four smaller cells, then rendering diagonally from the\n        // appropriate vertex to the opposite diagonal one.\n\n\n         // We've effectively split each cell into fours, so based on the cell\n         // ID, we need to determine which clockwise quadrant we're in.\n         vec2 mIP = mod(ip, 2.);\n         int j = mIP.x==0.? mIP.y==0.? 0 : 1 : mIP.y==0.? 3 : 2;\n\n         // Starting vertex and ending vertex.\n         pos = mix(v[(j + 2)&3], v[j], fTm); \n         // The diagonal direction vector.\n         dir = (v[(j + 2)&3] - v[j]);\n\n         // Interpolating a half spin over time.\n         mat2 m2 = rot2(mix(0., 3.14159, fTm));\n\n         // Moving a square (the same size as the dot) to the dot's central\n         // point, rotating it about that point according to the rotational \n         // factor, then moving the edges to the dot center to create a rotating\n         // quarter circle... Yeah, transformations can get a little confusing,\n         // but they're not hard to learn, and you get better with practice.\n         vec2 q = abs(m2*(p - pos*sc/2.) + sign(dir)*sz) - sz;\n         float bound = max(q.x, q.y); // Bounding square.\n          \n         // The object position itself.\n         float di = length(p - pos*sc/2.) - sz*2.;\n         di = max(di, bound); // CSG with the bound to form a quarter circle.\n         d = di; // Setting as the distance.\n     \n    }\n    \n\n    \n    return d;\n}\n\nvoid mainImage( out vec4 o, in vec2 p){\n \n    // Coordinates: They're already in aspect correct form, so a \n    // simple translation and scaling is all that is necessary.\n    p = (p - iResolution.xy*.5)/iResolution.y; \n    \n    vec2 op = p;\n    \n    // Last minute subtle plane warping.\n    p *= .95 + length(p)*.1;\n    // Screen rotation. I liked this angle, but you could choose another.\n    p = rot2(3.14159/6.)*(p - vec2(2, 1)*iTime/60.);\n   \n    \n    \n    // Obviously, timing is important in keyframing. This breaks time into\n    // three equal segments lasting 1.5 seconds each.\n    tmTotal = iTime/1.5; \n    tmID = floor(tmTotal);\n    tmSeg = mod(tmID, 3.);\n    \n    // Grid scale: I've set it to squares, but rectangles work too. \n    vec2 sc0 = vec2(1)/6.;\n    vec2 sc = tmSeg<1.01? sc0 : sc0/2.;\n    \n    \n    // A gradient background.\n    vec3 c = mix(vec3(1, .7, .3), vec3(1, .8, .2), op.y + .5);\n    #ifdef GRID \n    float rnd = hash21(floor(p/sc0));\n    vec3 bCol = .5 + .45*cos(6.2831*rnd - op.y/2. + vec3(0, 1, 2));\n    float ch = mod(dot(floor(p/sc0*2.), vec2(1)), 2.)<.5? -.1 : .1;\n    c = mix(c, max(bCol + ch, 0.), .5);\n    #endif \n    \n    \n    // Grid distance and shadow.\n    float d = 1e5, dSh = 1e5;\n    \n    // Rendering the grid: Some of the objects move slightly outside the\n    // cell bounds and into the neighboring cells, which means you need\n    // to render the neighbors also. The following is a standard way to \n    // do that.\n    for(int i = 0; i<4; i++){\n        \n        // Neighbor offset.\n        vec2 offs = vec2(i&1, i/2) - .5;\n\n        // Grid partitioning -- ID and local coordinates.\n        vec2 q = p;\n        vec2 iq = floor(q/sc + offs);\n        q -= (iq + .5)*sc;\n\n        // The dot field and shadow field.\n        d = min(d, dots(q, iq, sc));\n        dSh = min(dSh, dots(q - rot2(3.14159/6.)*vec2(-1)*.015, iq, sc));\n    }\n    \n    // Smoothing factor.\n    float sf = 1.5/iResolution.y;\n    \n    \n    // Shadow, edge and face color.\n    vec3 svC = mix(c*.2, vec3(.14), .75);\n    c = mix(c, vec3(0), (1. - smoothstep(0., sf*2., dSh - .007))*.5);\n    c = mix(c, vec3(0), 1. - smoothstep(0., sf, d - .007));\n    c = mix(c, vec3(.14)*0. + svC, 1. - smoothstep(0., sf, d));\n\n    // Rough gamma correction.\n    o = vec4(sqrt(max(c, 0.)), 1);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"sdscDf","date":"0","viewed":0,"name":"Fork Tiny Raytr neozhaolia 373","username":"neozhaoliang","description":"Port of Dmitry Sokolov's Tiny Raytracer: [url]https://github.com/ssloy/tinyraytracer[/url]\n\nMouse: rotate viewpoint.\nup/down: zoom\n","likes":0,"published":0,"flags":48,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//\n// Tiny Ray Tracer. Orginal C++ version by Dmitry Sokolov:\n// https://github.com/ssloy/tinyraytracer\n// Original License: WTFPL (https://en.wikipedia.org/wiki/WTFPL)\n//\n// GLSL version by Matthew Arcus, 2019:\n// I've tried to keep the logic the same as the original, some changes:\n//\n// Use a stack instead of recursion\n// Centre scene on origin to make view rotation easier\n// Mouse movement & rotation\n// Some fixes for single precision\n// Skip tracing eg. for opaque or non-reflective materials\n//\n////////////////////////////////////////////////////////////////////////////////\n\n#define PI 3.1415926536\n\nstruct Light {\n  vec3 position;\n  float intensity;\n};\n\nstruct Material {\n  float refractive_index;\n  vec4 albedo;\n  vec3 diffuse_color;\n  float specular_exponent;\n};\n\nstruct Sphere {\n  vec3 center;\n  float radius;\n  int material;\n};\n\nMaterial materials[] =\n  Material[](Material(1.0, vec4(0.5,  0.3, 0.1, 0.0), vec3(0.5, 0.5, 0.3),   50.0),\n             Material(1.5, vec4(0.0,  0.5, 0.1, 0.8), vec3(0.6, 0.7, 0.8),  125.0),\n             Material(1.0, vec4(0.9,  0.1, 0.0, 0.0), vec3(0.3, 0.1, 0.1),   10.0),\n             Material(1.0, vec4(0.0, 10.0, 0.8, 0.0), vec3(1.0, 1.0, 1.0), 1425.0),\n             Material(1.0, vec4(1,0,0,0),             vec3(.3, .2, .1),       1.0),\n             Material(1.0, vec4(1,0,0,0),             vec3(.3),               1.0));\n\nconst int IVORY = 0, GLASS = 1, RED_RUBBER = 2, MIRROR = 3, BOARD0 = 4, BOARD1 = 5;\n\nSphere spheres[] =\n  Sphere[](Sphere(vec3(-3,    0,   4), 2.0,      IVORY),\n           Sphere(vec3(-1.0, -1.5, 8), 2.0,      GLASS),\n           Sphere(vec3( 1.5, -0.5, 2), 3.0, RED_RUBBER),\n           Sphere(vec3( 7,    5,   2), 4.0,     MIRROR));\n\nLight lights[] =\n  Light[](Light(vec3(-20, 20, 40), 1.5),\n          Light(vec3( 30, 50, -5), 1.8),\n          Light(vec3( 30, 20, 50), 1.7));\n\nconst int NSPHERES = spheres.length();\nconst int NLIGHTS = lights.length();\n\nbool ray_intersect(Sphere s, vec3 orig, vec3 dir, out float t0) {\n  vec3 center = s.center;\n  float radius = s.radius;\n  vec3 L = center - orig;\n  float tca = dot(L,dir);\n  float d2 = dot(L,L) - tca*tca;\n  float disc = radius*radius - d2;\n  if (disc < 0.0) return false;\n  float thc = sqrt(disc);\n  // t0*t1 = tca^2 - thc^2 = tca^2 - disc\n  float t1, K = tca*tca - disc;\n  if (tca < 0.0) {\n    t0 = tca - thc;\n    t1 = K/t0;\n  } else {\n    t1 = tca + thc;\n    t0 = K/t1;\n  }\n  if (t0 < 0.0) t0 = t1;\n  if (t0 < 0.0) return false;\n  return true;\n}\n\n// Original refract function.\nvec3 refraction(vec3 I, vec3 N, float refractive_index) { // Snell's law\n  float cosi = -max(-1.0, min(1.0, dot(I,N)));\n  float etai = 1.0, etat = refractive_index;\n  vec3 n = N;\n  // if the ray is inside the object, swap the indices and\n  // invert the normal to get the correct result  \n  if (cosi < 0.0) {\n    cosi = -cosi;\n    float tmp = etai; etai = etat; etat = tmp; // swap\n    n = -N;\n  }\n  float eta = etai / etat;\n  float k = 1.0 - eta*eta*(1.0 - cosi*cosi);\n  return k < 0.0 ? vec3(0) : I*eta + n*(eta * cosi - sqrt(k));\n}\n\nbool scene_intersect(vec3 orig, vec3 dir, out vec3 hit, out vec3 N, out int material) {\n  float maxdist = 1e8;\n  float dist = maxdist;\n  for (int i=0; i < NSPHERES; i++) {\n    float dist_i;\n    if (ray_intersect(spheres[i],orig, dir, dist_i) && dist_i < dist) {\n      dist = dist_i;\n      hit = orig + dir*dist_i;\n      N = normalize(hit - spheres[i].center);\n      material = spheres[i].material;\n    }\n  }\n\n  if (abs(dir.y) > 1e-3)  {\n    float d = -(orig.y+4.0)/dir.y; // the checkerboard plane has equation y = -4\n    vec3 pt = orig + dir*d;\n    if (d > 0.0 && abs(pt.x) < 10.0 && abs(pt.z) < 10.0 && d < dist) {\n      dist = d;\n      hit = pt;\n      N = vec3(0,1,0);\n      int parity = (int(floor(0.5*hit.x)) + int(floor(0.5*hit.z))) & 1;\n      material = parity == 0 ? BOARD0 : BOARD1;\n    }\n  }\n  return dist < maxdist;\n}\n\nstruct StackEntry {\n  ivec3 iparams; // type, depth, material\n  vec3 value, dir, point, N;\n};\n\nvec3 background(vec3 dir) {\n#if 0\n  return vec3(0.05, 0.4, 0.5); // background color\n#elif 1\nreturn pow(texture(iChannel3,dir).xyz,vec3(2.2));\n#else\n  dir = abs(dir);\n  dir /= dot(dir,vec3(1));\n  return pow(texture(iChannel2,dir.xy).xyz,vec3(2.2));\n#endif\n}\n\nconst int MAXDEPTH = 4;\nStackEntry stack[MAXDEPTH];\nint stackptr = 0;\n\nvec3 cast_ray(vec3 orig, vec3 dir) {\n  int depth = 0, state = 0, materialindex;\n  vec3 value,point, N,reflect_color,refract_color;\n  while(true) {\n    if (state == 0) {\n      if (!scene_intersect(orig, dir, point, N, materialindex)) {\n        value = background(dir);\n        state = 1;\n      } else if (depth == MAXDEPTH) {\n        reflect_color = refract_color = background(dir);\n        state = 2;\n      } else {\n        stack[stackptr++] = StackEntry(ivec3(0,depth,materialindex),vec3(0),dir,point,N);\n        if (materials[materialindex].albedo[2] == 0.0) {\n          // Go directly to unwind if no reflection\n          value = vec3(0);\n          state = 1;\n        } else {\n          vec3 reflect_dir = normalize(reflect(dir, N));\n          // offset the original point to avoid occlusion by the object itself    \n          vec3 reflect_orig = dot(reflect_dir,N) < 0.0 ? point - N*1e-3 : point + N*1e-3;\n          orig = reflect_orig;\n          dir = reflect_dir;\n          depth++;\n          // and loop\n        }\n      }\n    }\n    if (state == 1) {\n      if (stackptr == 0) return value;\n      int type = stack[stackptr-1].iparams[0];\n      depth = stack[stackptr-1].iparams[1];\n      materialindex = stack[stackptr-1].iparams[2];\n      dir = stack[stackptr-1].dir;\n      point = stack[stackptr-1].point;\n      N = stack[stackptr-1].N;\n      Material material = materials[materialindex];\n      if (type == 0) {\n        // Don't actually pop the stack, but modify the top item\n        stack[stackptr-1].value = value;\n        stack[stackptr-1].iparams[0] = 1; //type = 1\n        if (material.albedo[3] == 0.0) {\n          value = vec3(0);\n        } else {\n          vec3 refract_dir = normalize(refraction(dir, N, material.refractive_index));\n          vec3 refract_orig = dot(refract_dir,N) < 0.0 ? point - N*1e-3 : point + N*1e-3;\n          orig = refract_orig;\n          dir = refract_dir;\n          depth++;\n          state = 0;\n        }\n      } else {\n        reflect_color = stack[stackptr-1].value;\n        refract_color = value;\n        stackptr--;\n        state = 2;\n      }\n    }\n    if (state == 2) {\n      Material material = materials[materialindex];\n      float diffuse_light_intensity = 0.0;\n      float specular_light_intensity = 0.0;\n      for (int i=0; i<NLIGHTS; i++) {\n        vec3 light_dir       = normalize(lights[i].position - point);\n        float light_distance = length(lights[i].position - point);\n\n        // checking if the point lies in the shadow of the lights[i]\n        vec3 shadow_orig = dot(light_dir,N) < 0.0 ? point - N*1e-3 : point + N*1e-3;\n        vec3 shadow_pt, shadow_N;\n        int tmpmaterial;\n        if (scene_intersect(shadow_orig, light_dir, shadow_pt, shadow_N, tmpmaterial) &&\n            length(shadow_pt-shadow_orig) < light_distance)\n          continue;\n                            \n        diffuse_light_intensity  += lights[i].intensity * max(0.0, dot(light_dir,N));\n        specular_light_intensity += pow(max(0.0, -dot(reflect(-light_dir, N),dir)),\n                                        material.specular_exponent)*lights[i].intensity;\n      }\n      value = material.diffuse_color * diffuse_light_intensity * material.albedo[0] +\n                                              vec3(1,1,1)*specular_light_intensity * material.albedo[1] +\n                                              reflect_color*material.albedo[2] +\n                                              refract_color*material.albedo[3];\n      state = 1;\n    }\n  }\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  p.zx = rotate(p.zx,-iTime * 0.2);\n  return p;\n}\n\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nint keycount(int key) {\n  return int(texelFetch(iChannel1, ivec2(0,key),0).x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float fov = PI/3.0;\n  vec2 xy = (fragCoord + 0.5) - 0.5*iResolution.xy;\n  float z = -iResolution.y/(2.0*tan(0.5*fov));\n  vec3 dir = normalize(transform(vec3(xy,z)));\n  float camera = 18.0;\n  camera *= 0.1*float(10+keycount(KEY_DOWN)-keycount(KEY_UP));\n  vec3 origin = transform(vec3(0,0,camera));\n  vec3 color = cast_ray(origin, dir);\n  float maxc = max(color[0], max(color[1], color[2]));\n  if (maxc > 1.0) color = color/maxc;\n  color = pow(color,vec3(0.4545));\n  fragColor = vec4(color,1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n#if __VERSION__ < 300\n    t = vec4(0);\n#else\n    \n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0 ) {\n        t = vec4(0);\n    } else {\n        t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n        \n#endif           \n}\n","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"mtSGzG","date":"0","viewed":0,"name":"Fork Volcano la neozhaolia 497","username":"neozhaoliang","description":" Draws the 3d ball packing of the hyperbolic group","likes":0,"published":0,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 tex = texelFetch(iChannel0, ivec2(gl_FragCoord.xy), 0);\n\tvec3 color = tex.rgb/tex.a;\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI                 3.1415926535\n#define Iterations         50","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 orbitTrap;\n\nstruct Ball {\n    vec4 data;\n    bool isplane;\n    bool invert;\n};\n\nconst Ball[5] balls = Ball[5] (\n    Ball(vec4(0.12132034, 0.50730594, 2.3483438, 1.014611872354576), false, false),\n    Ball(vec4(0, 1.73205081, 0, 2.449489742783177), false, true),\n    Ball(vec4(0.8660254037844386,  -0.5, 0.0, 0.8660254037844386),  true, false),\n    Ball(vec4(-0.8660254037844386, -0.5, 0.0, 0.8660254037844386), true, false),\n    Ball(vec4(0, 1, 0, 0), true, false)\n);\n\n\nfloat distanceToBall(vec3 p, Ball B) {\n    if (B.isplane)\n        return dot(vec4(p, 1), B.data);\n    else\n        return length(p - B.data.xyz) - B.data.w;\n}\n\nbool try_reflect(inout vec3 p,\n                 in Ball B,\n                 inout float scale,\n                 inout vec4 orb) {\n    if (B.isplane) {\n        float k = dot(vec4(p, 1), B.data);\n        if (k >= 0.)\n            return true;\n        p -= 2.0 * k  * B.data.xyz;\n        return false;\n    }\n    else {\n        vec3 cen = B.data.xyz;\n        float r = B.data.w;\n        vec3 q = p - cen;\n        float d2 = dot(q, q);\n        float k = (r * r) / d2;\n        if ( (k < 1.0 && B.invert) || (k > 1. && !B.invert) )\n            return true;\n\n        orb = min(orb, vec4(abs(p), d2));\n        scale *= k;\n        p = k * q + cen;\n        return false;\n    }\n}\n\nfloat map(inout vec3 p, inout float scale, inout vec4 orb) {\n    orb = vec4(10000.0);\n    for (int i = 0; i < Iterations; i++) {\n        bool cond = true;\n        for (int k = 0; k < 5; k++) {\n            cond = cond && try_reflect(p, balls[k], scale, orb);\n        }\n        if (cond)\n            break;\n    }\n    return abs(p.z);\n}\n\n\nfloat DE(vec3 p) {\n    float DEfactor = 1.;\n    float d = map(p, DEfactor, orbitTrap);\n    return 0.25 * d / DEfactor;\n}\n\n\nvec3 getNormal(vec3 pos, float normalDistance) {\n\tnormalDistance = max(normalDistance * 0.5, 1e-5);\n\tvec3 e = vec3(0.0, normalDistance, 0.);\n\tvec3 n = vec3(\n        DE(pos + e.yxx) - DE(pos - e.yxx),\n\t\tDE(pos + e.xyx) - DE(pos - e.xyx),\n\t\tDE(pos + e.xxy) - DE(pos - e.xxy));\n\t\n    n = normalize(n);\n\treturn n == n ? n : vec3(0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tfragColor += vec4(uv, 1., 1);\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"sl2GWd","date":"0","viewed":0,"name":"Fork [TDF2018]T neozhaolia 228","username":"neozhaoliang","description":"glsl compo for tokyo demo fest 2018, 3rd place\n\nNice to be there, thanks tdf!","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by EvilRyu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n#define PI 3.1415926535\n#define FAR 30.0\n\nvec2 hash22(vec2 p)\n{\n    float f=p.x+p.y*37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\n\nfloat hash13(vec3 p)\n{\n    p=fract(p * vec3(5.3983, 5.4472, 6.9371));\n    p += dot(p.yzx, p.xyz + vec3(21.5351, 14.3137, 15.3219));\n    return fract(p.x * p.y * p.z * 95.4337);\n}\n\nmat2 rot(float t)\n{\n    float c=cos(t);\n    float s=sin(t);\n    return mat2(c,-s,s,c);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h=clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\n\nvec2 line(vec3 pos, vec3 a, vec3 b)\n{\n    vec3 pa=pos-a;\n    vec3 ba=b-a;\n   \n    float h=clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    \n    return vec2(length(pa-h*ba), h);\n}\n\nfloat line(vec3 pos, vec3 a, vec3 b, float r)\n{\n    vec3 pa=pos-a;\n    vec3 ba=b-a;\n   \n    float h=clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    \n    return length(pa-h*ba)-r;\n}\n\nfloat line(vec2 pos, vec2 a, vec2 b, float r)\n{\n    vec2 pa=pos-a;\n    vec2 ba=b-a;\n   \n    float h=clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    \n    return length(pa-h*ba)-r;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n  vec2 q=vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sphere(vec3 p)\n{\n    return length(p)-0.5;\n}\n\nfloat cylinder(vec3 p, vec2 h)\n{\n  vec2 d=abs(vec2(length(p.xz),p.y))-h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat box(vec3 p, vec3 b)\n{\n  vec3 d=abs(p)-b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nfloat prism(vec3 p, vec2 h)\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat ellipsoid(vec3 p, vec3 r)\n{\n    float k0=length(p/r);\n    float k1=length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat rbox(vec3 p, vec3 b, float r)\n{\n  vec3 d=abs(p)-b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nvec3 swing(vec3 p)\n{\n    p.xy*=rot(0.15*sin(1.5*iTime));\n\n    p+=vec3(0.5*sin(1.5*iTime),0.,-0.3+2.*iTime);\n    return p;\n}\n\n// for bounding sphere\nvec3 inverse_swing(vec3 p)\n{\n    p.xy*=rot(-0.15*sin(1.5*iTime));\n\n    p-=vec3(0.5*sin(1.5*iTime),0.,-0.3+2.*iTime);\n    return p;\n}\n\n#define HEAD 1\n#define BODY 2\n#define NOSE 3\n#define HAND 4\n#define BELL 5\n// machine\n#define BASE 6\n#define CONTROL 7\n#define CONTROL_FRONT 8\n#define FUEL 9\n#define HANDLE1 10\n#define HANDLE2 11\n#define SOFA 12\n#define LIGHT 13\n\nint obj_id, machine_id;\n\nvoid body(vec3 p, inout float d0)\n{\n    float d1=line(p+vec3(0.,.6,0.),vec3(0),vec3(0.,0.2,0.),0.32);\n    if(d1<d0) obj_id=BODY;\n    d0=smin(d0,d1,0.03);\n}\n\nvoid brace(vec3 p, inout float d0)\n{\n    float d2=torus(p+vec3(0.,.4,0.),vec2(0.31,0.03));\n    if(d2<d0) {obj_id=NOSE;d0=d2;}\n}\n\nvoid legs(vec3 p, inout float d0)\n{\n    vec3 q=vec3(abs(p.x)-.18,p.y,p.z);\n    float d3=line(q+vec3(0,.95,0.),vec3(0),vec3(0.,0.2,0.),0.15);\n    d0=smin(d0,d3,0.13);\n    \n    // feet\n    q.x=abs(p.x)-0.2;\n    float d4=torus(q+vec3(0.,1.05,0.),vec2(0.08,0.09));\n    if(d4<d0) {obj_id=HAND;d0=d4;}\n}\n\nvoid arms(vec3 p, inout float d0)\n{\n    vec2 d5=line(p+vec3(-.28,0.5,0.),vec3(0),vec3(0.27,0.25,0.));\n    d5.x=d5.x-0.1*(1.-.6*d5.y);\n    if(d5.x<d0) obj_id=BODY;\n    d0=smin(d0,d5.x,.02);\n    d5.x=length(p+vec3(-.6,0.2,0.))-0.09;\n    if(d5.x<d0) {obj_id=HAND;d0=d5.x;}\n    \n    d5=line(p+vec3(.28,0.5,0.),vec3(0),.9*vec3(-0.27,-0.25,0.));\n    d5.x=d5.x-0.1*(1.-.6*d5.y);\n    if(d5.x<d0){obj_id=BODY;d0=d5.x;}\n    d5.x=length(p+vec3(.55,0.75,0.))-0.08;\n    if(d5.x<d0) {obj_id=HAND;d0=d5.x;}\n}\n\nvoid nose_tail(vec3 p, inout float d0)\n{\n    float d6=length(p+vec3(0.,-0.15,0.5))-0.05;\n    if(d6<d0) {obj_id=NOSE;d0=d6;}\n    \n    // tail\n    float d7=line(p+vec3(0.,0.77,-0.1),vec3(0),vec3(0.,-0.1,0.25),0.01);\n    float dt=length(p+vec3(0.,0.87,-0.35))-0.04;\n    if(dt<d0) {obj_id=NOSE;d0=dt;}\n    if(d7<d0) {obj_id=BODY;d0=d7;}\n\n}\n\nvoid bag(vec3 p, inout float d0)\n{\n    vec3 q=p;\n    q.yz*=rot(0.14);\n    float d8=cylinder(vec3(q.x,q.z+.16,abs(q.y+0.55)), vec2(0.1,.19))-0.05;\n    float d9=box(q+vec3(0.,.1,.0),vec3(1.,.44,1.));\n    d8=smax(-d9,d8,.02);\n    d0=smin(d0,d8,0.01);\n    \n    // bell\n    float d10=length(p+vec3(0.,0.46,0.36))-0.06;\n    float d11=torus(p+vec3(0.,0.46,0.36),vec2(0.06,0.009));\n    d10=min(d10,d11);\n    if(d10<d0) {obj_id=BELL;d0=d10;}\n}\n\nvoid mouth(vec3 p, inout float d0)\n{\n    vec3 q=p;\n    \n    p.yz*=rot(0.2);\n    float d12=cylinder(vec3(p.x,p.z+.6,abs(p.y-0.11)), vec2(0.25,.19))-0.05;\n    float d13=box(p+vec3(0.,-1.11,.0),vec3(1.,1.,1.));\n    d12=smax(-d13,d12,.06);\n    if(-d12>d0) obj_id=NOSE;\n    d0=smax(-d12,d0,.03); \n    float dt=length(vec3(abs(p.x)-.05,p.y+.18,p.z+.2))-0.2;\n    if(dt<d0) {obj_id=NOSE;d0=dt;}\n    \n    \n    q.x=abs(q.x);\n    \n    vec2 d5=line(q+vec3(0.,-0.03,0.41),vec3(0),vec3(0.27,-0.01,-0.02));\n    //if(d14<d0) obj_id=NOSE;\n    d5.x-=0.07+0.01*(1.-d5.y);\n    d0=smin(d0,d5.x,0.01);\n}\n\nfloat doraemon(vec3 p)\n{\n    p=swing(p);\n    \n    obj_id=HEAD;\n    float d0=length(p)-0.5;\n    \n    body(p,d0);\n    brace(p,d0);\n    legs(p,d0);\n    arms(p,d0);\n    nose_tail(p,d0);\n    bag(p,d0);\n    mouth(p,d0);\n    return d0;\n}\n\nvoid main_control(vec3 p, inout float d0)\n{\n    float d2=box(p+vec3(0.,-0.4,.9), vec3(.87,.4, .2));    \n    if(d2<d0){machine_id=CONTROL;d0=d2;}\n    float d3=prism(vec3(p.z+1.,p.y-0.24,p.x), vec2(0.4,0.87));\n    if(d3<d0){machine_id=CONTROL_FRONT;d0=d3;}\n    \n    float d4=box(p+vec3(0.,-0.8,.85),vec3(0.8,0.2,0.2));\n    d0=max(-d4,d0);\n    \n    float d5=cylinder(p+vec3(-0.5,-0.7,.8),vec2(0.015,0.2));\n    if(d5<d0){machine_id=CONTROL;d0=d5;}\n    \n    float d6=length(p+vec3(-0.5,-0.88,.8))-0.05;\n    if(d6<d0) {machine_id=HANDLE1; d0=d6;}\n}\n\nvoid lamp(vec3 p, inout float d0)\n{\n    float d7=cylinder(p+vec3(-1.17,-1.,.8),vec2(0.025,1.));\n    float d8=line(p+vec3(-1.17,-2.,.8),vec3(0.),vec3(-0.35,0.35,0.),0.025);\n    d8=min(d7,d8);\n    if(d8<d0){machine_id=CONTROL;d0=d8;}\n    \n    vec3 q=p;\n    q.xy*=rot(0.8);\n    float d9=ellipsoid(q+vec3(1.32,-2.22,.8),vec3(0.25,0.07,0.2));\n    if(d9<d0){machine_id=LIGHT;d0=d9;}\n}\n\nvoid handles(vec3 p, inout float d0)\n{\n    float d=cylinder(vec3(p.x+1.35,p.z-1.2, p.y-.1),vec2(0.3,.25));\n    d=max(d,-box(p+vec3(1.65,-.2,-1.2),vec3(0.3,0.4,0.3)));\n    d=max(d,-box(p+vec3(1.25,.4,-1.2),vec3(0.3,0.4,0.3)));\n    if(d<d0){machine_id=CONTROL;d0=d;}\n    \n    p=p+vec3(1.15,-.3,-1.1);\n    \n    for(int i=0;i<3;++i)\n    {\n        d=line(p,vec3(0),vec3(0.1,0.2,0.),0.01);\n        d0=min(d0,d);\n        d=length(p+vec3(-0.1,-0.2,0.))-0.04;\n        if(d<d0){machine_id=HANDLE2;d0=d;}\n        p.z-=0.11;\n    }\n}\n\nvoid sofa(vec3 p, inout float d0)\n{\n    float d12=rbox(p+vec3(0.,-.5,-.8),vec3(0.6,0.5,0.04), 0.05);\n    float d13=rbox(p+vec3(0.,-.15,-.4),vec3(0.6,0.15,0.3), 0.05);\n    d13=smin(d12,d13,0.2);  \n    if(d13<d0){machine_id=SOFA;d0=d13;}\n}\n\nfloat timemachine(vec3 p)\n{\n    p=swing(p+vec3(0,0,0));p.y+=1.15;\n    \n    machine_id=BASE;\n    \n    float d0=box(p+vec3(0.,0.02,0.), vec3(1.5,0.06,1.8));\n    \n    main_control(p,d0);\n    lamp(p,d0);\n    handles(p,d0);\n    sofa(p,d0);\n    \n    p.x=abs(p.x)-1.17;\n    float d1=line(p+vec3(0.,-0.1,1.45),vec3(0),vec3(0.,0.,1.5),0.2);\n    if(d1<d0) {machine_id=FUEL; d0=d1;}\n    return d0;\n}\n\n\nvec2 fold(vec2 p, float a)\n{\n    p.x=abs(p.x);\n    vec2 n = vec2(cos(a),sin(a));\n    for(int i = 0; i < 3; ++i)\n    {\n        p -= 2.*min(0.,dot(p,n))*n;\n        n = normalize(n-vec2(1.,0.));\n    }\n    return p;\n}\n\nvec3 path(float p)\n{\n    return vec3(sin(p*0.05)*cos(p*0.025)*18., 0.,0.);\n}\n\n/// from Klem's Olympian: https://www.shadertoy.com/view/XltyRf\nvec3 tunnel(vec3 rd, float pos, float speed) \n{\n    const float max_r = 5.;\n    vec3 col;//=vec3(1.);\n    for (float r=1.0;r<max_r+float(min(0,iFrame));r+=1.0) \n    {\n        // calculate where the ray intersects several fixed radius cylinders\n        // using cylindrical coordinates\n        // (phi, r, z)\n        // phi=arctan(rd.y/rd.x)\n        // r=r\n        // length(rd.xy) / r = rd.z / z ==> z=rd.z*r/length(rd.xy)\n        float phi=atan(rd.x, rd.y);\n        float z=rd.z*r/length(rd.xy);\n        if(r<1.5)col=vec3(abs(z)*.005);\n        // adjust the uv acoording to cylinder size and position\n        vec2 uv=vec2(phi*r, pos+z);\n        uv.x+=1.717*hash13(vec3(floor(uv),r))*r;\n        \n        vec2 cell_center=floor(uv)+0.5;\n        cell_center+=hash22(cell_center+vec2(0.,r))-.5;\n\n        vec2 size=vec2(.01);\n        size.y+=speed/r;\n        size.y/=sin(atan(r/abs(z)));\n        \n        //float d=(length((uv-cell_center)/size)-1.)*size.y;\n        //col+=vec3(1,.9,.6)*smoothstep(0.105,-0.105,d)/(.5*r*r+.3*z*z);\n\n        \n        float redshift=0.01+speed/r;\n        cell_center.y-=redshift;\n        for (int i=0; i<3+min(0,iFrame); i++) \n        {\n            cell_center.y+=redshift;\n            \n            // draw stars\n            vec2 p=uv-cell_center;\n            float d=(length(p/size)-1.0)*size.y;\n            float dist=(r*r+z*z);\n            col[i]+=smoothstep(0.02, -0.02, d)/dist;\n        }\n        \n    }\n    return 3.*col;\n}\n\n\nfloat get_ao(vec3 p, vec3 n)\n{\n    float r=0.0, w=1.0, d;\n    for(float i=1.; i<5.0+1.1+float(min(0,iFrame)); i++)\n    {\n        d=i/5.0;\n        r+=w*(d-min(doraemon(p+n*d),timemachine(p+n*d)));\n        w*=0.5;\n    }\n    return 1.0-clamp(r,0.0,1.0);\n}\n\n\n\nvec3 material_doraemon(vec3 rd, vec3 pos, vec3 nor)\n{\n    vec3 col=vec3(0);\n    float d; \n    pos=swing(pos);\n    \n    if(obj_id==HEAD)\n    {\n        col=vec3(0.,0.5,1.0); \n        if(pos.z<0.&&length(vec2(pos.x*0.9,pos.y+0.05))<0.38)col=vec3(0.9);\n        \n        // eyes\n        if(pos.z<0.)\n        {\n            vec2 p=vec2(abs(pos.x)-0.1,pos.y*.7-0.2);\n            float r=length(p.xy);\n            col*=pow(1.-smoothstep(0.08,0.09,r)*smoothstep(0.1,0.09,r),1.);\n            if(r<0.085) col=vec3(1.);\n            p=vec2(abs(pos.x)-0.06, pos.y-0.26);\n            r=length(p);\n            p=vec2(abs(pos.x)-0.06, pos.y-0.26);\n            float r1=length(p);\n            col*=pow(1.-smoothstep(0.0,0.025,r)*smoothstep(0.03,0.025,r),7.0);\n            \n            // beards\n            if(pos.y>0.&&pos.y<0.11)\n            col*=smoothstep(0.,0.01,abs(pos.x));\n            col*=smoothstep(0.,0.01, line(vec2(abs(pos.x)-0.16,pos.y), vec2(0.,0.14),vec2(0.14,0.18),0.001));\n            col*=smoothstep(0.,0.01, line(vec2(abs(pos.x)-0.16,pos.y+0.04), vec2(0.,0.14),vec2(0.15,0.15),0.001));\n            col*=smoothstep(0.,0.01, line(vec2(abs(pos.x)-0.16,pos.y+0.08), vec2(0.,0.14),vec2(0.15,0.13),0.001));\n        }\n    }\n    else if(obj_id==BODY)\n    {\n        col=vec3(0.,0.5,1.0); \n        if(pos.z<0.&&length(vec2(pos.x,pos.y+.6))<.22)col=vec3(0.9);\n    }\n    else if(obj_id==NOSE)\n        col=vec3(.4,0.,0.);\n    else if(obj_id==BELL)\n        col=vec3(1.2,0.7,0.);\n    else if(obj_id==HAND)\n        col=vec3(.9);\n    else if(obj_id==BASE)\n        col=vec3(0.05,0.1,0.2);\n    else if(obj_id==CONTROL)\n        col=vec3(.9,.7,.5);\n    else if(obj_id==CONTROL_FRONT)\n    {\n        col=vec3(.9,.7,.5);\n        // pos.y -1.x -> -0.7\n        col=mix(vec3(1.,0.2,0.),col,pow(smoothstep(0.,0.04, line(vec2(pos.x,pos.y), vec2(-0.5,-0.8),vec2(0.5,-0.8),0.001)),40.));\n        col=mix(vec3(1.,0.2,0.),col,pow(smoothstep(0.,0.04, line(vec2(pos.x,pos.y), vec2(-0.5,-0.9),vec2(0.5,-0.9),0.001)),40.));\n        col=mix(vec3(1.,0.2,0.),col,pow(smoothstep(0.,0.04, line(vec2(pos.x,pos.y), vec2(-0.5,-1.),vec2(0.5,-1.),0.001)),40.));\n        \n    }\n    else if(obj_id==HANDLE1)\n        col=vec3(0.,0.1,0.3);\n    else if(obj_id==FUEL)\n        col=vec3(0.01,0.04,0.1);\n    else if(obj_id==HANDLE2||obj_id==SOFA)\n        col=vec3(0.1,0.,0.04);\n    else if(obj_id==LIGHT)\n    {\n        // pixel light\n        vec2 frp=abs(fract(pos.xz*10.));\n        frp=pow(frp, vec2(4.));\n        float edge=max(0.,1.-(frp.x+frp.y));\n        vec2 flp=floor(pos.xz*10.);\n        float k=dot(sin(flp+cos(flp.yx*2.+iTime*2.)),vec2(.5));\n        col=nor.y<0.? 10.*edge*vec3(pow(k,.7)*2., 4.*pow(k, 1.5), pow(k,2.)) : vec3(.9,.7,.5);\n    }\n    return col;\n}\n\nvec3 get_doraemon_normal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*doraemon(p+0.001*e);\n    }\n    return normalize(n);\n}\n\nvec3 get_timemachine_normal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*timemachine(p+0.001*e);\n    }\n    return normalize(n);\n}\n\nvec3 lighting_doraemon(vec3 rd, vec3 pos, float ps,float hitinfo, float t)\n{\n    vec3 l1dir=normalize(vec3(1.0,2.,-1.));\n    vec3 l1col=vec3(1.,0.8,0.8);\n    \n    vec3 e=vec3(0.5*ps,0.0,0.0); \n    vec3 nor;\n\n    if(hitinfo<.9)\n        nor=get_doraemon_normal(pos);\n    else\n        nor=get_timemachine_normal(pos);\n    \n    if(timemachine(pos)<doraemon(pos))obj_id=machine_id;\n    if(t>FAR&&obj_id==LIGHT)obj_id=CONTROL; // avoid weird artifacts, should find a bettwe way\n    \n    vec3 mate=material_doraemon(rd,pos,nor);\n    float ao=get_ao(pos,nor);\n    float dif=max(0.0,dot(nor,l1dir));\n    float bac=max(0.0,dot(nor,-l1dir));\n    float spe=max(0.0, pow(clamp(dot(l1dir, reflect(rd, nor)), 0.0, 1.0), 32.0));\n\n    vec3 lin=6.0*dif*l1col*ao;\n    lin+=1.*bac*l1col;\n    lin+=3.*spe*vec3(1.);\n    return lin*0.2*mate;\n}\n\nfloat pixel_size;\n\nvec4 intersect_doraemon(vec3 ro, vec3 rd, out vec3 hitinfo)\n{\n    hitinfo=vec3(0.,0.,1.);\n    float d_first=100.0, t_first=0.0;\n    float old_d=1000.0;\n    float d_max=1000.0, t_max=0.0;\n    float t=1.0;\n    float d=100.0;\n    float hitwho=0.,old_hitwho=0.;\n    \n    for(int i=0; i<64+min(0,iFrame); ++i) \n    {\n        hitwho=0.;\n        // splitting them is just for not crashing my windows laptop....\n        d=doraemon(ro+rd*t);\n        float d1=timemachine(ro+rd*t);\n        if(d1<d){hitwho=1.;d=d1;}\n\n        \n        if(d_first == 100.0)  // the first edge\n        {\n            hitinfo.x=hitwho;\n            if(d>old_d) \n            {\n                if(old_d<pixel_size * (t-old_d))\n                {\n                    d_first=old_d;\n                    t_first=t-old_d;\n                    hitinfo.x=old_hitwho;\n                }\n            }\n            old_d=d;\n            old_hitwho=hitwho;\n        }\n        if(d<d_max) // save the max occluder\n        { \n            t_max=t; \n            d_max=d;\n            hitinfo.y=hitwho;\n        }  \n        \n        if(d<0.00001 || t>FAR)\n            break;\n        t += d;\n        hitinfo.z=t;\n    }\n    return vec4(t_max, d_max, t_first, d_first);\n}\n\nfloat bounding_sphere(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n    vec3 p=sph.xyz;\n    p=inverse_swing(p);\n    float t=-1.0;\n    vec3  ce=ro-p;\n    float b=dot(rd, ce);\n    float c=dot(ce, ce)-sph.w*sph.w;\n    float h=b*b - c;\n    if(h>0.0)\n    {\n        t=-b-sqrt(h);\n    }\n    \n    return t;\n}\n\nvec3 render_doraemon(vec3 ro, vec3 rd, vec3 bg)\n{\n    float t=bounding_sphere(ro,rd,vec4(0.,-0.35,0.,2.5));\n    if(t<=0. || t>1000.)\n        return bg;\n    \n    // first hit, max hit, t\n    vec3 hitinfo;\n    vec4 res=intersect_doraemon(ro,rd,hitinfo);\n    \n    float d_max, t_max, d_first, t_first;\n    t_max=res.x;\n    d_max=res.y;\n    t_first=res.z;\n    d_first=res.w;\n    vec3 nor,pos;\n    \n    vec3 col=bg;\n    \n    if(d_max < pixel_size*t_max) \n    {\n        pos=ro+rd*t_max;\n        col=mix(lighting_doraemon(rd, pos, pixel_size*t_max,hitinfo.y, hitinfo.z), col, \n                  clamp(d_max/(pixel_size * t_max), 0.0, 1.0));\n    }\n    float ratio=0.0;\n\n    if(d_first==100.0 || t_max==t_first)\n    {\n        t_first=t_max;\n        d_first=d_max;\n        ratio=0.5;\n    }\n    \n    pos=ro+rd*t_first;\n    col=mix(lighting_doraemon(rd, pos, pixel_size*t_first,hitinfo.x, hitinfo.z),\n              col, clamp(ratio+d_first/(pixel_size*t_first), 0.0, 1.0));\n    \n    return col;\n}\n\n\n#define CITY_MENGER 1\n#define CITY_ROAD 2\n\n#define VOXEL_GAP 0.1\n\nconst mat3 ma=mat3(0.6,0.,0.8,\n                   0.,1.,0.,\n                   -0.8,0.,0.6);\n\nvec4 city(vec3 p)\n{\n    p.y-=0.3;\n    obj_id=CITY_MENGER;\n    vec2 flp=floor(p.xz);\n    vec2 frp=fract(p.xz);\n    \n    frp-=0.5;\n    \n    vec2 rand;\n    rand=hash22(flp);\n    float height=0.4+rand.x*rand.x*1.7;\n    float d0=box(vec3(frp.x,p.y,frp.y),vec3(0.1,height,.4));   \n    \n    vec4 res=vec4(d0, 1.0, 0.0, 0.0);\n    \n    // menger spone from iq\n    // larger value gives higher density of rooms\n    // I like 1.1, 1.2, 1.7\n    float s=1.+.2*rand.y*(1.-step(1.6,height)); \n    vec3 q=p;\n    for(int m=0; m<4+min(0,iFrame); m++)\n    {      \n        p.y+=rand.y;\n        vec3 a=mod(p*s, 2.0)-1.0;\n        s*=3.;\n        vec3 r=abs(1. - 3.0*abs(a));\n        float da=max(r.x,r.y);\n        float db=r.y;//max(r.y,r.z);\n        float dc=max(r.z,r.x);\n        float c=(min(da,min(db,dc))-1.)/s;\n\n        if(c>d0)\n        {\n          d0=c;\n          res=vec4(d0, min(res.y,.2*da*db*dc), (1.0+float(m))/4.0, 0. );\n        }\n    }\n   \n    if(q.y<res.x){obj_id=CITY_ROAD;res.x=q.y;}\n    return res;\n}\n\n\nvec3 get_city_normal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*city(p+0.001*e).x;\n    }\n    return normalize(n);\n}\n\n#define CITY_ITER 250\n#define CITY_FAR 50.\n\nvec4 intersect_city_voxel(vec3 ro, vec3 rd)\n{\n    vec4 h=vec4(100.),res=vec4(-1);\n    float t = 0.05;\n    vec3 p=vec3(0.0);\n\n    for (int i=0; i<CITY_ITER+min(0,iFrame); i++)\n    {\n        if(h.x<0.0001+0.000125*t||t>CITY_FAR)\n        {\n            continue;\n        }\n        p=ro+rd*t;\n\n        h=city(p);\n\n        // 2d voxel marching the city blocks, as the boundaries are not continues\n        \n        float dx=-fract(p.x);\n        if (rd.x>0.) \n            dx=fract(-p.x);\n        \n        float dz=-fract(p.z);\n        if (rd.z>0.)\n            dz=fract(-p.z);\n        \n        float nearest=min(fract(dx/rd.x), fract(dz/rd.z))+VOXEL_GAP;\n        nearest=max(VOXEL_GAP, nearest);\n        \n        t+= min(h.x, nearest); \n        res=vec4(t,h.yzw);\n        \n    }\n    return res;\n}\n\nvec3 material_city(vec3 p, float night)\n{\n    vec3 col=vec3(0.4,0.6,1.0)*0.15;\n    vec4 res=city(p);\n    if(obj_id==CITY_MENGER)\n    {\n        res.z=1.-res.z;\n        col=(1.2*(1.-night)+0.8)* vec3(.5+res.z*res.z,.3+pow(res.z, 3.), res.z*res.z*0.9);\n        //col=vec3(res.z);  \n\n        if(night>0.5)\n        {\n            if(res.z<.25)\n                col=50.*vec3(1.2,0.3,0.);\n            else if(res.z<0.75)\n                col*=6.;\n        }\n        \n    }\n    else\n    {\n        p.z-=iTime*2.;\n        col+=(1.-smoothstep(0.01,0.025,abs(abs(p.x)-.25)))*vec3(1);\n        col=mix(col,vec3(1.2,0.7,0.),floor(fract(p.z)+.5)*(1.-smoothstep(0.01,0.02,abs(p.x)-0.001)));//*vec3(1);\n        // fake shadow\n        col*=(0.06+smoothstep(0.4,0.6,abs(abs(p.x+0.13)-0.7))); \n        col*=(0.06+smoothstep(0.4,0.6,-p.x+1.47))*vec3(1); \n    }\n    return col;\n}\n\nvec3 city_bg(vec3 ro, vec3 rd, float night)\n{\n    const vec3 moon_col=vec3(0.8,1.,1.);\n    const vec3 moon_dir=vec3(0,0,-1.);    \n    vec3 col;\n    \n    col=vec3(1.)-moon_col*smoothstep(-.1,0.,rd.y)*smoothstep(0.33,0.37,pow(max(dot(moon_dir, rd), 0.0), 32.0));\n\n    if(night>0.)\n        col=vec3(0.)+vec3(0.3,0.,0.)*smoothstep(-.1,0.,rd.y)*smoothstep(0.33,0.37,pow(max(dot(moon_dir, rd), 0.0), 32.0));\n    \n    return col;\n}\n\n\nfloat curve(in vec3 p, in float w)\n{\n    vec2 e=vec2(-1., 1.)*w;\n    \n    float t1=city(p+e.yxx).x, t2=city(p+e.xxy).x;\n    float t3=city(p+e.xyx).x, t4=city(p+e.yyy).x;\n    \n    return 0.0125/(w*w)*(t1+t2+t3+t4-4.*city(p).x);\n}\n\nvec4 render_city(vec3 ro, vec3 rd, float night)\n{\n    vec4 res=intersect_city_voxel(ro,rd);\n    vec3 col=city_bg(ro,rd,night);\n\n    if(res.x<CITY_FAR)\n    {\n       // if(city(ro+res.x*rd).x>0.005/res.x)\n         //   res.x=res.w;\n        vec3 pos=ro+res.x*rd;\n        vec3 nor=get_city_normal(pos);\n        vec3 l1dir=normalize(vec3(1.0,2.,-1.));\n        vec3 l1col=vec3(1.2,0.8,0.5);\n        \n        float ao=res.y*res.y;\n        if(obj_id==CITY_ROAD)\n            ao=1.;\n\n        vec3 mate=material_city(pos,night);\n        float dif=max(0.0,dot(nor,l1dir));\n        float bac=max(0.0,dot(nor,-l1dir));\n        float sky=0.5+0.5*nor.y;\n        float spe=pow(max(dot(reflect(-l1dir, nor), -rd), 0.0), 16.0);\n        float crv=clamp(1.-abs(curve(pos,0.0015)),0.,1.);\n\n        vec3 lin=4.0*(1.-night)*dif*l1col*ao;\n        lin+=3.*sky*vec3(0.1,0.2,0.5)*ao;\n        lin+=1.*bac*l1col*ao;\n        lin+=1.*spe*vec3(1.);\n        col=lin*crv*0.2*mate;\n        \n        vec3 skycol=vec3(1.-night);\n        if(rd.z<0.)\n            col=mix(col,vec3(.15,0,0),1.-exp(-0.005*res.x*res.x));\n        else col=mix(col,skycol,1.-exp(-0.001*res.x*res.x));\n       //col=vec3(lin);\n    }\n    return vec4(col,res.x);\n}\n\n\nvec3 tonemap(vec3 x) \n{\n    const float a=2.51;\n    const float b=0.03;\n    const float c=2.43;\n    const float d=0.59;\n    const float e=0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q=fragCoord/iResolution.xy;\n    vec2 p=q*2.-1.;\n    p.x*=iResolution.x/iResolution.y;\n    pixel_size=1.0/(iResolution.y);\n   \n     // debugging camera\n    //float x_rot=-iMouse.x/iResolution.x*PI*2.0;\n    //float y_rot=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;\n    //vec3 ro=vec3(0.,0.9,-2.*iTime)+vec3(cos(y_rot)*cos(x_rot),0.,cos(y_rot)*sin(x_rot))*10.;\n    //vec3 ta=vec3(0.,0.,-2.*iTime);\n   \n    float time=mod(iTime,40.);\n    vec3 ro,ro2;\n    if(time < 20.)\n    {\n        ro=vec3(0.,.9,-9.);\n        ro2=ro;\n        \n        if(time>10.)\n        {\n            ro.xz*=rot(-(time-10.)*0.07);\n        }\n    }\n    else\n    {\n        ro=vec3(0.,.9,9.);\n        ro2=ro;\n    }\n\n    ro.z-=2.*iTime;\n    ro2.z-=2.*iTime;\n    vec3 ta=vec3(0.,0.,-2.*iTime);\n    \n    \n    vec3 f=normalize(ta-ro);\n    vec3 r=normalize(cross(f,vec3(0.,1.,0.)));\n    vec3 u=normalize(cross(r,f));\n    \n    vec3 rd=normalize(r*p.x + u*p.y + f*2.3);\n    \n    vec3 timetunnel=tunnel(rd,-iTime*8.,.05);\n    vec3 menger=render_city(ro2,rd, 1.0-step(0.0,sin(0.05*(iTime+40.-14.)))).xyz;\n    \n    vec3 bg=mix(timetunnel,menger,1.-smoothstep(0.,1.,sin(0.1*(iTime+40.))));\n    vec3 col=render_doraemon(ro,rd,bg);\n    \n    // post processing\n    col=tonemap(col);\n    col=pow(clamp(col,0.,1.0),vec3(0.45));\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"NstSDs","date":"1634176278","viewed":5388,"name":"Hyperbolic Group Limit Set","username":"neozhaoliang","description":"old version of https://www.shadertoy.com/view/WdGBz3","likes":160,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n=============================================\n\nLimit set of rank 4 hyperbolic Coxeter groups\n\n                                by Zhao Liang\n=============================================\n\nThis program shows the limit sets of rank 4 hyperbolic Coxeter groups.\n\nSome math stuff:\n\nLet G be a hyperbolic Coxeter group and x a point inside the hyperbolic\nunit ball, the orbit S_x = { gx, g \\in G } has accumulation points\n(under Euclidean metric) only on the boundary of the space. We call the\naccumulation points of S_x the limit set of the group, it can be proved that\nthis set is independent of the way x is chosen, and it's the smallest\nclosed subset of the boundary that is invariant under the action of the group.\n\nThe Coxeter-Dynkin diagram of a rank 4 Coxeter group of string type has the form\n\n   A --- B --- C --- D\n      p     q     r\n\nHere A, B, D can be chosen as ususal Euclidean planes, C is a sphere orthongonal\nto the unit ball. This is taken from mla's notation, and as far as I know this\nhas long been used by users on fractalforums. (fragmentarium)\n\nIn this animation these points are colored in \"brass metal\".\n\n==========\n!important\n==========\n\nThe limit set is a closed set with no interior points, to show them we have\nto use an approximate procedure: we simply try to reflect a point p on the\nboundary to the fundamental domain up to a maximum steps, once failed then we\nthink p belongs to the limit set.\n\n**So the number MAX_REFLECTIONS is an important param**, if it's set too high\nthen little limit set will be shown, or if it's not high enough then\nthe boundary of the set will look too coarse, so beware of this.\n\nAs always, you can do whatever you want to this work.\n\nUpdate: thanks @mla for helping fix some bugs!\n\nYou can try more patterns like\n(3, 7, 3), (4, 6, 3), (4, 4, 5), (5, 4, 4), (7, 3, 4), ..., etc.\n5, 4, 4) is my favorite!\nSet PQR below to see the result.\nFor large PQRs the limit set will become too small to be visible, you need to adjust\nMAX_REFLECTIONS and tweak with the function chooseColor to get appealling results.\n*/\n\n#define inf        -1.\n\nconst vec3 PQR = vec3(3, 3, 7);\n\n// --------------------------\n// some global settings\n\n#define MAX_TRACE_STEPS  100\n#define MIN_TRACE_DIST   0.1\n#define MAX_TRACE_DIST   100.0\n#define PRECISION        0.0001\n#define AA               2\n#define MAX_REFLECTIONS  500\n#define PI               3.141592653\n\n// another pattern\n//#define CHECKER1  vec3(0.196078, 0.33, 0.82)\n//#define CHECKER2  vec3(0.75, 0.35, 0.196078)\n\n/*\n#define CHECKER1  vec3(0.82, 0.196078, 0.33)\n#define CHECKER2  vec3(0.196078, 0.35, 0.92)\n#define MATERIAL  vec3(0.71, 0.65, 0.26)\n#define FUNDCOL   vec3(0., 0.82, .33)\n*/\n\n// Shane's color scheme\n#define CHECKER1  vec3(0., 0., 0.05)\n#define CHECKER2  vec3(0.2)\n#define MATERIAL  vec3(10, 0.3, 0.2)\n#define FUNDCOL   vec3(.3, 1, 8)\n\n\n// used to highlight the limit set\n#define LighteningFactor 8.\n// --------------------------\n\nvec3 A, B, D;\nvec4 C;\nfloat orb;\n\nfloat dihedral(float x) { return x == inf ? 1. : cos(PI / x); }\n\n// minimal distance to the four mirrors\nfloat distABCD(vec3 p)\n{\n    float dA = abs(dot(p, A));\n    float dB = abs(dot(p, B));\n    float dD = abs(dot(p, D));\n    float dC = abs(length(p - C.xyz) - C.w);\n    return min(dA, min(dB, min(dC, dD)));\n}\n\n// try to reflect across a plane with normal n and update the counter\nbool try_reflect(inout vec3 p, vec3 n, inout int count)\n{\n    float k = dot(p, n);\n    // if we are already inside, do nothing and return true\n    if (k >= 0.0)\n    \treturn true;\n\n    p -= 2.0 * k * n;\n    count += 1;\n    return false;\n}\n\n// similar with above, instead this is a sphere inversion\nbool try_reflect(inout vec3 p, vec4 sphere, inout int count)\n{\n    vec3 cen = sphere.xyz;\n    float r = sphere.w;\n    vec3 q = p - cen;\n    float d2 = dot(q, q);\n    if (d2 == 0.0)\n    \treturn true;\n    float k = (r * r) / d2;\n    if (k < 1.0)\n    \treturn true;\n    p = k * q + cen;\n    count += 1;\n    orb *= k;\n    return false;\n}\n\n// sdf of the unit sphere at origin\nfloat sdSphere(vec3 p, float radius) { return length(p) - 1.0; }\n\n// sdf of the plane y=-1\nfloat sdPlane(vec3 p, float offset) { return p.y + 1.0; }\n\n// inverse stereo-graphic projection, from a point on plane y=-1 to\n// the unit ball centered at the origin\nvec3 planeToSphere(vec2 p)\n{\n    float pp = dot(p, p);\n    return vec3(2.0 * p, pp - 1.0).xzy / (1.0 + pp);\n}\n\n// iteratively reflect a point on the unit sphere into the fundamental cell\n// and update the counter along the way\nbool iterateSpherePoint(inout vec3 p, inout int count)\n{\n    bool inA, inB, inC, inD;\n    for(int iter=0; iter<MAX_REFLECTIONS; iter++)\n    {\n        inA = try_reflect(p, A, count);\n        inB = try_reflect(p, B, count);\n        inC = try_reflect(p, C, count);\n        inD = try_reflect(p, D, count);\n        p =  normalize(p);  // avoid floating error accumulation\n        if (inA && inB && inC && inD)\n            return true;\n    }\n    return false;\n}\n\n// colors for fundamental domain, checker pattern and limit set.\nvec3 chooseColor(bool found, int count)\n{\n    vec3 col;\n    if (found)\n    {\n        if (count == 0) return FUNDCOL;\n        else if (count >= 300) col = MATERIAL;\n        else\n            col = (count % 2 == 0) ? CHECKER1 : CHECKER2;\n\n    }\n    else\n        col = MATERIAL;\n\n    float t =  float(count) / float(MAX_REFLECTIONS);\n    col = mix(MATERIAL*LighteningFactor, col, 1. - t * smoothstep(0., 1., log(orb) / 32.));\n    return col;\n}\n\n// 2d rotation\nvec2 rot2d(vec2 p, float a) { return p * cos(a) + vec2(-p.y, p.x) * sin(a); }\n\nvec2 map(vec3 p)\n{\n    float d1 = sdSphere(p, 1.0);\n    float d2 = sdPlane(p, -1.0);\n    float id = (d1 < d2) ? 0.: 1.;\n    return vec2(min(d1, d2), id);\n}\n\n// standard scene normal\nvec3 getNormal(vec3 p)\n{\n    const vec2 e = vec2(0.001, 0.);\n    return normalize(\n        vec3(\n            map(p + e.xyy).x - map(p  - e.xyy).x,\n            map(p + e.yxy).x - map(p  - e.yxy).x,\n            map(p + e.yyx).x - map(p  - e.yyx).x\n            )\n        );\n}\n\n// get the signed distance to an object and object id\nvec2 raymarch(in vec3 ro, in vec3 rd)\n{\n    float t = MIN_TRACE_DIST;\n    vec2 h;\n    for(int i=0; i<MAX_TRACE_STEPS; i++)\n    {\n        h = map(ro + t * rd);\n        if (h.x < PRECISION * t)\n            return vec2(t, h.y);\n\n        if (t > MAX_TRACE_DIST)\n            break;\n\n        t += h.x;\n    }\n    return vec2(-1.0);\n}\n\nfloat calcOcclusion(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.15 * float(i) / 4.0;\n        float d = map(p + h * n).x;\n        occ += (h - d) * sca;\n        sca *= 0.75;\n    }\n    return clamp(1.0 - occ, 0.0, 1.0);\n}\n\n\nfloat softShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k) {\n    float res = 1.0;\n    float t = tmin;\n    for (int i = 0; i < 12; i++) {\n        float h = map(ro + rd * t).x;\n        res = min(res, k * h / t);\n        t += clamp(h, 0.01, 0.2);\n        if (h < 0.0001 || t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n\nvec3 getColor(vec3 ro, vec3 rd, vec3 pos, vec3 nor, vec3 lp, vec3 basecol)\n{\n    vec3 col = vec3(0.0);\n    vec3 ld = lp - pos;\n    float lDist = max(length(ld), .001);\n    ld /= lDist;\n    float ao = calcOcclusion(pos, nor);\n    float sh = softShadow(pos+0.001*nor, ld, 0.02, lDist, 32.);\n    float diff = clamp(dot(nor, ld), 0., 1.);\n    float atten = 2. / (1. + lDist * lDist * .01);\n\n    float spec = pow(max( dot( reflect(-ld, nor), -rd ), 0.0 ), 32.);\n    float fres = clamp(1.0 + dot(rd, nor), 0.0, 1.0);\n\n    col += basecol * diff;\n    col += basecol * vec3(1., 0.8, 0.3) * spec * 4.;\n    col += basecol * vec3(0.8) * fres * fres * 2.;\n    col *= ao * atten * sh;\n    col += basecol * clamp(0.8 + 0.2 * nor.y, 0., 1.) * 0.5;\n    return col;\n}\n\nmat3 sphMat(float theta, float phi)\n{\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(cy, -sy * -sx, -sy * cx,\n                0,   cx,  sx,\n                sy,  cy * -sx, cy * cx);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 finalcol = vec3(0.);\n    int count = 0;\n    vec2 m = vec2(0.0, 1.0) + iMouse.xy / iResolution.xy;\n    float rx = m.y * PI;\n    float ry = -m.x * 2. * PI;\n    mat3 mouRot = sphMat(rx, ry);\n\n// ---------------------------------\n// initialize the mirrors\n\n    float P = PQR.x, Q = PQR.y, R = PQR.z;\n    float cp = dihedral(P), sp = sqrt(1. - cp*cp);\n    float cq = dihedral(Q);\n    float cr = dihedral(R);\n    A = vec3(0,  0,   1);\n    B = vec3(0, sp, -cp);\n    D = vec3(1,  0,   0);\n\n    float r = 1.0 / cr;\n    float k = r * cq / sp;\n    vec3 cen = vec3(1, k, 0);\n    C = vec4(cen, r) / sqrt(dot(cen, cen) - r * r);\n\n// -------------------------------------\n// view setttings\n\n    vec3 camera = vec3(3., 3.2, -3.);\n    vec3 lp = vec3(0.5, 3.0, -0.8); //light position\n    camera.xz = rot2d(camera.xz, iTime*0.3);\n    vec3 lookat  = vec3(0., -0.5, 0.);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 forward = normalize(lookat - camera);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n\n// -------------------------------------\n// antialiasing loop\n\n    for(int ii=0; ii<AA; ii++)\n    {\n        for(int jj=0; jj<AA; jj++)\n        {\n            vec2 o = vec2(float(ii), float(jj)) / float(AA);\n            vec2 uv = (2. * fragCoord + o - iResolution.xy) / iResolution.y;\n            vec3 rd = normalize(uv.x * right + uv.y * up + 3.0 * forward);\n            orb = 1.0;\n            // ---------------------------------\n            // hit the scene and get distance, object id\n\n            vec2 res = raymarch(camera, rd);\n            float t = res.x;\n            float id = res.y;\n            vec3 pos = camera + t * rd;\n\n            bool found;\n            float edist;\n            vec3 col;\n            // the sphere is hit\n            if (id == 0.)\n            {\n                vec3 nor = pos;\n                vec3 q = pos * mouRot;\n                found = iterateSpherePoint(q, count);\n                edist = distABCD(q);\n                vec3 basecol = chooseColor(found, count);\n\n                col = getColor(camera, rd, pos, nor, lp, basecol);\n            }\n            // the plane is hit\n            else if (id == 1.)\n            {\n                vec3 nor = vec3(0., 1., 0.);\n                vec3 q = planeToSphere(pos.xz);\n                q = q * mouRot;\n                found = iterateSpherePoint(q, count);\n                edist = distABCD(q);\n                vec3 basecol = chooseColor(found, count);\n                col = getColor(camera, rd, pos, nor, lp, basecol) * .9;\n            }\n            // draw the arcs\n            col = mix(col, vec3(0.), (1.0 - smoothstep(0., 0.005, edist))*0.85);\n            col = mix(col, vec3(0.), 1.0 - exp(-0.01*t*t));\n            finalcol += col;\n        }\n    }\n    finalcol /= (float(AA) * float(AA));\n\n// ------------------------------------\n// a little post-processing\n\n    finalcol = mix(finalcol, 1. - exp(-finalcol), .35);\n    fragColor = vec4(sqrt(max(finalcol, 0.0)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"7dcXDB","date":"1633863097","viewed":871,"name":"Hyperbolic tilings: intro","username":"neozhaoliang","description":"This is similar to Shane's work https://www.shadertoy.com/view/WlBczG but uses a different approach.","likes":24,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    A mimic of shane's work at https://www.shadertoy.com/view/WlBczG.\n    \n    Show the basic procedure to draw a 2d hyperbolic Poincare tiling.\n    \n    Also can draw paracompact and noncompact tilings (with ideal and hyperideal vertices)\n\n*/\n// show the three reflection mirrors\n//#define debug_mirrors\n\n// comment out this to see the initial pattern\n#define enableMouseInversion\n\n// change to Klein model\n//#define KleinModel\n\n// set inf = 1.0 for paracompact tiling\n// set inf > 1.0 for noncompact tiling\n#define inf       1.0\n\n#define PI\t\t  3.14159265\n#define TAU\t      6.28318531\n#define MAX_ITER  30\n\n\n// the smaller this value, the larger the black area\n#define BlackRegionSize   0.065\n\n// the first entry in PQR must be finite, other two entries can be either finite or infinite\n// for example (3, inf 4), (3, 4, inf), etc\nconst vec3 PQR = vec3(3, 3, 7);\n\n\n// reflection mirrors\nvec2 A, B;\nvec3 C;\n\n// two vertices of the fundamental triangle, the 3rd one is the origin\nvec2 v0, m0;\n\n// count the total number of reflections\nfloat count;\n\n// compute cos(PI / x) using Vinberg's convention for inf.\nfloat dihedral(float x) { return x == inf ? inf : cos(PI / x); }\n\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\nvoid init() {\n\n    float cAB = dihedral(PQR.x);\n    float sAB = sqrt(1. - cAB*cAB);\n    \n\tA = vec2(1, 0);\n    B = vec2(-cAB, sAB);\n    \n    float cAC = dihedral(PQR.y);\n    float cBC = dihedral(PQR.z);\n    \n    float k1 = cAC;\n    float k2 = (cBC + cAB*cAC) / sAB;\n    float r = 1. / sqrt(k1*k1 + k2*k2 - 1.);\n    \n    C = vec3(k1, k2, 1.)*r;\n    \n    if (r*r >= C.x*C.x)\n        v0 = vec2(0., C.y - sqrt(r*r - C.x*C.x));\n    else\n        v0 = vec2(0, 1);\n        \n    vec2 n = vec2(-B.y, B.x);\n    float b = dot(C.xy, n);\n    float c = dot(C.xy, C.xy) - r*r;\n    float k = -1.0;\n    \n    if (b*b >= c)\n        k = b + sqrt(b*b-c);\n    \n    m0 = k*n;\n}\n\n\nbool try_reflect(inout vec2 p, vec2 mirror, inout float count) {\n    float k = dot(p, mirror);\n    if (k >= 0.)\n        return true;\n    p -= 2. * k  * mirror;\n    count += 1.;\n    return false;\n}\n\n\nbool try_reflect(inout vec2 p, vec3 sphere, inout float count) {\n    vec2 cen = sphere.xy;\n    float r = sphere.z;\n    float d = length(p - cen) - r;\n    if (d >= 0.)\n        return true;\n    p -= cen;\n    p *= r * r/ dot(p, p);\n    p += cen;\n    count += 1.;\n    return false;\n}\n\n\nvoid fold(inout vec2 p, inout float count) {\n    count = 0.;\n    for (int k = 0; k < MAX_ITER; k++) {\n        try_reflect(p, A, count);\n        try_reflect(p, B, count);\n        try_reflect(p, C, count);\n    }\n}\n\n\nfloat sBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew) {\n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n\nvec2 mouseInversion(vec2 p) {\n    vec2 m = vec2((2.*iMouse.xy - iResolution.xy)/iResolution.y);\n    if(length(m) < 1e-3) m += 1e-3; \n    if(abs(m.x)>.98*.7071 || abs(m.y)>.98*.7071) m *= .98;\n\n    float k = 1./dot(m, m);\n    vec2 invCtr = k*m;\n    float t = (k - 1.)/dot(p -invCtr, p - invCtr);\n    p = t*p + (1. - t)*invCtr;\n    p.x = -p.x;\n    return p;    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    uv *= 1.05;\n    vec2 p = uv;\n    \n#ifdef enableMouseInversion\n    p = mouseInversion(p);\n    p = rot2(iTime/16.)*p;\n#endif\n\n    init();   \n    \n    if(length(p)> 1.)\n        p /= dot(p, p);\n        \n#ifdef KleinModel\n    p = p / (1. + sqrt(1. - dot(p, p)));\n#endif\n  \n    fold(p, count);\n    \n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    ln = min(ln, lBox(p, vec2(0), v0, .007));    \n    ln = min(ln, lBox(p, vec2(0), m0, .007));\n    ln = min(ln, length(p-C.xy) - C.z - 0.007);\n\n    ln2 = min(ln2, lBox(p, vec2(0), m0, .007));\n    pnt = min(pnt, length(p - v0)); \n    pnt = min(pnt, length(p - m0)); \n    \n    float ssf = (2. - smoothstep(0., .25, abs(length(uv) - 1.) - .25));\n    float sf = 2./iResolution.y*ssf;\n        \n    vec3 oCol = .55 + .45*cos(count*TAU / 8. + vec3(0, 1, 2));\n    float pat = smoothstep(0., .25, abs(fract(ln2*50. - .2) - .5)*2. -.2);\n   \n    float sh = clamp(.65 + ln/v0.y*4., 0., 1.);\n    \n    vec3 col = min(oCol*(pat*.2 + .9)*sh, 1.);\n    \n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - BlackRegionSize)));\n\n    pnt -= .032;\n    pnt = min(pnt, length(p) - .032);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnt));\n    col = mix(col, vec3(1, .8, .3), 1. - smoothstep(0., sf, pnt + .02));\n    \n    vec3 bg = vec3(1, .2, .4);\n    bg *= .7*(mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .5)*.5 + .5);\n    pat = smoothstep(0., .25, abs(fract((uv.x - uv.y)*43. - .25) - .5)*2. -.5);\n    bg *= max(1. - length(uv)*.5, 0.)*(pat*.2 + .9);\n    \n    float cir = length(uv);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*10., abs(cir - 1.) - .05))*.7);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., abs(cir - 1.) - .05)));\n    col = mix(col, vec3(.9) + bg, (1. - smoothstep(0., sf, abs(cir - 1.) - .03)));\n    col = mix(col, col*max(1. - length(uv)*.5, 0.), (1. - smoothstep(0., sf, -cir + 1.05)));\n    col = mix(col, bg, (1. - smoothstep(0., sf, -cir + 1.05)));\n    \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(cir - 1.035) - .03))*.8);\n    col = mix(col, 1. - exp(-col), .35);\n\n#ifdef debug_mirrors\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.01, abs(dot(uv, A)) - 0.01));\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.01, abs(dot(uv, B)) - 0.01));\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.02, abs(length(uv-C.xy) - C.z))-0.01);\n#endif\n\n    fragColor = vec4(sqrt(max(col, 0.)), 1.);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"X3fGzf","date":"0","viewed":0,"name":"Icosahedral Quasicrystal ","username":"neozhaoliang","description":"Icosahedral Quasicrystal using de Bruijn's multigrid method","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LATTICE   1\n\n// Barycentric coordinates of the initial vertex v0 in the fundamental tetrahedron.\n// This determines the truncation type of the honeycomb.\nconst vec4 T = vec4(1, 1, 1, 0);\n\n// use another color style\n#define GOLD_STYLE\n\n// initial vertex\nvec3 v0;\n\n// M is the four reflection mirrors of the fundamental tetrahedron,\n// M_inv is the inverse of M.\nmat4 M, M_inv;\n\n// The four vertices of the fundamental tetrahedron and the four mirror images of v0 about\n// the four mirrors\nmat4x3 V, E;\n\nconst float tbsize = 0.055;\n\n// object id\nvec3 objIDs;\n\nfloat glow;\n\nvec3 do_reflect(vec3 p, vec4 n) {\n    vec4 q = vec4(p, 1.);\n    return p - 2. * dot(q, n) * n.xyz;\n}\n\nvec3 rA(vec3 p) { return do_reflect(p, M[0]); }\nvec3 rB(vec3 p) { return do_reflect(p, M[1]); }\nvec3 rC(vec3 p) { return do_reflect(p, M[2]); }\nvec3 rD(vec3 p) { return do_reflect(p, M[3]); }\n\n\nvoid init() {\n\n    const float s = 0.70710678;    // sqrt(2) / 2\n\n#if LATTICE == 0\n    // affine A3 lattice\n    //\n    // A     C\n    //  o---o\n    //  |   |\n    //  o---o\n    // D     B\n    M = mat4(vec4(-s, -s, 0, 2.*s),\n             vec4(s, -s, 0, 0),\n             vec4(0, s, -s, 0),\n             vec4(0, s, s, 0));\n             \n    V = mat4x3(vec3(0, 0, 0),\n               vec3(2, 0, 0),\n               vec3(1, 1, -1),\n               vec3(1, 1, 1));\n\n#elif LATTICE == 1\n    // affine B3 lattice\n    //          C\n    //         o\n    //     4  /\n    // A o---o B\n    //        \\\n    //         o\n    //          D\n    M = mat4(vec4(0, 0, 1, 0),\n             vec4(0, s, -s, 0),\n             vec4(s, -s, 0, 0),\n             vec4(-s, -s, 0, 2.*s));\n             \n    V = mat4x3(vec3(1, 1, 1),\n               vec3(1, 1, 0),\n               vec3(2, 0, 0),\n               vec3(0, 0, 0));\n\n// affine C3 lattice\n#else\n    //   4       4\n    // o---o---o---o\n    // A   B   C   D\n    M = mat4(vec4(0, 0, 1, 0),\n             vec4(0, s, -s, 0),\n             vec4(s, -s, 0, 0),\n             vec4(-1, 0, 0, 1));\n    \n    V = mat4x3(vec3(0, 0, 0),\n               vec3(1, 0, 0),\n               vec3(1, 1, 0),\n               vec3(1, 1, 1));\n\n#endif\n\n    M_inv = inverse(M);\n    vec4 v4 = T * M_inv;\n    v4 /= v4.w;\n    v0 = v4.xyz;\n    for (int i = 0; i < 4; i++) {\n        E[i] = v0 - 2. * dot(v4, M[i]) * M[i].xyz;\n    }\n}\n\n\n#define FAR     80.\n#define PI      3.141592654\n\nfloat sgn(float x) { return x > 0. ? 1. : -1.; }\n\n// Camera path as a function of time t.\n// I think it's unlikely to devise an universal path that flies through all\n// honeycombs without hitting the lattice.\nvec3 camPath(float t) { return vec3(t, 0, 0); }\n\n// A mirror is active if and only if the initial vertex v0 is not on it,\n// or equivalently, the barycentric coordinate with respect to this mirror is non-zero.\nbool isActive(int k) { return T[k] != 0.0; }\n\n// try to reflect a point p about mirror with normal `n`, if p and the fundamental domain\n// are on the different sides of the mirror\nvec4 try_reflect(vec4 p, vec4 n, inout int flips) {\n    float k = dot(p, n);\n    if (k < 0.) {\n        flips += 1;\n        p.xyz -= 2. * k * n.xyz;\n    }\n    return p;\n}\n\nvec2 rot2d(vec2 p, float a) { return cos(a) * p + sin(a) * vec2(p.y, -p.x); }\n\n\n// fold a point p into the fundamental domain.\n// we return the final position of p, but also track an intermediate state of p for\n// handling dual cases.\nvec3 fold(inout vec3 p, inout int flips) {\n    \n    vec4 q;\n\n#if LATTICE == 0\n\n    p = mod(p + 2., 4.) - 2.;\n    q = vec4(p, 1);\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            q = try_reflect(q, M[j], flips);\n        }\n    }\n\n#elif LATTICE == 1\n   \n    p = mod(p + 2., 4.) - 2.;\n    flips += int(p.x < 0.0) + int(p.y < 0.0) + int(p.z < 0.0);\n    p = abs(p);\n    q = vec4(p, 1);\n    for (int i = 0; i < 2; i++) {\n        q = try_reflect(q, M[3], flips);\n        q = try_reflect(q, M[2], flips);\n        q = try_reflect(q, M[1], flips);\n    }\n    \n#else\n\n    p = mod(p + 1., 2.) - 1.;\n    flips += int(p.x < 0.0) + int(p.y < 0.0) + int(p.z < 0.0);\n    p = abs(p);\n    q = vec4(p, 1.);\n    q = try_reflect(q, M[1], flips);\n    q = try_reflect(q, M[2], flips);\n    q = try_reflect(q, M[1], flips);\n\n#endif\n\n    return q.xyz;\n}\n\n\n// Shane's tex3D function\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n) {\n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n// I hacked this function to rotate any edge (a, b) to z-axis\nmat3 rotAxis(vec3 n) {\n    n = normalize(n);\n    vec3 x;\n    if (n.x == 0.)\n        x = vec3(1, 0, 0);\n    else\n        x = normalize(vec3(-n.y, n.x, 0.));\n    vec3 y = cross(n, x);\n    return mat3(x, y, n);\n}\n\n\nfloat tube(vec2 p, float sc, float rad) {\n    return max(max(p.x, p.y), (p.x + p.y)*sc) - rad;\n}\n\n\n// draw an edge with two ends at a, b.\nvec3 dSegment(vec3 p, vec3 a, vec3 b) {\n    // set local origin at middle point of the edge\n    vec3 m = (a + b) / 2.;\n    p -= m;\n    b -= m;\n    a -= m;\n    vec3 h = (b - a) / 2.;\n    float L = length(h); // length of half the edge\n\n    p = p * rotAxis(h);  // reorient the edge along with z-axis\n    p = abs(p);\n\n    // the main tube, currently this has infinite length\n    float tb;\n    tb = tube(p.xy, 0.75, tbsize);\n\n    float band = 1e5;\n    float innerTb = 1e5;\n    \n    // add a band of 1/4 length of the edge\n    band = max(tb - 0.0075, p.z - L/4.);\n    \n    // trick: rotate p to make two smaller tubes\n    // remove them from the main tube to make the holes\n    float psize = tbsize  / 1.5;\n    vec2 peg = vec2(tube(p.xz, .64, psize), tube(p.yz, .64, psize));\n    float hole = min(peg.x, peg.y);\n    \n    // use planes to cut the band\n    float dp1 = max(peg.x, p.y - tbsize - .0095); dp1 = max(dp1, p.y - L / 4.);\n    float dp2 = max(peg.y, p.x - tbsize - .0095); dp2 = max(dp2, p.x - L / 4.);\n    band = min(band, min(dp1, dp2));\n    \n    // make holes on the main tube\n    tb = max(tb, -(hole - .015));\n    \n    // cut the infinite main tube at the two ends\n    tb = max(tb, p.z - L);\n    \n    // make holes on the band\n    band = max(band, -(hole + .0125));\n    \n    // use sphere to create a fake inner tube\n    innerTb = length(p) - tbsize;\n    \n    return vec3(tb, band, innerTb);\n}\n\n// This function is only used for handling dual of A3 honeycombs.\n// verts[4] are four non-adjacent vertices of a cube, so each face of the cube\n/// contains exactly one pair of vertices in verts[4].\n// For p a point in the cube, we find this pair of vertices so that p is nearest to\n// the face contains this pair among all six faces.\nvoid findVertexPair(vec3 p, vec3 verts[4], out int i1, out int j1) {\n    float d = 1e5;\n    float d1;\n    for (int i = 0; i < 4; i++) {\n        for (int j = i+1; j < 4; j++) {\n            // (verts[i] + verts[j]) / 2. is the center of the face since they form a diagonal pair.\n            d1 = length(p - (verts[i] + verts[j]) / 2.);\n            if (d1 < d) {\n                i1 = i;\n                j1 = j;\n                d = d1;\n            }\n        }\n    }\n}\n\n\nfloat map(vec3 p) {\n    vec3 dedge = vec3(1e5);\n    vec3 p0 = p;\n    int flips = 0;\n    p = fold(p0, flips);\n\n// For the usual uniform honeycomb just render the edges, that's safe since they lie inside\n// the fundamental tetrahedron.\n#ifndef DUAL\n\n    for (int i = 0; i < 4; i++) {\n         dedge = min(dedge, dSegment(p, v0, E[i]));\n    }\n   \n#else\n    /*\n    Render the dual honeycomb.\n\n    In the dual honeycomb two cells are adjacent if and only if they share a common face.\n        \n    For two mirrors A, B they generate a non-degenerate face if and only if either\n    of below holds:\n        \n        1. A, B are perpendicular and they are both active\n        2. A, B are not perpendicular and at least one of them is active\n        \n    For such a face we further check if {A, B, C} and {A, B, D} both generate non-degenerate cells.\n\n    1. If {A, B, C} and {A, B, D} are both non-degenerate, (C, D) form an edge in the dual honeycomb.\n    2. If {A, B, D} degenerates to a face, (D, 2*C-D) form an edge in the dual honeycomb.\n    3. If both {A, B, C} and {A, B, D} are degenerate, no edge between C and D.\n    */\n\n    // The C3 honeycomb is the easiest, handle this case first.\n    //   4       4\n    // o---o---o---o\n    // A   B   C   D\n    #if LATTICE == 2\n        // if either A or B is active, then {A, B} generate a face and {A, B, C} is a\n        // non-degenerate cell. {A, B, D} is non-degenerate iff D is active.\n        // Other procedures below are all similar.\n        if (isActive(0) || isActive(1)) {\n            if (isActive(3))\n                dedge = min(dedge, dSegment(p, V[2], V[3]));\n            else\n                dedge = min(dedge, dSegment(p, V[3], 2.*V[2]-V[3]));\n        }\n        if (isActive(0) && isActive(2)) dedge = min(dedge, dSegment(p, V[1], V[3]));\n        if (isActive(1) || isActive(2)) dedge = min(dedge, dSegment(p0, V[0], V[3]));\n        if (isActive(0) && isActive(3)) dedge = min(dedge, dSegment(p, V[1], V[2]));\n        if (isActive(1) && isActive(3)) dedge = min(dedge, dSegment(p, V[0], V[2]));\n        if (isActive(2) || isActive(3)) {\n            if (isActive(0))\n                dedge = min(dedge, dSegment(p, V[1], V[0]));\n            else\n                dedge = min(dedge, dSegment(p, V[0], 2.*V[1]-V[0]));\n        }\n \n    #elif LATTICE == 1\n\n        if (isActive(0) || isActive(1)) dedge = min(dedge, dSegment(p, V[2], V[3]));\n        if (isActive(0) && isActive(2)) {\n            if (isActive(3))\n                dedge = min(dedge, dSegment(p, V[1], V[3]));\n            else\n                dedge = min(dedge, dSegment(p, V[3], 2.*V[1]-V[3]));\n        }\n        // trick: the edge (V[0], V[3]) does not lie inside the fundamental domain hence octahedral\n        // shapes won't work. we render its 4 copies in the cube [0, 0, 0] x [2, 2, 2].\n        if (isActive(1) || isActive(2)) {\n            dedge = min(dedge, dSegment(p0, V[0], V[3]));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(2, 2, 0)));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(2, 0, 2)));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(0, 2, 2)));\n        }\n        \n        if (isActive(0) && isActive(3)) {\n            if (isActive(2))\n                dedge = min(dedge, dSegment(p, V[1], V[2]));\n            else\n                dedge = min(dedge, dSegment(p, V[2], 2.*V[1]-V[2]));\n        }\n        if (isActive(1) || isActive(3)) {\n            dedge = min(dedge, dSegment(p0, V[0], V[2]));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(0, 2, 0)));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(0, 0, 2)));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(2, 2, 2)));\n        }\n        if (isActive(2) && isActive(3)) {\n            if (isActive(1))\n                dedge = min(dedge, dSegment(p, V[1], V[0]));\n            else\n                dedge = min(dedge, dSegment(p, V[0], 2.*V[1]-V[0]));\n        } \n    \n    #else\n        // The duals of A3 honeycombs are the most difficult. Recall p0 is now in [-2, -2, -2] x [2, 2, 2].\n        // We use a completely different way to render them. The idea is, vertices of the A3 regular honeycombs\n        // are integer lattices points (i, j, k) with:\n        // i + j + k = 0 mod 4 for V0\n        // i + j + k = 2 mod 4 for V1\n        // i + j + k = 1 mod 4 for V2\n        // i + j + k = 3 mod 4 for V3\n     \n        // find the center of the 2x2x2 cube that p belongs to\n        vec3 C = vec3(sgn(p0.x), sgn(p0.y), sgn(p0.z));\n        \n        float k = mod(C.x + C.y + C.z, 4.);\n        // if k = 1 mod 4, then the center of this cube is congruent to V[2] of the fundamental tetrahedron.\n        // else k = 3 mod 4 and the center is congruent to V[3].\n        int type = (k == 1.) ? 2 : 3;\n        \n        vec3 V0[4];  // holds the vertices of this 2x2x2 cube that are congruent to V[0]\n        vec3 V1[4];  // holds the vertices of this 2x2x2 cube that are congruent to V[1]\n        \n        if (type == 2) {\n            V0[0] = C + vec3(1, 1, 1);\n            V0[1] = C + vec3(-1, -1, 1);\n            V0[2] = C + vec3(1, -1, -1);\n            V0[3] = C + vec3(-1, 1, -1);\n            V1[0] = C + vec3(1, -1, 1);\n            V1[1] = C + vec3(-1, 1, 1);\n            V1[2] = C + vec3(1, 1, -1);\n            V1[3] = C + vec3(-1, -1, -1);\n        }\n        else {  // switch the role of V0, V1 above\n            V1[0] = C + vec3(1, 1, 1);\n            V1[1] = C + vec3(-1, -1, 1);\n            V1[2] = C + vec3(1, -1, -1);\n            V1[3] = C + vec3(-1, 1, -1);\n            V0[0] = C + vec3(1, -1, 1);\n            V0[1] = C + vec3(-1, 1, 1);\n            V0[2] = C + vec3(1, 1, -1);\n            V0[3] = C + vec3(-1, -1, -1);\n        }\n        \n        int r0, s0, r1, s1;\n        findVertexPair(p0, V0, r0, s0);\n        findVertexPair(p0, V1, r1, s1);\n        vec3 P0 = V0[r0] + V0[s0] - C;\n        vec3 P1 = V1[r1] + V1[s1] - C;\n\n        if (isActive(2) && isActive(3)) dedge = min(dedge, dSegment(p, V[0], V[1]));\n        if (isActive(1) || isActive(3)) {\n            if (type == 2) {\n                dedge = min(dedge, dSegment(p0, C, V0[r0]));\n                dedge = min(dedge, dSegment(p0, C, V0[s0]));\n            }\n            else {\n                dedge = min(dedge, dSegment(p0, P0, V0[r0]));\n                dedge = min(dedge, dSegment(p0, P0, V0[s0]));\n            }\n        }\n        if (isActive(1) || isActive(2)) {\n            if (type == 3) {\n                dedge = min(dedge, dSegment(p0, C, V0[r0]));\n                dedge = min(dedge, dSegment(p0, C, V0[s0]));            \n            }\n            else {\n                dedge = min(dedge, dSegment(p0, P0, V0[r0]));\n                dedge = min(dedge, dSegment(p0, P0, V0[s0]));\n            }\n        }\n        if (isActive(0) || isActive(3)) {\n            if (type == 2) {\n                dedge = min(dedge, dSegment(p0, C, V1[r1]));\n                dedge = min(dedge, dSegment(p0, C, V1[s1]));\n            }\n            else {\n                dedge = min(dedge, dSegment(p0, P1, V1[r1]));\n                dedge = min(dedge, dSegment(p0, P1, V1[s1]));\n            }\n        }\n        if (isActive(0) || isActive(2)) {\n            if (type == 3) {\n                dedge = min(dedge, dSegment(p0, C, V1[r1]));\n                dedge = min(dedge, dSegment(p0, C, V1[s1]));\n            }\n            else {\n                dedge = min(dedge, dSegment(p0, P1, V1[r1]));\n                dedge = min(dedge, dSegment(p0, P1, V1[s1]));\n            }\n        }\n        if (isActive(0) && isActive(1)) dedge = min(dedge, dSegment(p, V[2], V[3]));\n\n    #endif\n#endif\n\n    // store the object ids.\n    objIDs = dedge;\n    return min(dedge.x, min(dedge.y, dedge.z));\n}\n\n\n// This reduces the compiling time to about 7x times faster\nvec3 calcNormal(vec3 p, inout float edge, float t) {\n    float eps = 1./mix(400., iResolution.y, .5)*(1. + t*.5);\n    float d = map(p);\n    vec3 e = vec3(eps, 0, 0);\n    vec3 da = vec3(-2.*d);\n    for(int i = min(iFrame, 0); i < 3; i++ ) {\n        for(int j = min(iFrame, 0); j < 2; j++)\n            da[i] += map(p + e * float(1 - 2*j));\n        e = e.zxy;\n    }\n    da = abs(da);\n\n    edge = da.x + da.y + da.z;\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n\n    vec3 n = vec3(0.0);\n    for(int i=min(iFrame, 0); i<4; i++) {\n        vec3 e = .57735*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.);\n        n += e*map(p + .001*e);\n    }\n    return normalize(n);\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float tmin, float tmax, float k) {\n    const int maxShadeIterations = 32;\n    vec3 rd = lp - ro;\n    rd /= max(length(rd), 1e-4);\n    float shade = 1.0;\n    float t = tmin;\n    for (int i = 0; i < maxShadeIterations; i++) {\n        float h = map(ro + rd * t);\n        t += clamp(h, 0.01, 0.2);\n        shade = min(shade, smoothstep(0., 1., k * h / t));\n        if (abs(h) < 1e-4 || t > tmax)\n            break;\n    }\n    return min(max(shade, 0.) + .1, 1.);\n}\n\nfloat calcAO(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.15 * float(i) / 4.0;\n        float d = map(p + h * n);\n        occ += (h - d) * sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0.0, 1.0);\n}\n\n\nfloat trace(in vec3 ro, in vec3 rd) {\n    glow = 0.;\n    float ah;\n    const float precis = 1e-3;\n    float t = 0.0;\n    for (int i = 0; i < 128; i++) {\n        float h = map(ro + rd * t);\n        ah = abs(h);\n        glow += 1./(1. + ah*ah*8.);\n        if (ah < (t * 0.125 + 1.) * precis || t > FAR)\n            break;\n        t += h;\n    }\n    return min(t, FAR);\n}\n\n\nvec3 transform(in vec3 p) {\n    if (iMouse.x > 0.0) {\n        float phi =  2.0*iMouse.x / iResolution.x * PI - PI;\n        float theta = iMouse.y / iResolution.y * PI - 0.5*PI;\n        p.xz = rot2d(p.xz, phi / 6.);\n        p.yx = rot2d(p.yx, theta / 4.);\n       \n    }\n    return p;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    init();\n\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    vec3 up = vec3(0, 1, 0);\n    vec3 ro = camPath(iTime * 1.1);\n    vec3 lookat = camPath(iTime * 1.1 + 0.1);\n    \n    vec3 forward = normalize(lookat - ro);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    vec3 rd = normalize(uv.x * right + uv.y * up + forward * 2.);\n    ro = transform(ro);\n    rd = transform(rd);\n    vec3 lp = ro + vec3(-1, 2, -1);\n    vec3 col = vec3(0);\n    \n    float t = trace(ro, rd);\n    \n    float objID = (objIDs.x < objIDs.y && objIDs.x < objIDs.z) ? 0. : (objIDs.y < objIDs.z) ? 1. : 2.;\n    \n    if (t < FAR) {\n        float ed;\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos, ed, t);\n\n        vec3 oCol;\n        #ifndef GOLD_STYLE\n        vec3 bCol = mix(vec3(1, .1, .5).zyx,\n                        vec3(1, .3, .1).zyx,\n                        dot(sin(pos*8. - cos(pos.yzx*4. + iTime*4.)), vec3(.166)) + .5);\n        #else\n        vec3 bCol = mix(vec3(1, .5, .1),\n                        vec3(1, .1, .2),\n                        dot(sin(pos*8. - cos(pos.yzx*4. + iTime*4.)), vec3(.166)) + .5);\n        #endif\n        if(objID < .5)\n            oCol = mix(bCol, vec3(1), .97);\n        \n        else if (objID > 1.5)\n            oCol = mix(bCol, vec3(1), .05) + bCol*2.;\n        \n        else\n            oCol = mix(bCol, vec3(1.35), .97)*vec3(1.1, 1, .9);\n\n        vec3 tx = tex3D(iChannel0, pos*2., nor);\n        tx = smoothstep(.0, .5, tx)*2.;\n\n        if(objID < 1.5)\n            oCol *= tx;\n        else\n            oCol *= mix(vec3(1), tx, .5);\n\n        float ao = calcAO(pos, nor);\n        float sh = softShadow(pos + nor*.002, lp, 0.001, 16., t);\n\n        vec3 ld = lp - pos;\n        float dist = max(length(ld), 0.001);\n        ld /= dist;\n\n        float atten = 3./(1. + dist*0.05 + dist*dist*0.025);\n\n        float diff = max(dot(ld, nor), 0.);\n        if (objID < 1.5)\n            diff = pow(diff, 4.)*2.;\n        float spec = pow(max(dot( reflect(ld, nor), rd), 0.0 ), 32.0);\n\n        col = oCol*(diff + .25) + mix(bCol.zyx, vec3(1, .7, .3), .5)*spec*4.;\n\n        col += .015/max(abs(.05 - map(pos*1.5 + sin(iTime/6.))), .01)*oCol*mix(bCol, vec3(1, .8, .5), .35);\n\n        // Adding a bit of glow. It was tempting to get my money's worth, but I kept it subtle. :)\n        if(objID < 1.5)\n            col += bCol*glow*.02;\n        else\n            col += bCol*glow*1.5;\n\n        // Applying the dark edges, attenuation, shadows and ambient occlusion.\n        col *= (1. - ed*.7);\n        col *= atten*(sh + ao*.25)*ao;\n\n    }\n\n    float fog = 1./(1. + t*.125 + t*t*.01);\n    col = mix(vec3(0), col, fog);//\n\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125);\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float sq5 = sqrt(5.0);\nconst float sq52 = 2.0 / sqrt(5.0);\nconst float pi = 3.141592654;\n\nconst vec3 icosa[6] = vec3[6] (\n    vec3(1, 0, 0.5) * sq52,\n    vec3(cos(pi / 5.), sin(pi/5.), 0.5) * sq52,\n    vec3(cos(2.*pi / 5.), sin(2.*pi/5.), 0.5) * sq52,\n    vec3(cos(3.*pi / 5.), sin(3.*pi/5.), 0.5) * sq52,\n    vec3(cos(4.*pi / 5.), sin(4.*pi/5.), 0.5) * sq52,\n    vec3(0,0,1)\n);\n\nconst float offsets[6] = float[6] (1./6., 1./6., 1./6., 1./6., 1./6., 1./6.);","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"msd3WN","date":"0","viewed":0,"name":"Isometries in Poincare's disk","username":"neozhaoliang","description":"Isometries of hyperbolic space in Poincare's disk model","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI        3.141592654\n\nmat2 rot2d(float a) {\n    float ca = cos(a), sa = sin(a);\n    return mat2(ca, -sa, sa, ca);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x + z.y * w.y,\n        -z.x * w.y + z.y * w.x\n    ) / dot(w, w);\n}\n\nvec2 cconj(vec2 z) {\n    return vec2(z.x, -z.y);\n}\n\nstruct Mobius {\n    vec2 A, B, C, D;\n};\n\nfloat hypot (vec2 z) {\n    float x = abs(z.x);\n    float y = abs(z.y);\n    float t = min(x, y);\n    x = max(x, y);\n    t = t / x;\n    return x * sqrt(1.0 + t * t);\n}\n\n\nfloat e2h(float r) {\n    return 2. * atanh(r);\n}\n\nfloat h2e(float r) {\n    return tanh(0.5 * r);\n}\n\nMobius mobInverse(Mobius m) {\n    return Mobius(\n        m.D, -m.B, -m.C, m.A\n    );\n}\n\nvec2 applyMobius(Mobius m, vec2 z) {\n    return cdiv(cmul(m.A, z) + m.B, cmul(m.C, z) + m.D);\n}\n\nMobius translation(vec2 p) {\n    return Mobius(\n        vec2(1, 0), -p, -cconj(p), vec2(1, 0)\n    );\n}\n\nMobius translation2(vec2 p) {\n    return Mobius(\n        vec2(1, 0), p, cconj(p), vec2(1, 0)\n    );\n}\n\nMobius rotation(float a) {\n    return Mobius(\n        vec2(cos(a), sin(a)), vec2(0), vec2(0), vec2(1, 0)\n    );\n}\n\nMobius composite(Mobius m1, Mobius m2) {\n    vec2 A = cmul(m1.A, m2.A) + cmul(m1.B, m2.C);\n    vec2 B = cmul(m1.A, m2.B) + cmul(m1.B, m2.D);\n    vec2 C = cmul(m1.C, m2.A) + cmul(m1.D, m2.C);\n    vec2 D = cmul(m1.C, m2.B) + cmul(m1.D, m2.D);\n    return Mobius(A, B, C, D);\n}\n\nMobius composite(Mobius m1, Mobius m2, Mobius m3) {\n    return composite(m1, composite(m2, m3));\n}\n\nMobius rotation(vec2 p, float a) {\n    Mobius m1 = translation(-p);\n    Mobius m2 = rotation(a);\n    Mobius m3 = translation(p);\n    return composite(m3, m2, m1);\n}\n\n\nvec2 rectGrid(vec2 z, vec2 size) {\n    return mod(z + 0.5 * size, size) - 0.5 * size;\n}\n\nvec2 polarGrid(vec2 z, vec2 size) {\n    float theta = atan(z.y, z.x);\n    float r = e2h(hypot(z));\n    return rectGrid(vec2(r, theta), size);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 c = vec2(0.2, 0.4);\n    Mobius m = translation(c);\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv *= 1.02;\n    vec2 p = uv;\n    vec3 col = vec3(1);\n    \n    if (length(p) < 1.) {\n\n        p = applyMobius(m, p);\n        p = rot2d(iTime / 3.) * p;\n        vec2 polar = polarGrid(p, vec2(.5, PI/6.));\n        float d1 = abs(polar.x);\n        float d2 = abs(polar.y);\n        \n                \n        float K = hypot(vec2(dFdx(e2h(length(p))), dFdy(e2h(length(p)))));\n        d1 /= K * iResolution.y / 2.;\n        \n       \n        \n        float L = hypot(vec2(dFdx(atan(p.y, p.x)), dFdy(atan(p.y, p.x))));\n        d2 /= L * iResolution.y / 2.;\n        \n        float d = hypot(vec2(d1, d2));\n        //d /= (1. - pow(dot(p, p), 10.));\n\n        float sf = 2. / iResolution.y;\n        col = mix(col, vec3(0), 1. - smoothstep(0.00, sf, d1 - sf));\n        col = mix(col, vec3(0), 1. - smoothstep(0.00, sf, d2 - sf));\n       \n        col = mix(col, vec3(0), 1. - smoothstep(0.00, sf, d - 7.*sf));\n    }\n    \n    vec2 q = vec2(0.1, 0);\n             \n    q = applyMobius(m, q);\n  \n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0.00, 0.01, abs(length(p-q)) - 0.03));\n    col = mix(col, vec3(0), 1. - smoothstep(0.00, 0.01, abs(length(p) - 1.0)));\n\n    fragColor = vec4(sqrt(max(col, 0.)), 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"7dK3WD","date":"1631608166","viewed":781,"name":"Kleinian limit set","username":"neozhaoliang","description":"Another Kleinian limit set. A mix of the work https://www.shadertoy.com/view/ttdXDl and  https://www.shadertoy.com/view/Wl3fzM","likes":33,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define L2(x)           dot(x, x)\n#define MAX_ITER        50\n\n\nbool doHalfPlane = true;\n\nconst vec2[] PARAMS = vec2[] (\n    vec2(1.8462756, 0.09627581),\n    vec2(1.958591, 0.011278),\n    vec2(1.857382, 0.076258),\n    vec2(1.64213876, 0.76658841),\n    vec2(1.658312, 0.5),\n    vec2(1.926434053, 0.027381792),\n    vec2(2, 0)\n);\n\nconst int NUM_PARAMS = PARAMS.length();\n\nfloat wrap(in float x, in float a, in float s) {\n    return mod(x - s, a) + s;\n}\n\nvec2 transA(in vec2 z, float a, float b, inout float scale) {\n    float k = 1. / dot(z, z);\n    z *= k;\n    scale *= k;\n    z.x -= b;\n    z.y = a - z.y;\n    return z;\n}\n\nbool separation(in vec2 z, in float a, in float b) {\n    float f = (z.x >= -b/2.0) ? 1.0 : -1.0;\n    float K = sign(b) * (2.0*a - 1.95) / 4.3;\n    float M = 7.2 - (1.95 - a) * 18.0;\n    return z.y >= 0.5*a + K*f*(1.0 - exp(-M*abs(z.x + b * 0.5)));\n}\n\nfloat kleinian(in vec2 z, vec2 pattern, float scale) {\n    float a = pattern.x, b = pattern.y;\n    float f = sign(b);\n    vec2 lz = z + vec2(1), llz = z - vec2(1);\n    for (int i = 0; i < MAX_ITER; i++) {\n        z.x = z.x + f * b / a * z.y;\n        z.x = wrap(z.x, 2.0, -1.0);\n        z.x = z.x - f * b / a * z.y;\n\n        if (separation(z, a, b)) {\n            z = vec2(-b, a) - z;\n        }\n\n        z = transA(z, a, b, scale);\n\t\t\n        // If the iterated points enters a 2-cycle, bail out.\n        if (dot(z-llz, z-llz) < 1e-6) {\n            return abs(z.y)  / scale;\n        }\n    \n       // If the iterated point gets outside z.y=0 and z.y=a, bail out.\n        if (z.y < 0.0)\n            return -z.y/scale;\n        if (z.y > a)\n            return (z.y - a)/scale;\n\n        llz=lz; lz=z;\n    }\n    return 1e3;\n}\n\n\nvec3 hsv2rgb(vec3 c) {\n    const vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 postprocess(vec3 col, vec2 q) {\n    col = pow(clamp(col, 0.0, 1.0), vec3(1.0/2.2)); \n    col = col*0.6 + 0.4*col*col*(3.0 - 2.0*col);\n    col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n    col *= 0.5 + 0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.7);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    const float zoom = 3.;\n    \n    float time = mod(0.2*iTime, float(NUM_PARAMS));\n    int it = int(floor(time));\n    float ft = fract(time);\n    vec2 pattern = mix(PARAMS[it], PARAMS[(it+1) % NUM_PARAMS], smoothstep(0., 1., ft));\n    float scale = 1.2;\n    vec2 p = uv * 1.1;\n    \n    if (doHalfPlane) {\n        p.y += 1.0;\n        p *= 0.5*pattern.x;\n    }\n    else {\n        p -= vec2(0, -1);\n        float r2 = 2. / dot(p, p);\n        p *= r2;\n        scale *= r2;\n        p += vec2(0, -1);\n    }\n    float aa = 2. / iResolution.y;\n    \n    float d = zoom * kleinian(p, pattern, scale);\n    \n    float b = -0.125;\n    float t = 20.0;\n    const float lh = 1.25;\n    const vec3 lp1 = vec3(.5, .5, lh);\n    const vec3 lp2 = vec3(-0.5, .5, lh);\n    \n    vec3 ro = vec3(0, 0, t);\n    vec3 pp = vec3(p, 0);\n    \n    vec3 rd = normalize(pp - ro);\n\n    vec3 ld1 = normalize(lp1 - pp);\n    vec3 ld2 = normalize(lp2 - pp);\n\n    float bt = -(t-b)/rd.z;\n  \n    vec3  bp   = ro + bt*rd;\n    vec3  srd1 = normalize(lp1 - bp);\n    vec3  srd2 = normalize(lp2 - bp);\n    float bl21 = L2(lp1 - bp);\n    float bl22 = L2(lp2 - bp);\n\n    float st1 = (0.0-b)/srd1.z;\n    float st2 = (0.0-b)/srd2.z;\n    vec3  sp1 = bp + srd1*st1;\n    vec3  sp2 = bp + srd2*st1;\n\n    float bd = zoom * kleinian(bp.xy, pattern, scale);\n    float sd1= zoom * kleinian(sp1.xy, pattern, scale);\n    float sd2= zoom * kleinian(sp2.xy, pattern, scale);\n\n    vec3 col = vec3(0.0);\n    const float ss = 15.0;\n  \n    col       += vec3(1)  * (1.0 - exp(-ss*(max(sd1, 0.0)))) / bl21;\n    col       += vec3(.5) * (1.0 - exp(-ss*(max(sd2, 0.0)))) / bl22;\n    float l   = length(p);\n    float hue = fract(0.75*l-0.3*iTime) + .5;\n    float sat = tanh(4.*l);\n    vec3 hsv  = vec3(hue, sat, 1.0);\n    vec3 bcol = hsv2rgb(hsv);\n    col       *= (1.0-tanh(0.25*l))*0.5;\n    col       = mix(col, bcol, smoothstep(-aa, aa, -d));  \n    col       += 0.5*sqrt(bcol.zxy)*(exp(-(10.0+100.0*tanh(l))*max(d, 0.0)));\n    \n    col = postprocess(col, fragCoord/iResolution.xy);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"fstyz2","date":"0","viewed":0,"name":"Lots of pseudo kleinian fractals","username":"neozhaoliang","description":"Boyd-Maxwell ball packings 3d version","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2 // Make it 3 if you have a fast machine\n#endif\n\nfloat map(vec3 p, inout int index) {\n    float scale = 3.;\n    orb = vec4(1000.0); \n    for (int i = 0; i < MAX_ITER; i++) {\n        bool cond = true;\n        for (int k = 0; k < 5; k++) {\n            cond = try_reflect(p, coclusters[k], scale) && cond;\n            orb = min( orb, vec4(abs(p), dot(p, p)));\n        }\n\n        if (cond)\n            break;\n    }\n    index = 0;\n\n    float d = p.z;\n    for (int j = 1; j < 5; j++) {\n        if (clusters[j].isRealBall) {\n            float d1 = sdistanceToBall(p, clusters[j]);\n            if (d1 < d) { d = d1; index = j; }\n        }\n    }\n    return d / scale;\n}\n\n\n\nfloat trace( in vec3 ro, in vec3 rd, inout int index )\n{\n\tfloat maxd = 30.0;\n    float t = 0.01;\n    for( int i=0; i<512; i++ )\n    {\n\t    float precis = 0.001 * t;\n        \n\t    float h = map( ro+rd*t, index );\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    float precis = 0.001 * t;\n    int index;\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy, index) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, index ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, index ) + \n                      e.xxx*map( pos + e.xxx, index ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float anim )\n{\n    // trace\t\n    vec3 col = vec3(0.0);\n    int index = 0;\n    float t = trace( ro, rd, index);\n    if( t>0.0 )\n    {\n        vec4 tra = orb;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t );\n\n        // lighting\n        vec3  light1 = vec3(  0.577, 0.577, 0.577 );\n        vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n        float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n        float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n        float amb = (0.7+0.3*nor.z);\n        float ao = pow( clamp(tra.w*2.0,0.0,1.0), 1.2 );\n\n        vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*ao;\n        brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n        brdf += 1.0*vec3(0.40,0.40,0.40)*bac*ao;\n\n        // material\t\t\n        vec3 rgb = vec3(1.0);\n        rgb = mix( rgb, vec3(1.0,0.80,0.2), clamp(6.0*tra.z,0.0,1.0) );\n        rgb = mix( rgb, vec3(1.0,0.55,0.0), pow(clamp(1.0-2.0*tra.z,0.0,1.0),8.0) );\n\n        // color\n        col = rgb*brdf*exp(-0.2*t);\n    }\n\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init(333, vec3(3, 3, 2), vec3(3, 3, 2), inf, bvec4(1, 0, 0, 0));\n    float time = iTime*0.05 + 0.01*iMouse.x;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 1, jj = 1;\n    #endif\n    {\n        vec2 q = fragCoord.xy+vec2(float(ii),float(jj))/float(AA);\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n\n        // camera\n        vec3 ro = vec3( 2.8*cos(0.1+.33*time), 0.4 + 0.30*cos(0.37*time), 1.2+1.2*cos(0.5+0.35*time) );\n        vec3 ta = vec3( 1.9*cos(1.2+.41*time), 0.4 + 0.10*cos(0.27*time), 1.5 + 1.*cos(2.0+0.38*time) );\n        float roll = 0.2*cos(0.1*time);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(0, 0, 1);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        tot += render( ro, rd, anim );\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_ITER         30\n#define PI               3.141592653\n#define L2(x)            dot(x, x)\n#define ZOOM             3.\n#define inf              -1.05\n\nvec4 orb; \n\n// uncomment this to show the vertice sections\n//#define DrawVerticalSections\n\nfloat dihedral(float x) {\n    return x == inf ? 1. : cos(PI / x);\n}\n\nvec3 dihedral(vec3 v) {\n    return vec3(dihedral(v.x), dihedral(v.y), dihedral(v.z));\n}\n\n\n// For spheres n is the center, r is the radius\n// For planes n is the normal vector, r is the distance between the plane and the origin\n// if invert is true then the inside/outside of the sphere is interchanged (not used in this program)\n// if hasRealBall is true then this virtual ball has a real ball correspondes to it\nstruct Ball {\n    bool isplane;\n    vec3 n;\n    float r;\n    bool invert;\n    bool isRealBall;\n};\n\n// coclusters are mirror balls, they corresponde to root vectors (space-like)\nBall[5] coclusters;\n// clusters are real balls, they corresponde to space-like weight vectors\nBall[5] clusters;\n\n\n// create a ball. by default it's the z=0 plane with normal points to the negative half\nBall defaultBall() {\n    return Ball(false, vec3(0, 0, -1), 0., false, false);\n}\n\n// Distance from a point to a ball\nfloat sdistanceToBall(vec3 p, Ball B) {\n    if (B.isplane) {\n        float k = dot(vec4(p, 1), vec4(B.n, B.r));\n        return k;\n    }\n    else\n        return length(p - B.n) - B.r;\n}\n\nBall from_plane(vec3 n, float d) {\n    return Ball(true, n, d, false, false);\n}\n\nBall from_sphere(vec3 cen, float r) {\n    return Ball(false, cen, r, false, false);\n}\n\nvoid invertBall(inout Ball B) {\n    B.invert = !B.invert;\n}\n\n// try to reflect a point p to the positive half space bounded by a ball\n// if we are already in the positive half space, do nothing and return true,\n// else reflect about the ball and return false\n// if B is a sphere we try to reflect p into the interior of B\nbool try_reflect(inout vec3 p, Ball B, inout float scale) {\n    if (B.isplane) {\n        float k = dot(vec4(p, 1), vec4(B.n, B.r));\n        if (k >= 0.)\n            return true;\n        p -= 2. * k  * B.n;\n        return false;\n    }\n    else {\n        vec3 cen = B.n;\n        float r = B.r;\n        vec3 q = p - cen;\n        float d2 = dot(q, q);\n        float k = (r * r) / d2;\n        if ( (k < 1.0 && B.invert) || (k > 1. && !B.invert) )\n            return true;\n        p = k * q + cen;\n        scale *= k;\n        return false;\n    }\n}\n\n// return distance to the scene, and get the index of the real ball hitted\n\n\n// solve M*v = b, where v = (x, y, r) is the xy-coordinate of the center of the ball,\n// r is the radius of the ball.\nBall solveBall(mat3 M, vec3 b) {\n    vec3 p = b * inverse(M);\n    return from_sphere(vec3(p.xy, 0.), p.z);\n}\n\n// Solve a ball with its center has xy-coordinates P, and is orthogonal to other two Balls B0, B1.\n// Here B0 may be either a sphere or a plane, B1 is always a sphere. \nBall solveBall(vec2 P, Ball B0, Ball B1) {\n    if (B0.isplane) {\n        float z = B0.r;\n        vec3 cen = vec3(P, z);\n        float R = sqrt(L2(cen - B1.n) - B1.r*B1.r);\n        return from_sphere(cen, R);\n    }\n    else {\n        float r1 = B1.r;\n        float r0 = B0.r;\n        float z0 = B0.n.z;\n        float k0 = L2(P - B0.n.xy);\n        float k1 = L2(P - B1.n.xy);\n        float z = (r1*r1 - r0*r0 + z0*z0 + k0 - k1) / (2.*z0);\n        float R = sqrt(k1 + z*z - r1*r1);\n        return from_sphere(vec3(P, z), R);\n    }\n    \n}\n\n// triangleType: must be one of 236, 244 or 333\n// dihedralAngles0: labels of the edges between v0 and (v2, v3, v4)\n// dihedralAngles1: labels of the edges between v1 and (v2, v3, v4)\n// dihedralAngles0_1: label of the edge between (v0, v1)\n// isRealBall: specify which of (v1, v2, v3, v4) has real balls\nvoid init(int triangleType,\n          vec3 dihedralAngles0,\n          vec3 dihedralAngles1,\n          float dihedralAngle0_1,\n          bvec4 isRealBall) {\n    const float s2 = sqrt(2.);\n    const float s3 = sqrt(3.);\n    mat3 M0, M1;\n    vec3 b;\n    Ball B0, B1, B2, B3, B4;\n    vec3 t0 = dihedral(dihedralAngles0);\n    vec3 t1 = dihedral(dihedralAngles1);\n    float t01 = dihedral(dihedralAngle0_1);\n    // A, B, C are the vertices of the triangle formed by mirror plane v2, v3, v4 and z=0 plane\n    vec2 A, B, C;\n\n    // the 236 case\n    if (triangleType == 236) {\n        A = vec2(0, 0), B = vec2(0, s3), C = vec2(1, 0);\n        B2 = from_plane(vec3(1, 0, 0), 0.);\n        B3 = from_plane(vec3(-s3/2., -0.5, 0), s3/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(1, 0, -t1.x), vec3(s3/2., 0.5, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(1, 0, -t0.x), vec3(s3/2., 0.5, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(0, s3/2., 0);\n    }\n    \n    // the 244 case\n    else if (triangleType == 244) {\n        A = vec2(0, 0), B = vec2(0, 1), C = vec2(1, 0);\n        B2 = from_plane(vec3(1, 0, 0), 0.);\n        B3 = from_plane(vec3(-s2/2., -s2/2., 0), s2/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(1, 0, -t1.x), vec3(1./s2, 1./s2, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(1, 0, -t0.x), vec3(1./s2, 1./s2, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(0, s2/2., 0);\n    }\n    \n    // the 333 case\n    else {\n        A = vec2(-1, 0), B = vec2(0, s3), C = vec2(1, 0);\n        B2 = from_plane(vec3(s3/2., -.5, 0), s3/2.);\n        B3 = from_plane(vec3(-s3/2., -.5, 0), s3/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(-s3/2., 0.5, t1.x), vec3(s3/2., .5, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(-s3/2., 0.5, t0.x), vec3(s3/2., .5, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(s3, s3, 0)/2.;\n    }\n    \n    // now we solve the virtual ball B1, this can't be a plane\n    B1 = solveBall(M1, b);\n    invertBall(B1);\n    \n    // now we solve the virtual ball B0, this can be either a plane or a sphere\n    // this depends on if all entries in dihedralAngles0 are all 2\n    if (dot(dihedralAngles0, vec3(1)) == 6.) {\n        B0 = from_plane(vec3(0, 0, -1), B1.r*t01);\n    }\n    else {\n        B0 = solveBall(M0, b);\n        float r1 = B1.r, r0 = B0.r;\n        B0.n.z = sqrt(r0*r0 + r1*r1 + 2.*r0*r1*t01 - L2(B1.n.xy - B0.n.xy));\n        invertBall(B0);\n    }\n    coclusters = Ball[5] (B0, B1, B2, B3, B4);\n\n    //now we process the real balls\n    for (int k = 0; k < 5; k++)\n        clusters[k] = defaultBall();\n        \n    if (isRealBall.x) {\n        clusters[1] = from_plane(vec3(0, 0, -1.), B0.n.z);\n        clusters[1].isRealBall = true;\n    }\n    if (isRealBall.y) {\n        clusters[2] = solveBall(C, B0, B1);\n        clusters[2].isRealBall = true;\n    }\n    if (isRealBall.z) {\n        clusters[3] = solveBall(A, B0, B1);\n        clusters[3].isRealBall = true;\n    }\n   \n    if (isRealBall.w) {\n        clusters[4] = solveBall(B, B0, B1);\n        clusters[4].isRealBall = true;\n    }\n}\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"7lf3Wn","date":"1621876254","viewed":827,"name":"Marden's Theorem","username":"neozhaoliang","description":"This shader illustrates Marden's theorem on the Steiner inellipse of a triangle.","likes":26,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Marden's theorem on Steiner inellipse, Zhao Liang.\n\nMotivated by this tweet:\n\n    https://twitter.com/theAlbertChern/status/1395468792788967428?s=20\n*/\n#define PI 3.141592653\n\nfloat sl;\n\nconst float palNum = 70.;\n\n\nfloat sFract(float x, float sm)\n{\n    // Extra smoothing factor. \"1\" is the norm.\n    const float sf = 1.;\n\n    // The hardware \"fwidth\" is cheap, but you could take the expensive route and\n    // calculate it by hand if more quality was required.\n    vec2 u = vec2(x, fwidth(x)*sf*sm);\n\n    // Ollj's original formula with a transcendental term omitted.\n    u.x = fract(u.x);\n    u += (1. - 2.*u)*step(u.y, u.x);\n    return clamp(1. - u.x/u.y, 0., 1.); // Cos term ommitted.\n}\n\n// Only correct for nonnegative values, but in this example, numbers aren't negative.\nfloat sFloor(float x)\n{\n    return x - sFract(x, 1.);\n}\n\nfloat sdCross( in vec2 p, in vec2 b, float r )\n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    \n\tvec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    float d = length(max(w,0.0));\n    return ((k>0.0)?d:-d) + r;\n}\n\n\nvec3 rotHue(vec3 p, float a)\n{\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\n    return clamp(p*hr, 0., 1.);\n}\n\nfloat msign(in float x)\n{\n    return x < 0.0 ? -1.0 : 1.0;\n}\n\nmat2 rot2d(float a)\n{\n    float c=cos(a), s=sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvec2 cmul(vec2 p, vec2 q)\n{\n    return vec2(p.x*q.x-p.y*q.y, p.x*q.y+p.y*q.x);\n}\n\nvec2 csqrt(vec2 p)\n{\n    float a = atan(p.y, p.x) / 2.;\n    return vec2(cos(a), sin(a)) * sqrt(length(p));\n}\n\n// distance from a 2d point p to a 2d segment (a, b)\nfloat dseg(vec2 p, vec2 a, vec2 b)\n{\n    vec2 v = b - a;\n    p -= a;\n    float t = clamp(dot(p, v)/dot(v, v), 0., 1.);\n    return length(p - t * v);\n}\n\n// iq's triangle signed distance function\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n\n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// ellipse signed distance function\nfloat sdEllipse( vec2 p, vec2 cen, float theta, in vec2 ab )\n{\n    p -= cen;\n    float c = cos(theta), s = sin(theta);\n    p *= mat2(c, s, -s, c);\n    vec2 pab = p / (ab * ab);\n    return (0.5 * dot(pab, p) - 0.5) / length(pab);\n}\n\nfloat sdEllipseFromTriangle(vec2 p, vec2 p0, vec2 p1, vec2 p2, out vec2 f1, out vec2 f2)\n{\n    vec2 m = (p0 + p1 + p2) / 3.;\n    vec2 n = (cmul(p0, p1) + cmul(p1, p2) + cmul(p2, p0)) / 3.;\n    f1 = m + csqrt(cmul(m, m) - n);\n    f2 = m - csqrt(cmul(m, m) - n);\n    vec2 mid = (p0 + p1) / 2.;\n    float a = (length(mid - f1) + length(mid - f2)) / 2.;\n    vec2 cen = (f1 + f2) / 2.;\n    vec2 dir = (f1 - f2) / 2.;\n    float b = sqrt(a*a -dot(dir, dir));\n    float theta = atan(dir.y, dir.x);\n    return sdEllipse(p, cen, theta, vec2(a, b));\n}\n\nfloat getVoltage( vec2 p, vec2 p0, vec2 p1, vec2 p2 )\n{\n    float c = length(p - p0) * length(p - p1) * length(p - p2);\n    c = log(max(c, 0.001));\n    c = c / 10. + 0.5;\n    c = clamp(c, 0., 1.);\n    float level = sFloor(c*(palNum - .001));\n    sl = level;\n    return clamp(level/(palNum - 1.), 0., 1.) * .85 + .15 * c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    float sf = 2. / iResolution.y;\n    vec2 p = uv * 2.;\n\n    // triangle vertices\n    vec2 A = vec2(1.5*sin(iTime), 1.5);\n    vec2 B = vec2(-2.+0.4*cos(iTime*0.7), -1.+0.6*cos(iTime*0.7));\n    vec2 C = vec2(1.8+cos(iTime), -1.6);\n\n    // distance to the triangle\n    float dtri = sdTriangle(p, A, B, C);\n\n    // foci of the Steiner inscribed ellipse.\n    vec2[2] foci;\n\n    // solve the ellipse and foci\n    vec2 m = (A + B + C) / 3.;\n    vec2 n = (cmul(A, B) + cmul(B, C) + cmul(C, A)) / 3.;\n    foci[0] = m + csqrt(cmul(m, m) - n);\n    foci[1] = m - csqrt(cmul(m, m) - n);\n    // the tangent point is the middle point of an edge.\n    vec2 mid = (A + B) / 2.;\n    // semi-axis\n    float a = (length(mid - foci[0]) + length(mid - foci[1])) / 2.;\n    vec2 cen = (foci[0] + foci[1]) / 2.;\n    vec2 dir = (foci[0] - foci[1]) / 2.;\n    float b = sqrt(a*a - dot(dir, dir));\n    float theta = atan(dir.y, dir.x);\n    // now we have the distance to the ellipse and the foci\n    float dellipse = sdEllipse(p, cen, theta, vec2(a, b));\n    float dfoci = min(length(p - foci[0]), length(p - foci[1])) - 0.04;\n\n    // distance to the medians\n    float dlines = 1e5;\n    dlines = min(dlines, dseg(p, A, (B+C)/2.));\n    dlines = min(dlines, dseg(p, B, (A+C)/2.));\n    dlines = min(dlines, dseg(p, C, (B+A)/2.));\n\n    // inside the ellipse/between ellipse and triangle/outside the triangle\n    float sgn = dellipse < 0. ? -2. : (dtri < 0. ?  0. : 1.);\n\n    // get voltage at this point\n    float volt = getVoltage(p, A, B, C);\n    float ssl = sl;\n\n    vec2 e = vec2(8./clamp(iResolution.y, 300., 800.), 0);\n    float fxl = getVoltage(p + e.xy, A, B, C);\n    float fxr = getVoltage(p - e.xy, A, B, C);\n    float fyt = getVoltage(p + e.yx, A, B, C);\n    float fyb = getVoltage(p - e.yx, A, B, C);\n\n    // color the region between voltage contours\n    vec3 col = vec3(0.4, 0.7, 0.4) - sgn*vec3(0.2, 0., 0.2)*ssl/palNum;\n    // dissipate the colors by doing some rotation\n    col = rotHue(col, -(min(ssl/palNum, 0.85))*12.+1.);\n    // darken the edges\n    col *= max(1. - (abs(fxl - fxr) + abs(fyt - fyb))*10., 0.);\n    // make some highlight\n    fxl = getVoltage(p + e.xy*1.5, A, B, C);\n    fyt = getVoltage(p + e.yx*1.5, A, B, C);\n    col += vec3(.9, .7, 1.)*(max(volt - fyt, 0.) + max(volt - fxl, 0.)\n                             + max(volt - fxr, 0.) + max(volt - fyb, 0.))*ssl;\n    // draw the triangle\n    col *= smoothstep(0.005, 0.005+2.0*sf, abs(dtri)-0.01);\n    // draw the ellipse\n    col *= smoothstep(0.005, 0.005+2.0*sf, abs(dellipse)-0.005);\n    // draw the medians\n    col *= smoothstep(0.005, 0.005+2.0*sf, abs(dlines)-0.002);\n    // draw the segment connecting the foci\n    col = mix(col, vec3(0.91, 0.1, 0.1), 1.-smoothstep(0., 0.005+2.*sf, dseg(p, foci[0], foci[1])-0.01));\n\n    // decorate the vertices and foci\n    vec2[3] verts; verts[0] = A; verts[1] = B; verts[2] = C;\n    float lw = 0.02;\n\n    for (int i=0; i<3; i++)\n    {\n        float dv = length(p - verts[i]) - .12;\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dv))*.5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv));\n        col = mix(col, vec3(1, .7, .6), 1. - smoothstep(0., sf, dv + lw*1.6));\n        float cro = sdCross(p - verts[i], vec2(0.06, 0.012), 0.01);\n        cro = abs(cro);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, cro - lw));\n    }\n    for (int i=0; i<2; i++)\n    {\n        float dv = length(p - foci[i]) - .07;\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dv))*.5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv));\n        col = mix(col, vec3(.4, .6, 1.), 1. - smoothstep(0., sf, dv + lw*1.2));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv + .075 - lw));\n    }\n    \n    col *= 1.25 - 0.2*length(p);\n    \n    fragColor = vec4(sqrt(max(col, 0.)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4scfR2","date":"1525866410","viewed":28106,"name":"Mobius trans in hyper 3-space","username":"neozhaoliang","description":"This shader is based on Roice Nelson's work at https://www.shadertoy.com/view/MstcWr","likes":63,"published":3,"flags":16,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Keyboard control:\n    \n    Key 1 turn on/off applying the Mobius transformation\n    Key 2 turn on/off applying the elliptic rotation\n    Key 3 turn on/off applying the hyperbolic scaling\n    Key 4 turn on/off showing the Riemann sphere\n*/\n\n#define PI  3.1415926536\n#define E_  2.71828118285\n\n// Raymarching constants\n#define AA               1\n#define MIN_TRACE_DIST   0.01\n#define MAX_TRACE_STEPS  255\n#define PRECISION        1e-5\n#define FAR              100.\n\n// Animation speed\n#define anim_speed (iTime * .5)\n#define hue_speed  (iTime * .3)\n\n// grid and cone size\nconst vec2 polar_grid = vec2(0.4, PI / 7.0);\nconst vec2 cone_angle = normalize(vec2(1.5, 1.0));\n\n// Intensity constants\nconst float intensity_divisor = 40000.;\nconst float intensity_factor_max = 7.2;\nconst float center_intensity = 12.;\nconst float dist_factor = 3.;\nconst float ppow = 1.9;\n\n// Color constants\nconst float center_hue = 0.5;\nconst float center_sat = 0.18;\n\n// shape constants\nconst float strong_factor = 7.;\nconst float weak_factor = 1.;\nconst vec2 star_hv_factor = vec2(30, 1);\nconst vec2 star_diag_factor = vec2(30, 1);\n//const vec2 star_hv_factor = vec2(9.0, 0.3);\n//const vec2 star_diag_factor = vec2(12.0, 0.6);\n\n\n// b_apply: apply Mobius transformation or not\n// b_elliptic: apply rotation or not\n// b_hyperbolic: apply scaling or not\n// b_parabolic is true if b_elliptic and b_parabolic are both false\n// b_loxodromic is true if b_elliptic and b_parabolic are both true\nbool b_apply = true;\nbool b_elliptic = true;\nbool b_hyperbolic = true;\nbool b_riemann = true;  // action on Riemman sphere or not\nbool b_parabolic, b_loxodromic;\n\n// hsv to rgb conversion\nvec3 hsv2rgb(vec3 hsv)\n{\n    const vec3 p = vec3(0.0, 2.0/3.0, 1.0/3.0);\n    hsv.yz = clamp(hsv.yz, 0.0, 1.0);\n    return hsv.z*(0.63*hsv.y*(cos(2.*PI*(hsv.x + p)) - 1.0) + 1.0);\n}\n\n// Conversion between Euclidean distance and hyperbolic distance\n// in upper half space. They are inverse of each other.\nfloat eucToHyp(float d) { return log(d); }\nfloat hypToEuc(float d) { return pow(E_, d); }\n\n// 2d rotation\nvec2 rot2d(vec2 p, float a) { return cos(a) * p + sin(a) * vec2(p.y, -p.x); }\n\n// 1d and 2d rectangular grids\nfloat grid1d(float x, float size)\n{\n    return mod(x + 0.5 * size, size) - 0.5 * size;\n}\n\nvec2 grid2d(vec2 p, vec2 size)\n{\n    return mod(p + 0.5 * size, size) - 0.5 * size;\n}\n\n// 2d polar grids\nvec2 polarGrid(vec2 p, vec2 size)\n{\n    float theta = atan(p.y, p.x);\n    float r = eucToHyp(length(p));\n    return grid2d(vec2(r, theta), size);\n}\n\n/*\n * Complex arithmetic\n*/\nvec2 cmul(vec2 z, vec2 w)\n{\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w)\n{\n    return vec2(z.x * w.x + z.y * w.y, -z.x * w.y + z.y * w.x) / dot(w, w);\n}\n\nvec2 csqrt(vec2 z)\n{\n    float r2 = dot(z, z);\n    float r = sqrt(sqrt(r2));\n    float angle = atan(z.y, z.x);\n    return r * vec2(cos(angle / 2.0), sin(angle / 2.0));\n}\n\n/*\n * Quaternion arithmetic\n*/\nvec4 qmul(vec4 p, vec4 q)\n{\n    return vec4(p.x * q.x - dot(p.yzw, q.yzw),\n                p.x * q.yzw + q.x * p.yzw + cross(p.yzw, q.yzw));\n}\n\nvec4 qdiv(vec4 p, vec4 q)\n{\n    return qmul(p, vec4(q.x, -q.yzw) / dot(q, q));\n}\n\n/*\n * Mobius transformation z --> (Az + B) / (Cz + D)\n*/\nstruct Mobius\n{\n    vec2 A, B, C, D;\n};\n\nconst Mobius mob = Mobius(\n    vec2(1, 0),\n    vec2(-1, 0),\n    vec2(1, 0),\n    vec2(1, 0)\n);\n\n// Apply Mobius transformation on complex plane\nvec2 applyMobius(vec2 z)\n{\n    vec2 z1 = cmul(mob.A, z) + mob.B;\n    vec2 z2 = cmul(mob.C, z) + mob.D;\n    return cdiv(z1, z2);\n}\n\n// Apply Mobius transformation on upper half space as quaternions\n// (x, y, z) --> (x + yi + zj + 0k)\nvec4 applyMobius(vec4 p)\n{\n    vec4 p1 = qmul(vec4(mob.A, 0., 0.), p) + vec4(mob.B, 0., 0.);\n    vec4 p2 = qmul(vec4(mob.C, 0., 0.), p) + vec4(mob.D, 0., 0.);\n    return qdiv(p1, p2);\n}\n\nfloat applyMobius(inout vec3 p)\n{\n    if (!b_apply)\n        return 1.0;\n\n    p = applyMobius(vec4(p, 0)).xyz;\n    float scale = length(p);\n    return scale > 1.0 ? 1.0 / scale : scale;\n}\n\n// A Mobius transformation of hyperbolic type is conjugate to a pure scaling\nvoid trans_hyperbolic(inout vec2 p)\n{\n    float d = eucToHyp(length(p)) - anim_speed * polar_grid.x;\n    // This avoids running out of resolution.\n    d = grid1d(d, polar_grid.x);\n    p = normalize(p) * hypToEuc(d);\n}\n\n// A Mobius transformation of elliptic type is conjugate to a pure rotation\nvoid trans_elliptic(inout vec2 p)\n{\n    p = rot2d(p, anim_speed * polar_grid.y);\n}\n\n// A Mobius transformation of parabolic type is conjugate to a pure translation\nvoid trans_parabolic(inout vec2 p)\n{\n    p.x += iTime * polar_grid.x / 3.;\n}\n\n// signed distance function for sphere kissing at y=0 with radius r\nfloat sdSphere(vec3 p, float r) { p.y -= r; return length(p) - r; }\n// signed distance functions for plane y=0 and y=c\nfloat sdPlane(vec3 p) { return p.y; }\nfloat sdPlane(vec3 p, float c) { return p.y - c; }\n// a cone in the upper hyperbolic space may be a usual cone at the origin\n// or a Dupin cyclide with its two horns on the plane\nfloat sdCone(vec3 p)\n{\n    float t = 1.0;\n    if (b_apply)\n    {\n        t = applyMobius(p);\n        p = normalize(p);\n    }\n    float q = length(p.xz);\n    return dot(cone_angle, vec2(q, -p.y)) * t;\n}\n\n// signed distance function for parabolic case\nfloat sdScene1(vec3 p)\n{\n    return b_apply ? min(sdPlane(p), sdSphere(p, 1.0)) : sdPlane(p, 0.5);\n}\n\n// signed distance function for elliptic/hyperbolic case\nfloat sdScene2(vec3 p)\n{\n    if (b_riemann)\n        return min(sdPlane(p), sdSphere(p, 1.));\n\n    return min(sdPlane(p), sdCone(p));\n}\n\nvec3 getColor(vec2 p, float pint)\n{\n    float sat = 0.75 / pow(pint, 2.5) + center_sat;\n    // change hue by time\n    float hue2 = b_parabolic ?\n        hue_speed - length(p.y) / 5.0 :\n        hue_speed - eucToHyp(length(p)) / 7.0;\n    float hue = center_hue + hue2;\n    return hsv2rgb(vec3(hue, sat, pint)) + pint / 3.;\n}\n\nfloat getIntensity1(vec2 p)\n{\n    float dist = length(p);\n    float disth = length(p * star_hv_factor);\n    float distv = length(p * star_hv_factor.yx);\n\n    vec2 q = 0.7071 * vec2(dot(p, vec2(1.)), dot(p, vec2(1., -1.)));\n    float dist1 = length(q * star_diag_factor);\n    float dist2 = length(q * star_diag_factor.yx);\n\n    // Middle point star intensity\n    float pint1 = .5 / (dist * dist_factor + 0.015)\n        + strong_factor / (distv * dist_factor + 0.01)\n        + weak_factor / (disth * dist_factor + 0.01)\n        + weak_factor / (dist1 * dist_factor + 0.01)\n        + weak_factor / (dist2 * dist_factor + 0.01);\n\n    return center_intensity * intensity_factor_max * pow(pint1, ppow) / intensity_divisor;\n}\n\nfloat getIntensity2(vec2 p)\n{\n    float angle = atan(polar_grid.x, polar_grid.y);\n    float dist  = length(p);\n    float disth = length(p * star_hv_factor);\n    float distv = length(p * star_hv_factor.yx);\n\n    vec2 q1 = rot2d(p, angle);\n    float dist1 = length(q1 * star_diag_factor);\n    vec2 q2 = rot2d(p, -angle);\n    float dist2 = length(q2 * star_diag_factor);\n\n    float pint1 = 1. / (dist * dist_factor  + .5);\n    if (b_loxodromic)\n    {\n        pint1 = strong_factor / (dist2 * dist_factor + 0.01)\n            + weak_factor  / (dist1 * dist_factor + 0.01)\n            + weak_factor / (disth * dist_factor + 0.01)\n            + weak_factor / (distv * dist_factor + 0.01);\n    }\n    else if (b_elliptic)\n    {\n        pint1 += weak_factor / (distv * dist_factor + 0.01) +\n            strong_factor / (disth * dist_factor + 0.01) +\n            weak_factor / (dist1 * dist_factor + 0.01) +\n            weak_factor / (dist2 * dist_factor + 0.01);\n    }\n    else\n    {\n        pint1 += weak_factor / (disth * dist_factor + 1.) +\n            strong_factor / (distv * dist_factor + .01) +\n            weak_factor / (dist1 * dist_factor + 0.01) +\n            weak_factor / (dist2 * dist_factor + 0.01);\n    }\n    return intensity_factor_max * pow(pint1, ppow) / intensity_divisor * center_intensity * 3.;\n}\n\nfloat map(vec3 pos)\n{\n    return b_parabolic ? sdScene1(pos) : sdScene2(pos);\n}\n\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(.003, 0);\n    float d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n    float d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n    float d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    float d = map(p) * 2.;\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k)\n{\n    const int maxShadeIterations = 20;\n    float res = 1.0;\n    float t = tmin;\n    for (int i = 0; i < maxShadeIterations; i++)\n    {\n        float h = map(ro + rd * t);\n        res = min(res, smoothstep(0., 1., k * h / t));\n        t += clamp(h, 0.01, 0.2);\n        if (abs(h) < 1e-4 || t > tmax)\n            break;\n    }\n    return clamp(res+0.15, 0.0, 1.0);\n}\n\n\n// iq's ambient occlusion\nfloat calcAO(vec3 p, vec3 n)\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        float h = 0.01 + 0.15 * float(i) / 4.0;\n        float d = map(p + h * n);\n        occ += (h - d) * sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat trace(vec3 ro, vec3 rd, out vec2 p, out float pint)\n{\n    float depth = MIN_TRACE_DIST;\n    float dist;\n    vec3 pos;\n    for (int i = 0; i < MAX_TRACE_STEPS; i++)\n    {\n        pos = ro + rd * depth;\n        dist = map(pos);\n        if (dist < PRECISION || depth >= FAR)\n            break;\n        depth += dist;\n    }\n    if (b_parabolic)\n    {\n        if (b_apply)\n            pos /= dot(pos, pos);\n\n        p = pos.xz;\n        trans_parabolic(pos.xz);\n        pos.xz = grid2d(pos.xz, vec2(polar_grid.x / 2.0));\n        pint = getIntensity1(pos.xz);\n    }\n    else\n    {\n        applyMobius(pos);\n        p = pos.xz;\n        if (b_hyperbolic) trans_hyperbolic(pos.xz);\n        if (b_elliptic)   trans_elliptic(pos.xz);\n        pos.xz = polarGrid(pos.xz, polar_grid);\n        pint = getIntensity2(pos.xz);\n    }\n    return depth;\n}\n\n// ACES tone mapping\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 tonemap(vec3 color)\n{\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\n\nconst int CHAR_1 = 49;\nconst int CHAR_2 = 50;\nconst int CHAR_3 = 51;\nconst int CHAR_4 = 52;\n\n// https://www.shadertoy.com/view/lsXGzf\nbool keypress(int code) \n{\n\treturn texelFetch(iChannel0, ivec2(code,2), 0).x != 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    b_apply = !keypress(CHAR_1);\n    b_elliptic = !keypress(CHAR_2);\n    b_hyperbolic = !keypress(CHAR_3);\n    b_riemann = keypress(CHAR_4);\n\n    b_parabolic = !(b_elliptic || b_hyperbolic);\n    b_loxodromic = b_elliptic && b_hyperbolic;\n    vec3 ro = vec3(-2., 4.2, 5.0);\n    //ro.xz = rot2d(ro.xz, iTime*0.3);\n    vec3 lookat = vec3(0.0, 0.6, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = normalize(cross(r, f));\n    vec3 tot = vec3(0);\n    vec3 lp = ro + vec3(.2, .8, -0.2);\n    \n\n    for (int ii = 0; ii < AA; ii++)\n    {\n        for (int jj = 0; jj < AA; jj++)\n        {\n            vec2 offset = vec2(float(ii), float(jj)) / float(AA);\n            vec2 uv = (fragCoord + offset) / iResolution.xy;\n            uv = 2.0 * uv - 1.0;\n            uv.x *= iResolution.x / iResolution.y;\n            vec3 rd = normalize(uv.x * r + uv.y * u + 4.0 * f);\n            vec2 p;\n            float pint;\n            float t = trace(ro, rd, p, pint);\n            if (t >= 0.0)\n            {            \n                vec3 col = tonemap(4.0 * getColor(p, pint));\n                vec3 pos = ro + rd * t;\n                vec3 nor = getNormal(pos);\n                vec3 ld = lp - pos;\n                float dist = max(length(ld), 0.001);\n                ld /= dist;\n                float at = 2.2/(1. + dist*.1 + dist*dist*.05); \n                float ao = calcAO(pos, nor);\n                float sh = softShadow(pos, ld, 0.04, dist, 8.);\n         \n                float diff = clamp(dot(nor, ld), 0.0, 1.0);\n                float spec = max( 0.0, dot( reflect(-ld, nor), -rd));\n\t            spec = pow(spec, 50.0);\n                tot += diff * 2.5 * col + vec3(0.6, 0.8, 0.8) * spec * 2.;\n                tot *= ao * sh * at;\n            }\n            if(t >= FAR)\n                lp = normalize(lp - ro - rd*FAR);\n \n            vec3 bg = mix(vec3(.5, .7, 1), vec3(1, .5, .6), .5 - .5*lp.y) * .3;\n            tot = mix(clamp(tot, 0., 1.), bg, smoothstep(0., FAR-2., t));\n        }\n    }\n    tot /= float(AA * AA);\n    fragColor = vec4(sqrt(clamp(tot, 0., 1.)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"fljfRm","date":"1651976315","viewed":1176,"name":"Mobius transformation revealed","username":"neozhaoliang","description":"A recreation of the video: https://www-users.cse.umn.edu/~arnold/moebius/","likes":20,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis animation shows that Mobius transformations are rigid motions\nof \"admissible\" spheres in the upper half-space.\n\nA sphere is called admissible if its highest point is above the xy-plane.\n\nThe procedure involves four steps:\n\n1. Map the complex plane (xy) to the sphere using inverse\n   stereographic projection.\n   \n2. Translate and rotate the sphere, but keeping it admissible..\n\n3. Map the sphere back to the complex plane using stereographic projection, \n   with the north pole being the highest point of the sphere.\n\n4. Combine steps 1-3 to get a Mobius transformation of the complex plane.\n   All Mobius transformations can be obtained this way.\n   \n\nIn this process,\n\n1. moving the sphere in the xy-plane is a translation of the complex plane.\n\n2. moving it along the z-axis is a scaling of the complex plane.\n\n3. rotating it in the xy-plane is a rotation of the complex plane.\n\n4. rotating 180 degress about the x-axis is the inverse map z -> 1/z.\n\n\nFor a given Mobius transformation M and a chosen initial position\nof the sphere, the rigid motion that gives M is unique.\n*/\n\n#define PI            3.141592654\n#define TAU           (2.0*PI)\n#define ROT(a)        mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)       (0.5 + 0.5*cos(x))\n#define DOT2(x)       dot(x, x)\n#define TIME          iTime\n#define Y             vec3(0, 1, 0)\n#define NPOLE(sph)    (sph.xyz + sph.w * Y)\n#define PLANE         vec4(0, 1, 0, 1.5)\n#define aa            (2.0/iResolution.y)\n\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float grid_max     = 3.0;\nconst float grid_size    = 0.5;\nconst vec3  light_pos    = vec3(3, 4, 3);\nconst vec3  light_dir    = normalize(light_pos);\nconst vec3  sky0_color   = HSV2RGB(vec3(0.0, 0.65, 0.95)); \nconst vec3  sky1_color   = HSV2RGB(vec3(0.6, 0.5, 0.5));\nconst vec3  grid_color   = HSV2RGB(vec3(0.6, 0.6, 1.0)); \nconst vec3  light_color  = 12.0*HSV2RGB(vec3(0.6, 0.5, 1.0));\nconst vec3  plane_color  = HSV2RGB(vec3(0.7, 0.125, 1.0/32.0)); \n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvec2 mod2(inout vec2 p, vec2 size) {\n    vec2 id = floor(p / size);\n    p = mod(p + size*0.5, size) - size*0.5;\n    return id;\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n    return -(dot(ro, p.xyz) + p.w) / dot(rd, p.xyz);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 58.233))) * 13758.5453);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, vec4 sph, float k) {\n    vec3 oc = ro - sph.xyz;\n    float r2 = sph.w * sph.w;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - r2;\n    float h = b * b - c;\n    float d = -sph.w + sqrt(max(0.0, r2 - h));\n    float t = -b - sqrt(max(0.0, h));\n    return (t < 0.0) ? 1.0 : smoothstep(0.0, 1.0, k * d / t);\n}\n\nfloat bounce() {\n    float t = fract(TIME) - 0.5;\n    return 0.25 - t*t;\n}\n\nvec2 path(float t) {\n    const float rad = 0.8;\n    return rad * vec2(cos(t), sin(t));\n}\n\nvoid rot(inout vec3 sp) {\n    sp.xy    *= ROT(TIME*0.3);\n    sp.xz    *= ROT(TIME*0.3);\n}\n\nvec3 diffuse(vec3 pos, vec3 nor) {\n    float ll = DOT2(light_pos - pos);\n    vec3  ld = normalize(light_pos - pos);\n    return light_color * max(dot(nor, ld), 0.0) / ll * 20.;\n}\n\nvec3 restrictColor(vec2 p, vec3 col) {\n    float cond =  step(abs(p.x), grid_max);\n          cond *= step(abs(p.y), grid_max);\n    return mix(plane_color, col, cond);\n}\n\nvec3 planeToSphere(vec3 p, vec4 sph) {\n    vec3 N = NPOLE(sph);\n    vec3 rd = normalize(N - p);\n    float t = raySphere(p, rd, sph).x;\n    return p + rd*t;\n}\n\nvec3 sphereToPlane(vec3 p, vec4 sph, vec4 plane) {\n    vec3 N = NPOLE(sph);\n    vec3 rd = normalize(p - N);\n    float t = rayPlane(p, rd, plane);\n    return p + rd*t - sph.xyz;\n}\n\nvec3 computeGridColor(vec3 pos, vec2 pp) {\n    vec2 z = pp;\n    mod2(z, vec2(grid_size));\n    float d1 = smin(abs(z.x), abs(z.y), .05);\n    float gm = PCOS(-TAU * TIME + 0.25 * TAU * length(pos.xz));\n    \n    z = pp;\n    vec2 id = mod2(z, vec2(grid_size / 6.));\n    float d2 = min(abs(z.x), abs(z.y)) - 0.0125;\n    \n    float n  = hash21(id);\n    float n2 = n * 0.3 + .7;\n    if (n < 0.1 * sin(TIME) + 0.1)\n        n = 1E6;\n    else\n        n = 0.0;\n  \n    vec3 gcol = vec3(0);\n    gcol = mix(gcol, HSV2RGB(vec3(hash21(id), 1.0, n2)), vec3(n > 1.0));\n    gcol -= 0.2*vec3(2.0, 1.0, 1.0)*exp(-100.0*max(d2+0.01, 0.0));\n    gcol = mix(gcol, 6.*vec3(0.1, 0.09, 0.125), smoothstep(-aa, aa, -(d2+0.0075)));\n    gcol += 0.5*vec3(2.0, 1.0, 1.0)*exp(-900.0*abs(d2-0.00125));\n\n    vec3 col = clamp(gcol, -1.0, 1.0);\n\n    gcol = mix(vec3(0.75), 2.0*vec3(3.5, 2.0, 1.25), gm);\n    gcol *= exp(-mix(400.0, 100.0, gm) * max(d1-0.0125, 0.0));\n    gcol *= 0.3;\n    col = mix(col, gcol, smoothstep(-aa, aa, -d1 + 0.0125)); \n    return col;\n}\n\n\nvec3 renderBackground(vec3 ro, vec3 rd, vec4 sph, float T) {\n    vec3 sky = smoothstep(1.0, 0.0, rd.y) * sky1_color + \n               smoothstep(0.5, 0.0, rd.y) * sky0_color;\n               \n    sky += pow(max(dot(rd, light_dir), 0.0), 800.0)*light_color;\n    if (rd.y >= 0.0)\n        return sky;\n        \n    float ht  = 1.0 + 0.2 * smoothstep(-0.05, 0.1, bounce());\n    float t   = rayPlane(ro, rd, vec4(vec3(0.0, ht, 0.0), 0.5));\n    vec3 pos  = ro + t*rd;\n    vec3 dif  = diffuse(pos, Y);\n    float sha = softShadow(pos, normalize(light_pos - pos), sph, 2.0);\n    dif *= sha;\n    \n    vec3 sp = planeToSphere(pos, sph);\n    sp -= sph.xyz;\n    rot(sp);\n    sp += sph.xyz;\n    vec3 pp = sphereToPlane(sp, sph, PLANE);\n\n    vec3 col = computeGridColor(pos, pp.xz);\n    col = restrictColor(pp.xz, col); \n    col += plane_color * dif;\n    col /= (1.0 + 0.25 * DOT2(pos.xz)); \n    col = mix(sky, col, tanh(500.0/(1.0 + DOT2(pos))));\n    return col;\n}\n\nvec3 renderBall(vec3 ro, vec3 rd, vec4 sph, vec2 st, float T) {\n    vec3 pos  = ro + st.x*rd;\n    vec3 sp   = pos - sph.xyz;\n    vec3 nor  = normalize(sp);\n    vec3 ref  = reflect(rd, nor);\n    vec3 dif  = diffuse(pos, nor);\n    rot(sp);\n    pos       = sp + sph.xyz;\n    vec3 pp   = sphereToPlane(pos, sph, vec4(0, 1, 0, 0.5));\n    vec3 rcol = renderBackground(pos, ref, sph, T);\n    \n    vec2 z = pp.xz;\n    mod2(z, vec2(grid_size));\n    float d1 = smin(abs(z.x), abs(z.y), .05);\n    float gm = PCOS(-TAU * T + 0.25 * TAU * length(pp));\n    \n    z = pp.xz;\n    vec2 id = mod2(z, vec2(grid_size / 6.));\n    float d2 = min(abs(z.x), abs(z.y)) - 0.0125;\n    \n    float n = hash21(id);\n    float n2 = n * 0.3 + .7;\n    if (n < 0.1 * sin(T) + 0.1)\n        n = 1E6;\n    else\n        n = 0.0;\n  \n    vec3 gcol = vec3(0);\n    gcol = mix(gcol, HSV2RGB(vec3(hash21(sin(id * TAU)), 1.0, n2)), vec3(n > 1.0));\n    gcol -= 0.2*vec3(2.0, 1.0, 1.0)*exp(-100.0*max(d2+0.01, 0.0));\n    gcol = mix(gcol, 6.*vec3(0.09, 0.1, 0.125), smoothstep(-aa, aa, -(d2+0.0075)));\n    gcol += 1.*vec3(2.0, 1.0, 1.0)*exp(-900.0*abs(d2-0.00125));\n    vec3 col = clamp(gcol, -1., 1.);\n    gcol = mix(vec3(0.75), 2.0*vec3(3.5, 2.0, 1.25), gm);\n    gcol *= exp(-mix(400.0, 100.0, gm) * max(d1-0.0125, 0.0));\n    gcol *= 0.3;\n    col = mix(col, gcol, smoothstep(-aa, aa, -d1 + 0.0125));\n    col = restrictColor(pp.xz, col);\n    col += rcol * 0.175;\n    return col;\n}\n\nvec3 render(vec2 p, vec2 uv) {\n    vec2 ph = path(TIME * 0.5);\n    vec3 ro = vec3(2.5, 1.0, 0.);\n    ro.xz *= ROT(TIME / 3.);\n    vec3 lookat = vec3(0., 0., 0.);\n    vec3 forward = normalize(lookat - ro);\n    vec3 right = normalize(cross(forward, Y));\n    vec3 up = normalize(cross(right, forward));\n    vec3 rd = normalize(p.x*right + p.y*up + 2.0*forward);\n    vec4 sph = vec4(vec3(0., bounce(), 0.), 0.5);\n    sph.xz += ph;\n    vec2 st = raySphere(ro, rd, sph);\n    if (st.x >= 0.0)\n        return renderBall(ro, rd, sph, st, TIME);\n    else\n        return renderBackground(ro, rd, sph, TIME);\n}\n\nvec3 postprocess(vec3 col, vec2 q) {\n    col = pow(clamp(col, 0.0, 1.0), vec3(1.0/2.2)); \n    col = col*0.6 + 0.4*col*col*(3.0 - 2.0*col);\n    col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n    col *= 0.5 + 0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.7);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 col = render(p, uv);\n\n    //float fi = smoothstep(0.0, 5.0, TIME);\n    //col = mix(vec3(0.0), col, fi);\n\n    col = postprocess(col, uv);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ss2cz3","date":"1643890479","viewed":538,"name":"Neo three worlds","username":"neozhaoliang","description":"Motivated by Escher's artwork \"three worlds\", try to combine spherical, Euclidean, hyperbolic geometry in one scene. See three worlds through the mirrors at the same time.","likes":22,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 get_floor_color(vec2 z) {\n    // Modify P, Q, R to change the tiling\n    const float P = 2.;\n    const float Q = 3.;\n    const float R = 7.;\n    const float cp = cos(PI / P), sp = sin(PI / P);\n    const vec2 mB = vec2(-cp, sp);\n    const float k1 = cos(PI / Q);\n    const float k2 = (cos(PI / R) + cp * k1) / sp;\n    const float rad = 1. / sqrt(k1 * k1 + k2 * k2 - 1.);\n    const vec2 cen = vec2(k1 * rad, k2 * rad);\n    const vec2 v0 = vec2(0, cen.y - sqrt(rad * rad - cen.x * cen.x));\n    const vec2 n_ = vec2(-mB.y, mB.x);\n    const float b_ = dot(cen, n_);\n    const float c_ = dot(cen, cen) - rad * rad;\n    const float k_ = b_ + sqrt(b_ * b_ - c_);\n    const vec2 m0 = k_ * n_;\n\n    vec2 p = square_to_disc(z);\n    vec2 invCtr = vec2(1);\n    float t = 1. / dot(p -invCtr, p - invCtr);\n    p = mix(invCtr, p, t);\n    p.x = -p.x;\n    p = rot2(iTime/12.)*p;\n\n    if (length(p) > 1.)\n        p /= dot(p, p);\n\n    float count = 0.;\n    for (int i = 0; i < MAX_TILING_REFLECTIONS; i++) {\n        if (p.x < 0.) {\n            p.x = -p.x;\n            count += 1.;\n        }\n        float k = dot(p, mB);\n        if (k < 0.) {\n            p -= 2. * k * mB;\n            count += 1.;\n        }\n        \n        float d = length(p - cen) - rad;\n        if (d < 0.) {\n            p -= cen;\n            p *= rad * rad / dot(p, p);\n            p += cen;\n            count += 1.;\n        }\n    }\n    \n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    ln = min(ln, lBox(p, vec2(0), v0, .007));    \n    ln = min(ln, lBox(p, vec2(0), m0, .007));\n    ln = min(ln, length(p - cen) - rad - 0.007);\n\n    ln2 = min(ln2, lBox(p, vec2(0), m0, .007));\n    pnt = min(pnt, length(p - v0)); \n    pnt = min(pnt, length(p - m0)); \n    \n    float sf = 2. / iResolution.y;\n    float rnd = smoothstep(.8, .97, sin(iTime*.5 + count)*.5 + .5);\n        \n    vec3 oCol = .55 + .45*cos(count * PI / 4. + vec3(0, 1, 2));\n    oCol = mix(oCol*.1, clamp(oCol*3.5, 0., 1.), rnd);\n     \n    float pat = smoothstep(0., .25, abs(fract(ln2*50. - .2) - .5)*2. -.2);\n   \n    float sh = clamp(.65 + ln/v0.y*4., 0., 1.);\n    vec3 col = min(oCol*(pat*.2 + .9)*sh, 1.);\n\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - BlackRegionSize)));\n\n    pnt -= .032;\n    pnt = min(pnt, length(p) - .032);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnt));\n    \n    rnd = smoothstep(.8, .97, sin(iTime * 1.5)*.5 + .5);\n    vec3 blink = vec3(1.3, 0.25, 0.35);\n    blink = mix(blink * 0.5, blink * 2.2, rnd);\n    col = mix(col, blink, 1. - smoothstep(0., sf, pnt + .02));\n    return col;\n}\n\nvec3 get_ceil_color(vec2 p) {\n    const float P = 3.;\n    const float Q = 3.;\n    const float R = 3.;\n    const float cp = cos(PI / P), sp = sin(PI / P);\n    const float cq = cos(PI / Q), cr = cos(PI / R);\n    const vec2 mB = vec2(-cp, sp);\n    const vec3 mC = vec3(-cr, -(cq + cr * cp) / sp, 1.);\n    const vec2 v0 = vec2(0, -1./mC.y);\n    const float k_ = mB.x / mB.y;\n    const float x_ = 1. / (k_ * mC.y - mC.x);\n    const float y_ = -k_ * x_;\n    const vec2 m0 = vec2(x_, y_);\n    \n    p = rot2(iTime/12.)*p;\n\n    float count = 0.;\n    for (int i = 0; i < MAX_TILING_REFLECTIONS; i++) {\n        if (p.x < 0.) {\n            p.x = -p.x;\n            count += 1.;\n        }\n        float k = dot(p, mB);\n        if (k < 0.) {\n            p -= 2. * k * mB;\n            count += 1.;\n        }\n        \n        k = dot(vec3(p, 1.), mC);\n        if (k < 0.) {\n            p -= 2. * k * mC.xy;\n            count += 1.;\n        }\n    }\n    \n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    //ln = min(ln, lBox(p, vec2(0), v0, .05));    \n    //ln = min(ln, lBox(p, vec2(0), m0, .05));\n    ln = min(ln, lBox(p, v0, m0, .05));\n\n    ln2 = min(ln2, lBox(p, vec2(0), m0, .007));\n    pnt = min(pnt, length(p - v0)); \n    pnt = min(pnt, length(p - m0)); \n    \n    float sf = 2. / iResolution.y;\n    float rnd = smoothstep(.8, .97, sin(iTime + count * PI)*.5 + .5);\n        \n    vec3 oCol = .55 + .45*cos(count * PI / 8. + vec3(0, 1, 2)).yzx;\n    oCol = mix(oCol*.1, clamp(oCol*1.5, 0., 1.), rnd);\n     \n    float pat = smoothstep(0., .25, abs(fract(ln2*15. - .2) - .5)*2. -.2);\n   \n    float sh = clamp(.65 + ln/v0.y*4., 0., 1.);\n    vec3 col = min(oCol*(pat*.2 + .9)*sh, 1.);\n\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - BlackRegionSize * 16.)));\n\n    pnt -= .15;\n    pnt = min(pnt, length(p) - .15);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnt));\n    \n    rnd = smoothstep(.4, .5, sin(iTime)*.5 + .5);\n    vec3 blink = vec3(1.3, 0.25, 0.35);\n    blink = mix(blink * 0.5, blink * 2.2, rnd);\n    col = mix(col, blink, 1. - smoothstep(0., sf, pnt + .02));\n    return col;\n}\n\n// distance to the four sides of mirrors \nfloat sdMirror(vec3 p) {\n    vec2 d = RoomSize.xz - abs(p.xz);\n    return min(d.x, d.y);\n}\n\n// the floor and the ceil\nfloat sdFloor(vec3 p) {\n    return RoomSize.y - abs(p.y);\n}\n\n// wood framework\nfloat sdRoomFrame(vec3 p) {\n    return sdBoxFrame(p, RoomSize, vec3(RoomFrameSize));\n}\n\nfloat sdMirrorFrame(vec3 p) {    \n    float d1 = sdBoxFrame(p, RoomSize, WindowFrameSize.xyy);\n    float d2 = sdBoxFrame(p, RoomSize, WindowFrameSize.yxy);\n    float d3 = sdBoxFrame(p, RoomSize, WindowFrameSize.yyx);\n    return min(d1, min(d2, d3));\n}\n\n// polyhedra with faces and edges\nvec2 sdPolyhedra(vec3 p) {\n    p *= RotObj;\n    p = fold_spherical(p);\n    p -= v0S;\n    float d1 = sdPolyhedraFaces(p);\n    float d2 = sdPolyhedraEdges(p);\n    float d = min(d1, d2);\n    float id = d1 < d2 ? 1. : 2.;\n    return vec2(d, id);\n}\n\nfloat sdScene(vec3 p) {\n    float d1 = sdMirror(p);\n    float d2 = sdFloor(p);\n    float d3 = sdRoomFrame(p);\n    float d4 = sdMirrorFrame(p);\n    float d5 = sdPolyhedra(p).x;\n    return min(d1, min(d2, min(d3, min(d4, d5))));\n}\n\nvec3 trace(vec3 pos, vec3 rd) {\n    float h = 1.0;\n    for (int i = 0; i < MAX_TRACE_STEPS; i++) {\n        if (h < PRECISION)\n            break;\n        h = sdScene(pos);\n        pos += rd * min(h, MAX_MARCH_STEP);\n    }\n    return pos;\n}\n\nfloat soft_shadow(vec3 pos, vec3 lp) {\n    const float softness = 16.;\n    const float shadowStartDistance = .1;\n    const int shadowLoopCount = 16;\n\n    vec3 ld = lp - pos;\n    float ldist = max(length(lp), 0.001);\n    ld /= ldist;\n    float epsilon = .001;\n    float t = shadowStartDistance;\n    float h = 1.;\n    float shade = 1.0;\n    for (int i=0; i < shadowLoopCount; i++ ) {\n        if (h < epsilon || t > ldist)\n            break;\n        h = sdScene(pos + ld * t);\n        shade = min(shade, smoothstep(0.0, 1.0, softness*h/t));\n        t += h;\n    }\n    return clamp(shade + 0.25, 0., 1.);\n}\n\nvec3 get_normal(vec3 p) {\n    const vec2 d = vec2(-1, 1) * .001;\n    return normalize(\n            sdScene(p + d.xxx)*d.xxx +\n            sdScene(p + d.yyx)*d.yyx +\n            sdScene(p + d.yxy)*d.yxy +\n            sdScene(p + d.xyy)*d.xyy);\n}\n\nstruct Light {\n    vec3 pos;\n    vec3 col;\n};\n\nLight lights[] = Light[] (\n    Light(vec3(2.5, 2.2, 2.5), vec3(1) * 5.),\n    Light(vec3(-1, -.5, -1), vec3(1)),\n    Light(vec3(-2.5,-1.9,-2.5), vec3(0, .3, 1))\n);\n\nvoid ray_bounce(in vec3 p,\n                in vec3 rd,\n                out vec3 diffuse,\n                out vec3 ref_dir,\n                out vec3 bounceTint,\n                in vec3 normal) {\n\n    vec3 bCol = vec3(0);\n    for( int i=0; i < lights.length(); i++ ) {\n        vec3 ld = lights[i].pos - p;\n        float ldist = max(length(ld), 0.001);\n        ld /= ldist;\n        float diff = max(0., dot(normal, ld));\n        float at = 1.5 / (1. + ldist * 0.3 + ldist * ldist * 0.1);\n        float sh = soft_shadow(p, lights[i].pos);\n        bCol += lights[i].col * sh * (.2 + diff) * at;\n    }\n    // ambient light\n    vec3 ao = vec3(.03,.05,.07);\n    // sample SDF to approximate occlusion\n    ao *= exp2(min(0., sdScene(p + normal * 0.3) / 0.3 - 1.));\n    ao *= exp2(min(0., sdScene(p + normal * .15) / .15 - 1.));\n    ao *= exp2(min(0., sdScene(p + normal * .07) / .07 - 1.));\n    bCol += ao;\n    \n    // https://www.shadertoy.com/view/tlBGR1\n    vec3 albedo = vec3(.3,.5,.6) * .4;\n    vec4 specLevel = vec4(0.9, 0.9, 0.9, 1);\n\n    float d1 = sdMirror(p);\n    float d2 = sdFloor(p);\n    float d3 = sdRoomFrame(p);\n    float d4 = sdMirrorFrame(p);\n    vec2 sdPoly = sdPolyhedra(p);\n    float d5 = sdPoly.x, id = sdPoly.y;\n    float d = min(d1, min(min(d2, d3), min(d4, d5)));\n    \n    if (d == d3) {  // room frame\n        albedo = vec3(.25);\n        specLevel = vec4(0.08);\n    }\n    else if (d == d4) {  // mirror border\n        albedo = vec3(0.01);\n        specLevel = vec4(0.2, 0.2, 0.2, 1.);\n    }\n    else if (d == d5) {  // polyhedra\n        if (id == 2.) {  // polyhedra edges\n            albedo = vec3(0.15, 0.3, 0.8);\n            specLevel = vec4(vec3(0.05), 1.);\n        }\n        else {  // polyhedra faces\n            specLevel = vec4(0.7);\n        }\n    }\n    else if (d == d2) {  // floor and ceil\n        vec2 uv = p.xz;\n        albedo = p.y < 0. ? get_floor_color(uv / (RoomSize.x - RoomFrameSize))\n                          : get_ceil_color(uv * 2.);\n        float ior = 1.33;\n        float schlick = pow((ior - 1.) / (ior + 1.), 2.);\n\t    specLevel = vec4(vec3(schlick), 1);\n    \tspecLevel *= mix(.2, .7, p.x);\n    \tnormal = normalize(normal + (texture(iChannel0, vec2(p.xz) /2.).rgb - .5) * .005);\n    }\n    \n    float fresnel = pow(dot(normal, rd) + 1., 5.);\n    vec3 spec = mix(specLevel.xyz, specLevel.www, fresnel);\n    \n    bounceTint = spec;\n    diffuse = albedo * (vec3(1) - spec) * bCol;\n    ref_dir = reflect(rd, normal);\n}\n\nvec3 get_ray_color(vec3 ro, vec3 rd) {\n    vec3 pos = ro;\n    vec3 tint = vec3(1);\n\n    vec3 col = vec3(0);\n    for (int i = 0; i < MAX_RAY_BOUNCES; i++) {\n        pos = trace(pos, rd);\n        vec3 normal = get_normal(pos);\n        vec3 bounceTint, diffuse;\n        ray_bounce(pos, rd, diffuse, rd, bounceTint, normal);\n        pos += normal * PRECISION * 2.;\n        col += diffuse * tint;\n        tint *= bounceTint;\n        if (length(tint) < .01)\n            break;\n    }\n    return col;\n}\n\nmat3 camera_matrix(vec3 eye, vec3 lookat, vec3 up) {\n    vec3 forward = normalize(lookat - eye);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    return mat3(right, up, -forward);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init_spherical();\n\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 movement = vec2(iTime * 0.2, sin(iTime * 0.2) * 0.5);\n    vec3 eye = 2.5 * vec3(\n        cos(movement.x) * cos(movement.y),\n        0.5*sin(movement.y),\n        sin(movement.x) * cos(movement.y));\n    eye += vec3(1, 0.3, 1) * cos(vec3(0.75, 0.3, 0.2) * iTime);\n   \n    vec2 mouse = vec2(0);\n    if (iMouse.x > 0.) {\n        mouse = 2. * iMouse.xy / iResolution.y - 1.;\n        eye = rot_y(mouse.x) * rot_x(mouse.y) * eye;\n    }\n    vec3 lookat = vec3(0);\n    vec3 up = vec3(0, 1, 0);\n    mat3 M = camera_matrix(eye, lookat, up);\n    \n    vec3 ray = M * normalize(vec3(uv, -2.));\n    vec3 col = get_ray_color(eye, ray);\n    fragColor = vec4(clamp(sqrt(col), 0., 1.), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI  3.141592654\n#define BlackRegionSize  0.03\n#define L2(x)  dot(x, x)\n#define RotObj  rot_x(iTime/2.)*rot_z(iTime/3.)\n#define PolyhedraEdgeSize  0.02\n#define PolyhedraFaceOffset  0.\n#define RoomSize  vec3(5, 2.5, 5)\n#define RoomFrameSize  0.5\n#define WindowFrameSize vec2(RoomFrameSize*1.2, 0)\n#define MAX_TILING_REFLECTIONS 12\n#define MAX_TRACE_STEPS  128\n#define MAX_RAY_BOUNCES  15\n#define PRECISION        1e-3\n#define MAX_MARCH_STEP   1.0\n\nconst vec3 pqr_wythoff = vec3(5, 2, 3);\nconst vec3 bary = vec3(1, 1, 1);\n\nmat3 matS, triS;\nvec3 v0S;\n\nvoid init_spherical() {\n    vec3 c = cos(PI / pqr_wythoff);\n    float sp = sin(PI / pqr_wythoff.x);\n    vec3 m1 = vec3(1, 0, 0);\n    vec3 m2 = vec3(-c.x, sp, 0);\n    float x3 = -c.z;\n    float y3 = -(c.y + c.x*c.z)/sp;\n    float z3 = sqrt(1.0 - x3*x3 - y3*y3);\n    vec3 m3 = vec3(x3, y3, z3);\n    matS = mat3(m1, m2, m3);\n    triS[0] = normalize(cross(m2, m3));\n    triS[1] = normalize(cross(m3, m1));\n    triS[2] = normalize(cross(m1, m2));\n    v0S = normalize(bary * inverse(matS));\n}\n\nvec3 fold_spherical(vec3 p) {\n    for (int i = 0; i < 5; i++)\n    for (int j = 0; j < 3; j++) {\n        p -= 2. * min(dot(p, matS[j]), 0.) * matS[j];\n    }\n    return p;\n}\n\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n ) {\n    n = max(n * n, 0.001);\n    n /= (n.x + n.y + n.z ); \n\treturn (\n        texture(tex, p.yz) * n.x +\n        texture(tex, p.zx) * n.y +\n        texture(tex, p.xy) * n.z\n    ).xyz;\n}\n\nmat2 rot2(in float a) {\n    float c = cos(a), s = sin(a); return mat2(c, -s, s, c);\n}\n\nmat3 rot_x(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0,  0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\nmat3 rot_y(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n}\n\nmat3 rot_z(in float t) {\n    float cz = cos(t), sz = sin(t);\n    return mat3(cz, -sz, 0.,\n                sz, cz, 0.,\n                0., 0., 1.);\n}\n\nfloat sBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew) {\n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n// https://www.shadertoy.com/view/3ljcRh\n// I changed e to vec3 so it works for non-uniform edge size\nfloat sdBoxFrame(vec3 p, vec3 b, vec3 e) {\n    p = abs(p) - b;\n    vec3 q = abs(p + e) - e;\n    return min(min(\n        length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n        length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n        length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdPolyhedraEdges(vec3 p) {\n    float d = 1e5;\n    for (int i = 0; i < 3; i++) {\n        d = min(d, L2(p - min(0., dot(p, matS[i])) * matS[i]));\n    }\n\treturn sqrt(d) - PolyhedraEdgeSize;\n}\n\nfloat sdPolyhedraFaces(vec3 p) {\n   return max(dot(p, triS[0]), max(dot(p, triS[1]), dot(p, triS[2]))) - PolyhedraFaceOffset;\n}\n\n//complex multiplication\nvec2 cMul(vec2 a, vec2 b) {\n\treturn vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\n// complex inverse \nvec2 cDiv( vec2 a, vec2 b ) {\n  float d = dot(b, b);\n  return vec2(dot(a, b), a.y*b.x - a.x*b.y ) / d;\n}\n\n// complex inverse \nvec2 cInv(vec2 a) {\n\treturn vec2(a.x, -a.y) / dot(a, a);\n}\n\n// code below taken from @mla's https://www.shadertoy.com/view/Mlsfzs\nvoid sncndn(float u, float k2,\n            out float sn, out float cn, out float dn) {\n    float emc = 1.0 - k2;\n    float a = 1.0, b, c;\n    const int N = 4;\n    float em[N], en[N];\n    dn = 1.0;\n    for (int i = 0; i < N; i++) {\n        em[i] = a;\n        emc = sqrt(emc);\n        en[i] = emc;\n        c = 0.5*(a + emc);\n        emc *= a;\n        a = c;\n    }\n\n    u = c*u;\n    sn = sin(u);\n    cn = cos(u);\n    if (sn != 0.0) {\n        a = cn / sn;\n        c *= a;\n        for(int i = N - 1; i >= 0; i--) {\n            b = em[i];\n            a *= c;\n            c *= dn;\n            dn = (en[i] + a) / (b + a);\n            a = c/b;\n        }\n        a = 1.0 / sqrt(c*c + 1.0);\n        if (sn < 0.0)\n            sn = -a;\n        else\n            sn = a;\n        cn = c * sn;\n    }\n}\n\nvec2 cn(vec2 z, float k2) {\n  float snu, cnu, dnu, snv, cnv, dnv;\n  sncndn(z.x, k2, snu, cnu, dnu);\n  sncndn(z.y, 1.0-k2, snv, cnv, dnv);\n  return vec2(cnu * cnv, -snu*dnu*snv*dnv) / (1. - dnu*dnu*snv*snv);\n}\n\nvec2 square_to_disc(vec2 z) {     \n    z = cDiv(z, vec2(1));\n    z -= vec2(1, 0);\n    z *= 1.854;\n    z = cn(z, 0.5);\n    z = cMul(z, vec2(0.70711));\n    return z;\n}","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"fst3Rl","date":"1630480754","viewed":340,"name":"Poncelet-Blaschke triangle","username":"neozhaoliang","description":"This animation shows the connection between Poncelet's triangle and degree 3 Blaschke product.\n\nSee the book  \"Finding Ellipses: What Blaschke Products, Poncelet's Theorem,  and the Numerical Range Know about Each Other\".","likes":15,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Poncelet's triangle and degree 3 Blaschke product.\n\nA Blaschke product B(z) of degree n is an mapping of the unit disc D to itself and has the form\n\nB(z) = \\prod_{i=1}^n (z - a_i) / (1 - conjugate(a_i)*z) where a_i, i=1,2,...,n are all in D.\n\nB(z) preserves ∂D. Further more, for each point P on ∂D, there are n preimages\nz1, ..., zn on ∂D such that B(z1) = ... = B(zn) = P.\n\nNow fix n=3, and let a, b be complex numbers in D. For simplicity we choose a, b\nboth are reals and a is always the origin. Let\n\nB(z) = z * (z-a)/(1-a*z) * (z-b)/(1-b*z)\n\nSo B(z) is a Blaschke product of degree 3 and it has zeros at 0, a, b.\n\nThen for each point P on ∂D, the preimages z1, z2, z3 form an inscribed triagle\nABC of D, interestingly, ABC is also the circumscribe triangle of an ellipse\nwith foci at a and b:\n\n|z - a| + |z - b| = |1 - conjugate(a)*b|.\n\nIn the animtion P is colored yellow, z1, z2, z3 are colored pink.\n\nTo show that I'm not cheating, I choosed a, b and draw the ellipse using the\nexpression as above, then solve the cubic equation B(z) = P for P moving along\nthe circle and draw the triangle ABC. You can see the triangle does circumscribe\nthe ellipse!\n\nThis result generalizes to Blaschke product of degree n, the curve that the n-gon\ncircumscribes is a Poncelet curve.\n\n*/\n#define PI 3.141592653\n\nvec3 rotHue(vec3 p, float a) {\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n              mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n              mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\n    return clamp(p*hr, 0., 1.);\n}\n\n\nvec2 cmul(vec2 p, vec2 q) {\n    return vec2(p.x*q.x-p.y*q.y, p.x*q.y+p.y*q.x);\n}\n\n\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y, -z.x * w.y + z.y * w.x) / dot(w, w);\n}\n\nvec2 csqrt(vec2 p) {\n    float a = atan(p.y, p.x) / 2.;\n    return vec2(cos(a), sin(a)) * sqrt(length(p));\n}\n\nvec2 ccubrt(vec2 z) {\n    float r = length(z);\n    r = pow(r, 1./3.);\n    float angle = atan(z.y, z.x);\n    return r * vec2(cos(angle / 3.0), sin(angle / 3.0));\n}\n\nvec2 cpow2(vec2 z) {\n    return cmul(z, z);\n}\n\nvec2 cpow3(vec2 z) {\n    return cmul(z, cmul(z, z));\n}\n\nvoid solveCubic(float b, vec2 k, inout vec2 z1, inout vec2 z2, inout vec2 z3) {\n    vec2 t1 = vec2(2.*b*b*b, 0) - 9.*b*b*k;\n    vec2 t2 = cpow2(t1 + 27.*k);\n    vec2 t3 = 3.*b*k - vec2(b*b, 0);\n    vec2 t4 = 4.*cpow3(t3);\n    vec2 s1 = ccubrt(csqrt(t4 + t2) + 27.*k + t1);\n    vec2 s2 = cdiv(t3, s1);\n    z1 = 0.264566842 * s1 - 0.41997368 * s2 + vec2(b/3.,0.);\n    z2 = cmul(vec2(-0.132283421, 0.2291216), s1) + cmul(vec2(0.209998684, 0.36371), s2) + vec2(b/3., 0);\n    z3 = cmul(vec2(-0.132283421, -0.2291216), s1) + cmul(vec2(0.209998684, -0.36371), s2) + vec2(b/3., 0);\n}\n\n// distance from a 2d point p to a 2d segment (a, b)\nfloat dseg(vec2 p, vec2 a, vec2 b) {\n    vec2 v = b - a;\n    p -= a;\n    float t = clamp(dot(p, v)/dot(v, v), 0., 1.);\n    return length(p - t * v);\n}\n\nvec3 cubehelix(vec3 c) {\n    vec2 sc = vec2(sin(c.x), cos(c.x));\n    return c.z * (1.0 + c.y * (1.0 - c.z) * (\n        sc.x * vec3(0.14861, 0.29227, -1.97294) +\n        sc.y * vec3(1.78277, -0.90649, 0.0)\n        ));\n}\n\nvec3 rainbow(float t) {\n    return cubehelix(vec3(\n        2. * PI * t - 1.74533,\n        (0.25 * cos(2. * PI * t) + 0.25) * vec2(-1.5, -0.9) + vec2(1.5, 0.8)\n        ));\n}\n\n// iq's triangle signed distance function\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 ) {\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n\n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// ellipse signed distance function\nfloat sdEllipse( vec2 p, vec2 cen, in vec2 ab ) {\n    p -= cen;\n    vec2 pab = p / (ab * ab);\n    return (0.5 * dot(pab, p) - 0.5) / length(pab);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    float sf = 2. / iResolution.y;\n    vec2 p = uv * 1.1;\n\n    mat2 foci;\n    float b = sin(iTime) * 0.3 + 0.6;\n    // for a fixed ellipse, you can see each point on the unit cicle is a Poncelet point.\n    //float b = 0.6;\n    foci[0] = vec2(0);\n    foci[1] = vec2(b, 0);\n\n    vec2 k = vec2(cos(iTime), sin(iTime));\n    vec2 A, B, C;\n    solveCubic(b, k, A, B, C);\n\n    // distance to the triangle\n    float dtri = sdTriangle(p, A, B, C);\n    float dcirc = length(p) - 1.;\n\n    vec2 cen = vec2(b*0.5, 0);\n    vec2 ab = vec2(0.5, sqrt(1.-b*b)/2.);\n    float dellipse = sdEllipse(p, cen, ab);\n    float dfoci = min(length(p), length(p - foci[1])) - 0.04;\n\n    float sgn = dellipse < 0. ? -2. : (dtri < 0. ?  0. : 1.);\n\n    vec3 col = vec3(0.4, 0.7, 0.4) - sgn*vec3(0.2, 0., 0.2);\n    col = rotHue(col, sgn + 5.);\n    const float numlines = 30.;\n    for (float i=0.; i<numlines; i+=1.0) {\n        vec2 Q = vec2(cos(i/numlines*2.*PI), sin(i/numlines*2.*PI));\n        vec2 z1, z2, z3;\n        solveCubic(b, Q, z1, z2, z3);\n        float ds = dseg(p, z1, z2);\n        ds = min(ds, dseg(p, z2, z3));\n        ds = min(ds, dseg(p, z3, z1));\n        col = mix(col, rainbow(i/numlines), 1.-smoothstep(0., 0.003+2.*sf, ds));\n    }\n    col *= smoothstep(0.005, 0.005+2.0*sf, abs(dtri)-0.01);\n    col *= smoothstep(0.005, 0.005+2.0*sf, abs(dcirc)-0.01);\n    col *= smoothstep(0.005, 0.005+2.0*sf, abs(dellipse)-0.005);\n    col = mix(col, vec3(0.91, 0.1, 0.1), 1.-smoothstep(0., 0.005+2.*sf, dseg(p, foci[0], foci[1])-0.01));\n\n    // decorate the vertices and foci\n    mat4x2 verts; verts[0] = A; verts[1] = B; verts[2] = C, verts[3] = k;\n    float lw = 0.02;\n    for (int i=0; i<4; i++) {\n        float dv = length(p - verts[i]) - .08;\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dv))*.5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv));\n        if (i < 3)\n            col = mix(col, vec3(1, .5, .8), 1. - smoothstep(0., sf, dv + lw*1.6));\n        else\n            col = mix(col, vec3(1, 1., .2), 1. - smoothstep(0., sf, dv + lw*1.6));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv + .08 - lw));\n    }\n    for (int i=0; i<2; i++) {\n        float dv = length(p - foci[i]) - .06;\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dv))*.5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv));\n        col = mix(col, vec3(.4, .6, 1.), 1. - smoothstep(0., sf, dv + lw*1.2));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv + .065 - lw));\n    }\n\n    col *= 1.25 - 0.4*length(p);\n\n    fragColor = vec4(sqrt(max(col, 0.)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ctVGRR","date":"1683457379","viewed":1161,"name":"Reflective Wythoff polyhedra","username":"neozhaoliang","description":"Another reflective polyhedra shader","likes":35,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nWythoff reflective polyhedra, code adapted from\n\n    https://www.shadertoy.com/view/tlX3WH\n\nI basically rewrote the polyhera construction and raytracing part there,\nand kept the rendering part untouched.\n\nThe code should look simpler now?\n\nTo play with:\n\n1. Change pqr and truncation_type to see other polyhedron.\n2. use 'INSIDE_VIEW' to view from the inside.\n3. use 'DUAL' to view the dual polyhera.\n   pqr=(2, 3, 4) and truncation_type=(0, 0, 1) will give the\n   rhombic dodecahedron that tiles the whole inner space.\n*/\n#define PI                3.141592654\n#define L2(x)             dot(x, x)\n#define EDGE_THICKNESS    0.05\n#define MAX_TRACE_STEPS   128\n#define MAX_RAY_BOUNCES   12\n#define EPSILON           1e-4\n#define FAR               20.\n#define min3(x, y, z)     (min(x, min(y, z)))\n#define max3(x, y, z)     (max(x, max(y, z)))\n\n\n//#define INSIDE_VIEW\n\n//#define DUAL\n\nconst vec3 pqr = vec3(2, 3, 5);   // (2, 3, 3), (2, 3, 4)\nconst vec3 truncation_type = vec3(1, 1, 1);\n\nconst float size = 1.35;  // polyhera size\n\nmat3 M;  // normals of reflection mirrors\nmat3 T;  // three vertices of the fundamental triangle  \nvec3 v0; // initial vertex\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nvoid init() {\n    vec3 c = cos(PI / pqr);\n    float sp = sin(PI / pqr.x);\n    vec3 m1 = vec3(1, 0, 0);\n    vec3 m2 = vec3(-c.x, sp, 0);\n    float x3 = -c.z;\n    float y3 = -(c.y + c.x*c.z)/sp;\n    float z3 = sqrt(1.0 - x3*x3 - y3*y3);\n    vec3 m3 = vec3(x3, y3, z3);\n    M = mat3(m1, m2, m3);\n    T[0] = normalize(cross(m2, m3));\n    T[1] = normalize(cross(m3, m1));\n    T[2] = normalize(cross(m1, m2));\n    v0 = normalize(truncation_type * inverse(M)) * size;\n#ifdef DUAL\n    #define proj(p, n)  (length(p - dot(p, n) * n))\n    float scale = min3(proj(v0, m1), proj(v0, m2), proj(v0, m3));\n    v0 /= scale;\n#endif\n}\n\nvec3 fold(vec3 p) {\n    for (int i = 0; i < 5; i++)\n    for (int j = 0; j < 3; j++) {\n        p -= 2. * min(dot(p, M[j]), 0.) * M[j];\n    }\n    return p;\n}\n\nfloat dSegment(vec3 p, vec3 a, vec3 b) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  float d = length(pa - ba * h);\n  return d;\n}\n\nvec3 distEdges(vec3 p) {\n    p = fold(p);\n#ifdef DUAL\n\tvec3 ed = vec3(1e5);\n    vec3 a = T[0] / dot(T[0], v0) * size;\n    vec3 b = T[1] / dot(T[1], v0) * size;\n    vec3 c = T[2] / dot(T[2], v0) * size;\n\tif(bool(truncation_type.x))\n        ed.x = dSegment(p, b, c);\n\tif(bool(truncation_type.y))\n        ed.y = dSegment(p, c, a) ;\n\tif(bool(truncation_type.z))\n        ed.z = dSegment(p, a, b);\n\treturn ed;\n#else\n    p -= v0;\n    vec3 ed;\n    for (int i = 0; i < 3; i++) {\n        ed[i] = L2(p - min(0., dot(p, M[i])) * M[i]);\n    }\n\treturn sqrt(ed);\n#endif\n}\n\nfloat map(vec3 p) {\n    p = fold(p);\n#ifdef DUAL\n    return dot(p, v0) - size;\n#else\n    p -= v0;\n    return max(dot(p, T[0]), max(dot(p, T[1]), dot(p, T[2])));\n#endif\n}\n\nfloat trace(vec3 pos, vec3 rd, bool outside) {\n    float t = 0.0;\n    float sgn = outside ? 1.0 : -1.0;\n    for (int i = 0; i < MAX_TRACE_STEPS; i++) {\n        float d = map(pos + t * rd);\n        if (abs(d) < EPSILON)\n            return t;\n        if (t > FAR)\n            break;\n        t += sgn * d  * 0.9;\n    }\n    return FAR;\n}\n\nvec4 wallColor(vec3 dir, vec3 nor, vec3 eds) {\n    float d = min3(eds.x, eds.y, eds.z);\n    \n    // Texturing of walls\n    vec3 albedo = texture(iChannel1, vec2(eds.xy * 2.0)).rgb;\n    albedo = pow(albedo, vec3(2.2)) * 0.5;\n    \n    // Simple diffuse lighting\n    float lighting = 0.2 + max(dot(nor, vec3(0.8, 0.5, 0.0)), 0.0);\n    \n    if (dot(dir, nor) < 0.0) {\n        // Outer walls, just add a black line to hide seams\n        float f = clamp(d * 1000.0 - 3.0, 0.0, 1.0);\n        albedo = mix(vec3(0.01), albedo, f);\n        return vec4(albedo * lighting, f);\n    } else {\n        // Inner walls, add fancy lights\n        float m = max3(eds.x, eds.y, eds.z);\n        vec2 a = fract(vec2(d, m) * 40.6) - 0.5;\n        float b = 1.0 - sqrt(dot(a, a));\n        b = 0.2 / (dot(a, a) + 0.2);\n        \n        float lightShape = 1.0 - clamp(d * 100.0 - 2.0, 0.0, 1.0);\n        lightShape *= b;\n        \n        vec3 emissive = vec3(3.5, 1.8, 1.0);\n        return vec4(mix(albedo * lighting, emissive, lightShape), 0.0);\n    }\n\treturn vec4(1.0);\n}\n\n\nmat3 camera_matrix(vec3 eye, vec3 lookat, vec3 up) {\n    vec3 forward = normalize(lookat - eye);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    return mat3(right, up, -forward);\n}\n\nvec3 get_normal( in vec3 pos ) {\n    vec3 eps = vec3(0.001,0.0,0.0);\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nvec3 background(vec3 dir) {\n\tvec3 col = texture(iChannel0, dir).rgb;\n    col = pow(col, vec3(2.2));\n    float origLuma = dot(col, vec3(0.2126, 0.7152, 0.0722)) * 0.7;\n    return 2.5 * col / (1.0 - origLuma);\n}\n\nvec3 drawRay(vec3 pos, vec3 rd) {\n    vec3 color = vec3(0.0);\n#ifndef INSIDE_VIEW\n    float t = trace(pos, rd, true);\n    if (t == FAR) {\n    \treturn background(rd);\n    }\n    pos = pos + t * rd;\n    vec3 nor = get_normal(pos);\n    vec3 reflDir = reflect(rd, nor);\n    vec3 bgColor = pow(background(reflDir), vec3(1.0));\n    float fresnel = 0.04 + 0.96 * pow(1.0 - max(dot(rd, -nor), 0.0), 5.0);\n    color += bgColor * fresnel;\n    vec3 eds = distEdges(pos);\n    float d = min3(eds.x, eds.y, eds.z);\n    if (d < EDGE_THICKNESS) {\n        vec4 wc = wallColor(rd, nor, eds);\n    \treturn color * wc.a + wc.rgb;\n    }\n#endif\n    vec3 transmittance = vec3(1.0);\n    for (int i = 0; i < MAX_RAY_BOUNCES; i++) {\n        float t = trace(pos, rd, false);\n        pos = pos + t * rd;\n        vec3 eds = distEdges(pos);\n        vec3 nor = get_normal(pos);\n    \tfloat d = min3(eds.x, eds.y, eds.z);\n        if (d < EDGE_THICKNESS) {\n        \treturn color + transmittance * wallColor(rd, nor, eds).rgb;\n        }\n        rd = reflect(rd, nor);\n        pos += rd * 0.005;\n        transmittance *= vec3(0.4, 0.7, 0.7);\n    }\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init();\n    vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    vec2 move = vec2(iTime * 0.2, sin(iTime * 0.2) * 0.5);\n\n#ifdef INSIDE_VIEW\n    float radius = 0.1;\n#else\n    float radius = 2.0;\n#endif\n    vec3 eye = radius * vec3(\n        cos(move.x)*cos(move.y),\n        sin(move.y),\n        sin(move.x)*cos(move.y)\n    );\n    \n    vec2 mouse = vec2(0);\n    if (iMouse.x > 0.)\n        mouse = 2. * iMouse.xy / iResolution.y - 1.;\n    eye = rotateY(mouse.x) * rotateX(-mouse.y) * eye;\n    \n    vec3 lookat = vec3(0);\n    vec3 up = vec3(0, 1, 0);\n    vec3 forward = normalize(lookat - eye);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    vec3 ray = normalize(uv.x*right + uv.y*up + forward * 1.0);\n    vec3 color = drawRay(eye, ray);\n    color = color / (color * 0.5 + 0.5);\n    color = pow(color, vec3(1.0 / 2.2));\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"fdK3RD","date":"1631196606","viewed":421,"name":"Rouché - winding number theorem","username":"neozhaoliang","description":"Rouché's theorem in complex analysis","likes":20,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nWinding number theorem:\n\nA man is walking his dog along closed paths represented by f(z) and g(z),\nrespectively. If the man holds the leash tight enough to prevent the dog\nfrom touching the tree throughout their walk, they will circle the tree the\nsame number of times when they return to their initial positions.\n\nRouché's theorem:\n\nWhen f and g are analytic functions in a region that encloses the unit circle S\nand |f(z)| > |f(z) - g(z)| whenever z in S (here |f-g| is the length of the leash),\nthen f(S) and g(S) will circle the origin the same number of times, and this number\nequals the number of their zeros inside S.\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = (fragCoord - iResolution.xy*.5) / iResolution.y;\n    \n    vec2 p = uv * 9.;\n    p -= vec2(1.5, .5); // adjust the postion of the curves\n    vec2 O = vec2(0.5);\n\n    // Smoothing factor.\n    float sf = 8./iResolution.y;\n\n    // background color\n    vec3 col = vec3(1, .92, .75);\n    float hatch = doHatch(uv, iResolution.y);\n    col *= hatch*.2 + .8;\n    \n    vec2 e = vec2(.015, .03);\n    float le = length(e);\n\n    // curve width\n    float lw = .02;\n\n    float dc1 = dcurve(p, 0);\n    float dc2 = dcurve(p, 1);\n\n    float tA = mod(iTime*.2, 2.*PI);\n    float tB = max(0., tA + sin(iTime) * .1 - .1);\n    vec2 A0 = map1(0.), B0 = map2(0.);\n   \n    vec2 A = map1(tA);\n    vec2 B = map2(tB);\n    float dA = length(p - A) ;\n    float dB = length(p - B) ;\n\n    // dash grid lines\n    vec2 p1 = uv * 6.;\n    p1 -= floor(p1) + 0.5;\n    float bord = max(abs(p1.x), abs(p1.y))-0.49;\n    vec2 q1 = abs(mod(p1, 1./8.) - .5/8.);\n    float lines = (min(q1.x, q1.y) - .5/8./3.);\n    bord = min(bord, lines);\n    bord = step(0., bord);\n    \n    float dlink = dSegment(p, A, B);\n    // noisy background pattern\n    col *= fbm(p*48.)*.4 + .6;\n    // draw the grid lines\n    col = mix(col, vec3(0), bord*.8);\n\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*16., dc2))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*8., dc2 - lw*2.4));\n    col = mix(col, colorB, (1. - smoothstep(0., sf*4., dc2 - lw*1.6))*.8);\n\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*16., dc1))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*8., dc1 - lw*2.4));\n    col = mix(col, colorA, 1. - smoothstep(0., sf*4., dc1 - lw*1.6));\n\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*.7, dlink - 0.005))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*.7, dlink - .008));\n    col = mix(col, vec3(1, 1, .3), 1. - smoothstep(0., sf*.7, dlink));\n\n    lw *= 12.;\n\n    dA -= lw;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dA - 0.02))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dA - 0.04));\n\tcol = mix(col, colorA, 1. - smoothstep(0., sf, dA));\n    dA += .12;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dA - .03));\n\tcol = mix(col, vec3(1, .8, .6), 1. - smoothstep(0., sf, dA)); \n    dA += .08;\n\tcol = mix(col, vec3(0), (1. - smoothstep(0., sf, dA))); \n\n    dB -= lw;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dB - 0.02))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dB - 0.04));\n\tcol = mix(col, colorB, 1. - smoothstep(0., sf, dB));\n    dB += .12;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dB - .03));\n\tcol = mix(col, vec3(1, .8, .6), 1. - smoothstep(0., sf, dB)); \n    dB += .08;\n\tcol = mix(col, vec3(0), (1. - smoothstep(0., sf, dB)));\n    \n    float dA0 = length(p - A0);\n    dA0 -= lw * .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dA0 - 0.02))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dA0 - 0.04));\n\tcol = mix(col, colorA, 1. - smoothstep(0., sf, dA0));\n    dA0 += .06;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dA0));\n    \n    float dB0 = length(p - B0);\n    dB0 -= lw * .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dB0 - 0.02))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dB0 - 0.04));\n\tcol = mix(col, colorB, 1. - smoothstep(0., sf, dB0));\n    dB0 += .06;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dB0));\n \n    vec2 q = p - O;\n    float ci = length(q) - .7;\n    float sh = max(.75 - ci*4., 0.);\n    col = mix(col, vec3(0), (ss(sf*6., ci - .04))*.5);\n    col = mix(col, vec3(0), ss(sf, ci));\n    col = mix(col, vec3(1, .7, .4)*(ci + sh*sh*.1 + .5), ss(sf, ci + .03));\n    col = mix(col, col*1.6, ss(sf*4., ci + .15));\n   \tcol = mix(col, vec3(0), ss(sf, abs(ci + .1) - .01));   \n    col = mix(col, vec3(0), (ss(sf, length(q) - .18))*.5);\n    col = mix(col, vec3(0), ss(sf, abs(length(q) - .12) - .01));\n    col = mix(col, vec3(0), ss(sf, length(q) - .05));\n        \n    A -= O;\n    B -= O;\n    vec2 qA = rot2(atan(A.y, A.x-.5) -PI/2.) * q;\n    vec2 qB = rot2(atan(B.y, B.x)-PI/2.) * q;\n    float indA = distLine(qA - vec2(0, -.005), qA - vec2(0, .46)) - .01;\n    float indB = distLine(qB - vec2(0, -.005), qB - vec2(0, .3)) - .01;\n    \n    const float rad = .45;\n    const float aNum = 12.;\n    q = rot2(3.14159/aNum)*q;\n    float a = atan(q.y, q.x);\n    float ia = floor(a/6.283*aNum) + .5; // .5 to center cell.\n    ia = ia*6.283/aNum;\n    q = rot2(ia)*q;\n    q.x -= rad;\n        \n    // Markings.\n    float mark = sBox(q, vec2(.04, .022), 0.);\n    col = mix(col, vec3(.5), ss(sf, mark - .015));\n    col = mix(col, vec3(0), ss(sf, mark));\n        \n    // Indicator.        \n    col = mix(col, vec3(0), ss(sf, indA - .025));\n    col = mix(col, colorA, ss(sf, indA));\n    col = mix(col, vec3(0), ss(sf, indB - .025));\n    col = mix(col, colorB, ss(sf, indB));\n    \n    p -= vec2(-7.5, -3.);\n    p *= .8;\n    float ds1 = min(abs(length(p) - 1.), sqrt(dSegment(p, vec2(0), vec2(1, 0))));\n    col = mix(col, vec3(0.2), ss(sf, ds1 - 0.025));\n    float dr = distRoots(p);\n    col = mix(col, vec3(0.5, 0, 0), ss(sf, dr - .05));\n    col = mix(col, vec3(0.2), ss(sf, length(p - vec2(1, 0)) - .1));\n    \n    vec2 P = vec2(cos(tA), sin(tA));\n    float dP = length(p - P);\n    \n    dP -= lw * .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dP - 0.02))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dP - 0.04));\n\tcol = mix(col, colorA, 1. - smoothstep(0., sf, dP));\n\n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./16.)*1.05;\n\n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define NUM_SEGMENTS  100\n#define PI            3.141592653\n#define ss(a, b)      (1. - smoothstep(0., a, b))\n#define colorA   vec3(1, 0.2, 0.2)\n#define colorB   vec3(0.3, 1., .6)\n\n\nmat2 rot2(in float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n// complex multiplication\nvec2 cmul(vec2 p, vec2 q) {\n    return vec2(p.x*q.x-p.y*q.y, p.x*q.y+p.y*q.x);\n}\n\n// complex division\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y, -z.x * w.y + z.y * w.x) / dot(w, w);\n}\n\nvec2 transform(vec2 z, vec2 a) {\n    return cdiv(z - a, vec2(1, 0) - cmul(vec2(a.x, -a.y), z));\n}\n\nfloat n2D(vec2 p) {\n    const vec2 s = vec2(1, 113);\n    vec2 ip = floor(p); p -= ip;\n    vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);\n    p = p*p*(3. - 2.*p);\n    h = fract(sin(h)*43758.5453);\n    h.xy = mix(h.xy, h.zw, p.y);\n    return mix(h.x, h.y, p.x);\n}\n\nfloat fbm(vec2 p) {\n    return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\nfloat distLine(vec2 a, vec2 b) {\n    b = a - b;\n    float h = clamp(dot(a, b)/dot(b, b), 0., 1.);\n    return length(a - b*h);\n}\n\nfloat sBox(vec2 p, vec2 b, float r) {\n    vec2 d = abs(p) - b + r;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - r;\n}\n\nfloat dot2(in vec2 v) {\n    return dot(v, v);\n}\n\nfloat dSegment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return dot2(pa - ba*clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0));\n}\n\nvec2 map1(float t) {\n    const float s = 2.;\n    vec2 p = vec2(cos(t), sin(t));\n    vec2 z = transform(p, vec2(.5, .7));\n    z = cmul(z, transform(p, vec2(-.6, 0.5)));\n    z = cmul(z, transform(p, vec2(-0.4)));\n    z = cmul(z, p - vec2(s, s));\n    return z;\n}\n\nfloat distRoots(vec2 p) {\n    float d = length(p - vec2(.5, .7));\n    d = min(d, length(p - vec2(-0.6, 0.5)));\n    d = min(d, length(p - vec2(-0.4)));\n    return d;\n}\n\nvec2 map2(float t) {\n    return map1(t) + vec2(cos(t) * 1.6, sin(t) * 1.2);\n}\n\nfloat dcurve(vec2 p, int index) {\n    float h = 0.05;\n    float t = 0.0;\n\n    vec2  a = index == 0 ? map1(t) : map2(t);\n    float d = dot2(p - a);\n\n    for(int i = 0; i < NUM_SEGMENTS; i++) {\n        vec2  b = index == 0 ? map1(t) : map2(t);\n        d = min(d, dSegment(p, a, b));\n        t += clamp(0.01*length(a-p)/length(a-b), 0.01, 0.15);\n        a = b;\n    }\n    return sqrt(d);\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453);\n}\n\nfloat doHatch(vec2 p, float res) {\n    p *= res/16.;\n    float hatch;\n    float hRnd = hash21(floor(p*6.) + .73);\n    if(hRnd>.66) hatch = hRnd;\n    else if (hRnd > 0.33) hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.);\n    else hatch = clamp(sin((p.x + p.y)*3.14159*200.)*2. + .5, 0., 1.);\n    return hatch;\n}\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"3tccWf","date":"1609987591","viewed":1938,"name":"Uniform 3D Euclidean Honeycombs","username":"neozhaoliang","description":"3D Wythoffian uniform honeycombs and their duals in Euclidean space, a flythrough version.","likes":26,"published":3,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nUniform honeycombs and their duals\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis program draws uniform honeycombs and their duals in 3D Euclidean space.\n\nYou can learn more about these honeycombs on the Wikipedia page for convex\nuniform honeycombs:\n\n    https://en.wikipedia.org/wiki/Convex_uniform_honeycomb\n\nThe main rendering procedure is based on the work of @shane:\n\n    https://www.shadertoy.com/view/4l2cD3.\n    \nI particularly like the metallic effects in many of his examples.\n\nThe honeycomb data is taken from @mla's work at\n\n    https://www.shadertoy.com/view/WsfcRn.\n    \nI'm also grateful to @mla for helpful discussions.\n\n@mla's code is a great reference for the general Wythoff construction,\nwhich saved me a lot of hard (and even boring) computations.\nIf you have any difficulty understanding this code, I recommend referring to\n@mla's version, as the ideas are the same.\n\nThe trickiest part of this program is to render the octagonal edges\n(or other prism-like shapes) instead of just cylinder edges.\nThis is due to the fact that Wythoff construction may change the distance\nbetwwen a point and the cell edges: In the Wythoff construction, one need to\nreflect a point P across the mirrors repeatly until it falls within a certain\nregion, known as the \"fundamental domain\". Say its final location in the fundamental\ndomain is Q. In the cases that edges have prism-like shapes, the distances d(P, edges)\nand d(Q, edges) may not be equal. This results in annoying artifacts in the final image.\nIt took me 90% of the time to figure out how to tackle this. My solution is\nbrute-force: just render more copies of the fundamental domain. This made the\ncode look ugly and the program take a bit long time to compile, but it worked and\nlooked right in the end.\n*/\n\n// Honeycomb type. 0 for affine A3, 1 for affine B3, 2 for affine C3\n#define LATTICE   1\n\n// Barycentric coordinates of the initial vertex v0 in the fundamental tetrahedron.\n// This determines the truncation type of the honeycomb.\nconst vec4 T = vec4(1, 1, 1, 0);\n\n// use another color style\n#define GOLD_STYLE\n\n// render the dual honeycomb?\n//#define DUAL\n\n\n// initial vertex\nvec3 v0;\n\n// M is the four reflection mirrors of the fundamental tetrahedron,\n// M_inv is the inverse of M.\nmat4 M, M_inv;\n\n// The four vertices of the fundamental tetrahedron and the four mirror images of v0 about\n// the four mirrors\nmat4x3 V, E;\n\nconst float tbsize = 0.055;\n\n// object id\nvec3 objIDs;\n\nfloat glow;\n\nvec3 do_reflect(vec3 p, vec4 n) {\n    vec4 q = vec4(p, 1.);\n    return p - 2. * dot(q, n) * n.xyz;\n}\n\nvec3 rA(vec3 p) { return do_reflect(p, M[0]); }\nvec3 rB(vec3 p) { return do_reflect(p, M[1]); }\nvec3 rC(vec3 p) { return do_reflect(p, M[2]); }\nvec3 rD(vec3 p) { return do_reflect(p, M[3]); }\n\n\nvoid init() {\n\n    const float s = 0.70710678;    // sqrt(2) / 2\n\n#if LATTICE == 0\n    // affine A3 lattice\n    //\n    // A     C\n    //  o---o\n    //  |   |\n    //  o---o\n    // D     B\n    M = mat4(vec4(-s, -s, 0, 2.*s),\n             vec4(s, -s, 0, 0),\n             vec4(0, s, -s, 0),\n             vec4(0, s, s, 0));\n             \n    V = mat4x3(vec3(0, 0, 0),\n               vec3(2, 0, 0),\n               vec3(1, 1, -1),\n               vec3(1, 1, 1));\n\n#elif LATTICE == 1\n    // affine B3 lattice\n    //          C\n    //         o\n    //     4  /\n    // A o---o B\n    //        \\\n    //         o\n    //          D\n    M = mat4(vec4(0, 0, 1, 0),\n             vec4(0, s, -s, 0),\n             vec4(s, -s, 0, 0),\n             vec4(-s, -s, 0, 2.*s));\n             \n    V = mat4x3(vec3(1, 1, 1),\n               vec3(1, 1, 0),\n               vec3(2, 0, 0),\n               vec3(0, 0, 0));\n\n// affine C3 lattice\n#else\n    //   4       4\n    // o---o---o---o\n    // A   B   C   D\n    M = mat4(vec4(0, 0, 1, 0),\n             vec4(0, s, -s, 0),\n             vec4(s, -s, 0, 0),\n             vec4(-1, 0, 0, 1));\n    \n    V = mat4x3(vec3(0, 0, 0),\n               vec3(1, 0, 0),\n               vec3(1, 1, 0),\n               vec3(1, 1, 1));\n\n#endif\n\n    M_inv = inverse(M);\n    vec4 v4 = T * M_inv;\n    v4 /= v4.w;\n    v0 = v4.xyz;\n    for (int i = 0; i < 4; i++) {\n        E[i] = v0 - 2. * dot(v4, M[i]) * M[i].xyz;\n    }\n}\n\n\n#define FAR     80.\n#define PI      3.141592654\n\nfloat sgn(float x) { return x > 0. ? 1. : -1.; }\n\n// Camera path as a function of time t.\n// I think it's unlikely to devise an universal path that flies through all\n// honeycombs without hitting the lattice.\nvec3 camPath(float t) { return vec3(t, 0, 0); }\n\n// A mirror is active if and only if the initial vertex v0 is not on it,\n// or equivalently, the barycentric coordinate with respect to this mirror is non-zero.\nbool isActive(int k) { return T[k] != 0.0; }\n\n// try to reflect a point p about mirror with normal `n`, if p and the fundamental domain\n// are on the different sides of the mirror\nvec4 try_reflect(vec4 p, vec4 n, inout int flips) {\n    float k = dot(p, n);\n    if (k < 0.) {\n        flips += 1;\n        p.xyz -= 2. * k * n.xyz;\n    }\n    return p;\n}\n\nvec2 rot2d(vec2 p, float a) { return cos(a) * p + sin(a) * vec2(p.y, -p.x); }\n\n\n// fold a point p into the fundamental domain.\n// we return the final position of p, but also track an intermediate state of p for\n// handling dual cases.\nvec3 fold(inout vec3 p, inout int flips) {\n    \n    vec4 q;\n\n#if LATTICE == 0\n\n    p = mod(p + 2., 4.) - 2.;\n    q = vec4(p, 1);\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            q = try_reflect(q, M[j], flips);\n        }\n    }\n\n#elif LATTICE == 1\n   \n    p = mod(p + 2., 4.) - 2.;\n    flips += int(p.x < 0.0) + int(p.y < 0.0) + int(p.z < 0.0);\n    p = abs(p);\n    q = vec4(p, 1);\n    for (int i = 0; i < 2; i++) {\n        q = try_reflect(q, M[3], flips);\n        q = try_reflect(q, M[2], flips);\n        q = try_reflect(q, M[1], flips);\n    }\n    \n#else\n\n    p = mod(p + 1., 2.) - 1.;\n    flips += int(p.x < 0.0) + int(p.y < 0.0) + int(p.z < 0.0);\n    p = abs(p);\n    q = vec4(p, 1.);\n    q = try_reflect(q, M[1], flips);\n    q = try_reflect(q, M[2], flips);\n    q = try_reflect(q, M[1], flips);\n\n#endif\n\n    return q.xyz;\n}\n\n\n// Shane's tex3D function\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n) {\n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n// I hacked this function to rotate any edge (a, b) to z-axis\nmat3 rotAxis(vec3 n) {\n    n = normalize(n);\n    vec3 x;\n    if (n.x == 0.)\n        x = vec3(1, 0, 0);\n    else\n        x = normalize(vec3(-n.y, n.x, 0.));\n    vec3 y = cross(n, x);\n    return mat3(x, y, n);\n}\n\n\nfloat tube(vec2 p, float sc, float rad) {\n    return max(max(p.x, p.y), (p.x + p.y)*sc) - rad;\n}\n\n\n// draw an edge with two ends at a, b.\nvec3 dSegment(vec3 p, vec3 a, vec3 b) {\n    // set local origin at middle point of the edge\n    vec3 m = (a + b) / 2.;\n    p -= m;\n    b -= m;\n    a -= m;\n    vec3 h = (b - a) / 2.;\n    float L = length(h); // length of half the edge\n\n    p = p * rotAxis(h);  // reorient the edge along with z-axis\n    p = abs(p);\n\n    // the main tube, currently this has infinite length\n    float tb;\n    tb = tube(p.xy, 0.75, tbsize);\n\n    float band = 1e5;\n    float innerTb = 1e5;\n    \n    // add a band of 1/4 length of the edge\n    band = max(tb - 0.0075, p.z - L/4.);\n    \n    // trick: rotate p to make two smaller tubes\n    // remove them from the main tube to make the holes\n    float psize = tbsize  / 1.5;\n    vec2 peg = vec2(tube(p.xz, .64, psize), tube(p.yz, .64, psize));\n    float hole = min(peg.x, peg.y);\n    \n    // use planes to cut the band\n    float dp1 = max(peg.x, p.y - tbsize - .0095); dp1 = max(dp1, p.y - L / 4.);\n    float dp2 = max(peg.y, p.x - tbsize - .0095); dp2 = max(dp2, p.x - L / 4.);\n    band = min(band, min(dp1, dp2));\n    \n    // make holes on the main tube\n    tb = max(tb, -(hole - .015));\n    \n    // cut the infinite main tube at the two ends\n    tb = max(tb, p.z - L);\n    \n    // make holes on the band\n    band = max(band, -(hole + .0125));\n    \n    // use sphere to create a fake inner tube\n    innerTb = length(p) - tbsize;\n    \n    return vec3(tb, band, innerTb);\n}\n\n// This function is only used for handling dual of A3 honeycombs.\n// verts[4] are four non-adjacent vertices of a cube, so each face of the cube\n/// contains exactly one pair of vertices in verts[4].\n// For p a point in the cube, we find this pair of vertices so that p is nearest to\n// the face contains this pair among all six faces.\nvoid findVertexPair(vec3 p, vec3 verts[4], out int i1, out int j1) {\n    float d = 1e5;\n    float d1;\n    for (int i = 0; i < 4; i++) {\n        for (int j = i+1; j < 4; j++) {\n            // (verts[i] + verts[j]) / 2. is the center of the face since they form a diagonal pair.\n            d1 = length(p - (verts[i] + verts[j]) / 2.);\n            if (d1 < d) {\n                i1 = i;\n                j1 = j;\n                d = d1;\n            }\n        }\n    }\n}\n\n\nfloat map(vec3 p) {\n    vec3 dedge = vec3(1e5);\n    vec3 p0 = p;\n    int flips = 0;\n    p = fold(p0, flips);\n\n// For the usual uniform honeycomb just render the edges, that's safe since they lie inside\n// the fundamental tetrahedron.\n#ifndef DUAL\n\n    for (int i = 0; i < 4; i++) {\n         dedge = min(dedge, dSegment(p, v0, E[i]));\n    }\n   \n#else\n    /*\n    Render the dual honeycomb.\n\n    In the dual honeycomb two cells are adjacent if and only if they share a common face.\n        \n    For two mirrors A, B they generate a non-degenerate face if and only if either\n    of below holds:\n        \n        1. A, B are perpendicular and they are both active\n        2. A, B are not perpendicular and at least one of them is active\n        \n    For such a face we further check if {A, B, C} and {A, B, D} both generate non-degenerate cells.\n\n    1. If {A, B, C} and {A, B, D} are both non-degenerate, (C, D) form an edge in the dual honeycomb.\n    2. If {A, B, D} degenerates to a face, (D, 2*C-D) form an edge in the dual honeycomb.\n    3. If both {A, B, C} and {A, B, D} are degenerate, no edge between C and D.\n    */\n\n    // The C3 honeycomb is the easiest, handle this case first.\n    //   4       4\n    // o---o---o---o\n    // A   B   C   D\n    #if LATTICE == 2\n        // if either A or B is active, then {A, B} generate a face and {A, B, C} is a\n        // non-degenerate cell. {A, B, D} is non-degenerate iff D is active.\n        // Other procedures below are all similar.\n        if (isActive(0) || isActive(1)) {\n            if (isActive(3))\n                dedge = min(dedge, dSegment(p, V[2], V[3]));\n            else\n                dedge = min(dedge, dSegment(p, V[3], 2.*V[2]-V[3]));\n        }\n        if (isActive(0) && isActive(2)) dedge = min(dedge, dSegment(p, V[1], V[3]));\n        if (isActive(1) || isActive(2)) dedge = min(dedge, dSegment(p0, V[0], V[3]));\n        if (isActive(0) && isActive(3)) dedge = min(dedge, dSegment(p, V[1], V[2]));\n        if (isActive(1) && isActive(3)) dedge = min(dedge, dSegment(p, V[0], V[2]));\n        if (isActive(2) || isActive(3)) {\n            if (isActive(0))\n                dedge = min(dedge, dSegment(p, V[1], V[0]));\n            else\n                dedge = min(dedge, dSegment(p, V[0], 2.*V[1]-V[0]));\n        }\n \n    #elif LATTICE == 1\n\n        if (isActive(0) || isActive(1)) dedge = min(dedge, dSegment(p, V[2], V[3]));\n        if (isActive(0) && isActive(2)) {\n            if (isActive(3))\n                dedge = min(dedge, dSegment(p, V[1], V[3]));\n            else\n                dedge = min(dedge, dSegment(p, V[3], 2.*V[1]-V[3]));\n        }\n        // trick: the edge (V[0], V[3]) does not lie inside the fundamental domain hence octahedral\n        // shapes won't work. we render its 4 copies in the cube [0, 0, 0] x [2, 2, 2].\n        if (isActive(1) || isActive(2)) {\n            dedge = min(dedge, dSegment(p0, V[0], V[3]));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(2, 2, 0)));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(2, 0, 2)));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(0, 2, 2)));\n        }\n        \n        if (isActive(0) && isActive(3)) {\n            if (isActive(2))\n                dedge = min(dedge, dSegment(p, V[1], V[2]));\n            else\n                dedge = min(dedge, dSegment(p, V[2], 2.*V[1]-V[2]));\n        }\n        if (isActive(1) || isActive(3)) {\n            dedge = min(dedge, dSegment(p0, V[0], V[2]));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(0, 2, 0)));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(0, 0, 2)));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(2, 2, 2)));\n        }\n        if (isActive(2) && isActive(3)) {\n            if (isActive(1))\n                dedge = min(dedge, dSegment(p, V[1], V[0]));\n            else\n                dedge = min(dedge, dSegment(p, V[0], 2.*V[1]-V[0]));\n        } \n    \n    #else\n        // The duals of A3 honeycombs are the most difficult. Recall p0 is now in [-2, -2, -2] x [2, 2, 2].\n        // We use a completely different way to render them. The idea is, vertices of the A3 regular honeycombs\n        // are integer lattices points (i, j, k) with:\n        // i + j + k = 0 mod 4 for V0\n        // i + j + k = 2 mod 4 for V1\n        // i + j + k = 1 mod 4 for V2\n        // i + j + k = 3 mod 4 for V3\n     \n        // find the center of the 2x2x2 cube that p belongs to\n        vec3 C = vec3(sgn(p0.x), sgn(p0.y), sgn(p0.z));\n        \n        float k = mod(C.x + C.y + C.z, 4.);\n        // if k = 1 mod 4, then the center of this cube is congruent to V[2] of the fundamental tetrahedron.\n        // else k = 3 mod 4 and the center is congruent to V[3].\n        int type = (k == 1.) ? 2 : 3;\n        \n        vec3 V0[4];  // holds the vertices of this 2x2x2 cube that are congruent to V[0]\n        vec3 V1[4];  // holds the vertices of this 2x2x2 cube that are congruent to V[1]\n        \n        if (type == 2) {\n            V0[0] = C + vec3(1, 1, 1);\n            V0[1] = C + vec3(-1, -1, 1);\n            V0[2] = C + vec3(1, -1, -1);\n            V0[3] = C + vec3(-1, 1, -1);\n            V1[0] = C + vec3(1, -1, 1);\n            V1[1] = C + vec3(-1, 1, 1);\n            V1[2] = C + vec3(1, 1, -1);\n            V1[3] = C + vec3(-1, -1, -1);\n        }\n        else {  // switch the role of V0, V1 above\n            V1[0] = C + vec3(1, 1, 1);\n            V1[1] = C + vec3(-1, -1, 1);\n            V1[2] = C + vec3(1, -1, -1);\n            V1[3] = C + vec3(-1, 1, -1);\n            V0[0] = C + vec3(1, -1, 1);\n            V0[1] = C + vec3(-1, 1, 1);\n            V0[2] = C + vec3(1, 1, -1);\n            V0[3] = C + vec3(-1, -1, -1);\n        }\n        \n        int r0, s0, r1, s1;\n        findVertexPair(p0, V0, r0, s0);\n        findVertexPair(p0, V1, r1, s1);\n        vec3 P0 = V0[r0] + V0[s0] - C;\n        vec3 P1 = V1[r1] + V1[s1] - C;\n\n        if (isActive(2) && isActive(3)) dedge = min(dedge, dSegment(p, V[0], V[1]));\n        if (isActive(1) || isActive(3)) {\n            if (type == 2) {\n                dedge = min(dedge, dSegment(p0, C, V0[r0]));\n                dedge = min(dedge, dSegment(p0, C, V0[s0]));\n            }\n            else {\n                dedge = min(dedge, dSegment(p0, P0, V0[r0]));\n                dedge = min(dedge, dSegment(p0, P0, V0[s0]));\n            }\n        }\n        if (isActive(1) || isActive(2)) {\n            if (type == 3) {\n                dedge = min(dedge, dSegment(p0, C, V0[r0]));\n                dedge = min(dedge, dSegment(p0, C, V0[s0]));            \n            }\n            else {\n                dedge = min(dedge, dSegment(p0, P0, V0[r0]));\n                dedge = min(dedge, dSegment(p0, P0, V0[s0]));\n            }\n        }\n        if (isActive(0) || isActive(3)) {\n            if (type == 2) {\n                dedge = min(dedge, dSegment(p0, C, V1[r1]));\n                dedge = min(dedge, dSegment(p0, C, V1[s1]));\n            }\n            else {\n                dedge = min(dedge, dSegment(p0, P1, V1[r1]));\n                dedge = min(dedge, dSegment(p0, P1, V1[s1]));\n            }\n        }\n        if (isActive(0) || isActive(2)) {\n            if (type == 3) {\n                dedge = min(dedge, dSegment(p0, C, V1[r1]));\n                dedge = min(dedge, dSegment(p0, C, V1[s1]));\n            }\n            else {\n                dedge = min(dedge, dSegment(p0, P1, V1[r1]));\n                dedge = min(dedge, dSegment(p0, P1, V1[s1]));\n            }\n        }\n        if (isActive(0) && isActive(1)) dedge = min(dedge, dSegment(p, V[2], V[3]));\n\n    #endif\n#endif\n\n    // store the object ids.\n    objIDs = dedge;\n    return min(dedge.x, min(dedge.y, dedge.z));\n}\n\n\n// This reduces the compiling time to about 7x times faster\nvec3 calcNormal(vec3 p, inout float edge, float t) {\n    float eps = 1./mix(400., iResolution.y, .5)*(1. + t*.5);\n    float d = map(p);\n    vec3 e = vec3(eps, 0, 0);\n    vec3 da = vec3(-2.*d);\n    for(int i = min(iFrame, 0); i < 3; i++ ) {\n        for(int j = min(iFrame, 0); j < 2; j++)\n            da[i] += map(p + e * float(1 - 2*j));\n        e = e.zxy;\n    }\n    da = abs(da);\n\n    edge = da.x + da.y + da.z;\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n\n    vec3 n = vec3(0.0);\n    for(int i=min(iFrame, 0); i<4; i++) {\n        vec3 e = .57735*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.);\n        n += e*map(p + .001*e);\n    }\n    return normalize(n);\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float tmin, float tmax, float k) {\n    const int maxShadeIterations = 32;\n    vec3 rd = lp - ro;\n    rd /= max(length(rd), 1e-4);\n    float shade = 1.0;\n    float t = tmin;\n    for (int i = 0; i < maxShadeIterations; i++) {\n        float h = map(ro + rd * t);\n        t += clamp(h, 0.01, 0.2);\n        shade = min(shade, smoothstep(0., 1., k * h / t));\n        if (abs(h) < 1e-4 || t > tmax)\n            break;\n    }\n    return min(max(shade, 0.) + .1, 1.);\n}\n\nfloat calcAO(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.15 * float(i) / 4.0;\n        float d = map(p + h * n);\n        occ += (h - d) * sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0.0, 1.0);\n}\n\n\nfloat trace(in vec3 ro, in vec3 rd) {\n    glow = 0.;\n    float ah;\n    const float precis = 1e-3;\n    float t = 0.0;\n    for (int i = 0; i < 128; i++) {\n        float h = map(ro + rd * t);\n        ah = abs(h);\n        glow += 1./(1. + ah*ah*8.);\n        if (ah < (t * 0.125 + 1.) * precis || t > FAR)\n            break;\n        t += h;\n    }\n    return min(t, FAR);\n}\n\n\nvec3 transform(in vec3 p) {\n    if (iMouse.x > 0.0) {\n        float phi =  2.0*iMouse.x / iResolution.x * PI - PI;\n        float theta = iMouse.y / iResolution.y * PI - 0.5*PI;\n        p.xz = rot2d(p.xz, phi / 6.);\n        p.yx = rot2d(p.yx, theta / 4.);\n       \n    }\n    return p;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    init();\n\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    vec3 up = vec3(0, 1, 0);\n    vec3 ro = camPath(iTime * 1.1);\n    vec3 lookat = camPath(iTime * 1.1 + 0.1);\n    \n    vec3 forward = normalize(lookat - ro);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    vec3 rd = normalize(uv.x * right + uv.y * up + forward * 2.);\n    ro = transform(ro);\n    rd = transform(rd);\n    vec3 lp = ro + vec3(-1, 2, -1);\n    vec3 col = vec3(0);\n    \n    float t = trace(ro, rd);\n    \n    float objID = (objIDs.x < objIDs.y && objIDs.x < objIDs.z) ? 0. : (objIDs.y < objIDs.z) ? 1. : 2.;\n    \n    if (t < FAR) {\n        float ed;\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos, ed, t);\n\n        vec3 oCol;\n        #ifndef GOLD_STYLE\n        vec3 bCol = mix(vec3(1, .1, .5).zyx,\n                        vec3(1, .3, .1).zyx,\n                        dot(sin(pos*8. - cos(pos.yzx*4. + iTime*4.)), vec3(.166)) + .5);\n        #else\n        vec3 bCol = mix(vec3(1, .5, .1),\n                        vec3(1, .1, .2),\n                        dot(sin(pos*8. - cos(pos.yzx*4. + iTime*4.)), vec3(.166)) + .5);\n        #endif\n        if(objID < .5)\n            oCol = mix(bCol, vec3(1), .97);\n        \n        else if (objID > 1.5)\n            oCol = mix(bCol, vec3(1), .05) + bCol*2.;\n        \n        else\n            oCol = mix(bCol, vec3(1.35), .97)*vec3(1.1, 1, .9);\n\n        vec3 tx = tex3D(iChannel0, pos*2., nor);\n        tx = smoothstep(.0, .5, tx)*2.;\n\n        if(objID < 1.5)\n            oCol *= tx;\n        else\n            oCol *= mix(vec3(1), tx, .5);\n\n        float ao = calcAO(pos, nor);\n        float sh = softShadow(pos + nor*.002, lp, 0.001, 16., t);\n\n        vec3 ld = lp - pos;\n        float dist = max(length(ld), 0.001);\n        ld /= dist;\n\n        float atten = 3./(1. + dist*0.05 + dist*dist*0.025);\n\n        float diff = max(dot(ld, nor), 0.);\n        if (objID < 1.5)\n            diff = pow(diff, 4.)*2.;\n        float spec = pow(max(dot( reflect(ld, nor), rd), 0.0 ), 32.0);\n\n        col = oCol*(diff + .25) + mix(bCol.zyx, vec3(1, .7, .3), .5)*spec*4.;\n\n        col += .015/max(abs(.05 - map(pos*1.5 + sin(iTime/6.))), .01)*oCol*mix(bCol, vec3(1, .8, .5), .35);\n\n        // Adding a bit of glow. It was tempting to get my money's worth, but I kept it subtle. :)\n        if(objID < 1.5)\n            col += bCol*glow*.02;\n        else\n            col += bCol*glow*1.5;\n\n        // Applying the dark edges, attenuation, shadows and ambient occlusion.\n        col *= (1. - ed*.7);\n        col *= atten*(sh + ao*.25)*ao;\n\n    }\n\n    float fog = 1./(1. + t*.125 + t*t*.01);\n    col = mix(vec3(0), col, fog);//\n\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125);\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"3sVBWV","date":"1608739422","viewed":671,"name":"Uniform 3D hyperbolic honeycombs","username":"neozhaoliang","description":"Exploring the fun of hyperbolic geometry with hyperbolic honeycombs. Sorry for the high AA and low fps.","likes":11,"published":0,"flags":0,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nCompact and paracompact Hyperbolic honeycombs in H3 space\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis program draws compact/paracompact uniform hyperbolic honeycombs in\nPoincaré's 3D ball model. For a complete list of available honeycombs see\n\n    \"https://en.wikipedia.org/wiki/Uniform_honeycombs_in_hyperbolic_space\"\n\nThanks @knighty for his fragmentarium code && help.\n\nSome math stuff:\n\n1. The 4D space R^4 is endowed with Minkowski inner product: for\n   p=(x1, y1, z1, w1) and q=(x2, y2, z2, w2), their \"hyperbolic dot\" is given by\n\n       hdot(p, q) := x1*y1 + x2*y2 * x3*y3 - x4*y4.\n\n   This inner product has Sylvester type (3, 1), the quadratic form is Q(p) = hdot(p, p).\n\n2. The hyperboloid are those vectors in R^4 with Q(p) = -1 (time-like). For those q with\n   Q(q) > 0 we call q space-like. The hyperboloid consists of two sheets: w > 0 and w < 0.\n\n3. The distance between two vectors p, q on the same sheet is given by\n\n       cosh(d(p, q)) = -hdot(p, q).\n\n4. Any geodesic line from a point p on the hyperboloid can be parameterized by\n\n       p*cosh(t) + v*sinh(t),\n\n   where v is a unit tangent vector at p (v must be space-like).\n\n5. A reflection across a plane with normal `n` is given by\n\n       ref(p) = p - 2 * hdot(p, n) * n.\n\n   Here p is time-like and n is space-like.\n\n6. We iteratively reflect a 4d point until it's in the fundamental domian, we get\n   its distance to the initial vertex/mirrors, then use knighty's magic formula to\n   estimate a `safe` distance that we can march in the 3d space. This is the most\n   intriguing part in the code.\n\n\n@mla has another honeycomb demo:\n\n    https://www.shadertoy.com/view/XddyR2\n\n@knighty's fragmentarium code:\n\n    https://github.com/3Dickulus/Fragmentarium_Examples_Folder/tree/master/Knighty%20Collection/Hyperbolic-tesselations-named\n    \n    \n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nList of available honeycombs\n\n\n***9 compact ones***\n\n(5, 2, 2, 3, 2, 5), (3, 2, 2, 5, 2, 3), (4, 2, 2, 5, 2, 3), (5, 2, 2, 4, 2, 3)\n\n  5       5            5            4       5        5       4\no---o---o---o    o---o---o---o    o---o---o---o    o---o---o---o\n\n\n(4, 2, 3, 3, 2, 4), (5, 2, 3, 3, 2, 4), (5, 2, 3, 3, 2, 5), (5, 2, 2, 3, 3, 2), (5, 2, 3, 3, 2, 3)\n\n                                             o\n  o---o        o---o        o---o        5  /       o---o\n4 |   | 4    5 |   | 4    5 |   | 5    o---o      5 |   |\n  o---o        o---o        o---o           \\       o---o\n                                             o     \n\n***paracompact ones***\n\n\n(6, 2, 2, 2, 3, 3), (3, 2, 2, 2, 3, 6), (6, 2, 2, 2, 3, 6), (3, 2, 2, 2, 6, 3)\n\n  6                        6        6       6            6   \no---o---o---o    o---o---o---o    o---o---o---o    o---o---o---o\nA   B   D   C    A   B   D   C    A   B   D   C    A   B   D   C\n\n\n(4, 2, 2, 2, 4, 4), (4, 2, 2, 2, 4, 3), (3, 2, 2, 2, 4, 4)\n\n  4   4   4        4   4                4   4               \no---o---o---o    o---o---o---o    o---o---o---o\nA   B   D   C    A   B   D   C    A   B   D   C\n\n\n(6, 2, 2, 2, 3, 5), (5, 2, 2, 2, 3, 6), (4, 2, 2, 2, 3, 6), (6, 2, 2, 2, 3, 4)\n\n\n  6       5        5       6        4       6        6       4\no---o---o---o    o---o---o---o    o---o---o---o    o---o---o---o\nA   B   D   C    A   B   D   C    A   B   D   C    A   B   D   C\n\n\n(4, 2, 2, 3, 4, 2), (4, 2, 4, 3, 2, 3), (4, 2, 4, 3, 2, 4), (3, 2, 6, 4, 2, 3), (3, 2, 6, 5, 2, 3)\n\n                 B\nA o              o            4\n  4\\           4/ \\       A o---o B    A o---o B    A o---o B\n    o---o    A o   o C    4 |   |      6 |   | 4    6 |   | 5\n  4/B   C      4\\ /       D o---o C    D o---o C    D o---o C\n  o              o            4\n  D              D\n\n     \n(3, 2, 2, 3, 3, 3), (3, 2, 3, 4, 3, 2), (3, 2, 3, 5, 3, 2)\n      \n      o C          o A          o A\nA   B/|      C 4 B/|      C 5 B/|\no---o |      o---o |      o---o |  \n     \\|           \\|           \\|  \n      o D          o D          o D\n     \n     \n(3, 2, 3, 3, 3, 3)\n\n    B\n    o    \n   /|\\\nA o | o C\n   \\|/\n    o\n    D\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n*/\n\n// antialiasing level\n#define AA    3\n// view boundary near the infinite\n#define FAR   0.998\n// maximum number of raymarch steps\n#define MAX_TRACE_STEPS  128\n\n#define FOV   1.\n#define fog   vec3(.19, .19, .86)\n//#define fog   vec3(0.6, 0.8, 1)\n\n\n// ===========\n// !Important:\n// ===========\n// Due to the way we construct the mirrors, the first three mirrors must have spherical\n// type, so for paracompact honeycombs like (4, 4, x), (6, 3, x), (3, 6, x), you need to\n// swap the order of the last two mirrors, i.e. use (4, 2, 2, 2, 4, 4) or (6, 2, 2, 2, 3, x)\n// in the Coxeter diagram. Suggested by @mla.\n// For diagram = (a, b, c, d, e, f) the corresponding Coxeter matrix is\n//\n// | 1  a  b  c |\n// | a  1, d  e |\n// | b  d  1  f |\n// | c  e  f  1 |\n//\nconst float[6] diagram = float[6](5., 2., 3., 3., 2., 5.);\n\n// active mirrors, 1 for active, 0 for non-active. This determines the position\n// of the initial vertex hence the truncation type of the honeycomb.\nconst vec4 active_mirrors = vec4(1, 0, 0, 0);\n\n// size of the vertex and segments\n// you may need to adjust these for different scenes\nconst float vradius = 0.12;\nconst float sradius = 0.06;\n\n// palette for the vertices and segments\nconst vec3 vcolor = vec3(0.71, 0.65, 0.26);\nconst vec3[4] ecolors = vec3[4](vec3(.90, .91, 0.98),\n                                vec3(0.72, 0.45, 0.2),\n                                vec3(0.32, 0.79, 0.36),\n                                vec3(0.14, 0.42, 0.56));\n\nvec3 chooseColor(float id) {\n    return (id == 4.) ? vcolor : ecolors[int(id)];\n}\n\nvec2 map(vec3 p) {\n    float r = length(p);\n    vec4 q = vec4(2.*p, 1.+r*r) / (1.-r*r);\n    bool found = fold(q, M);\n    if (found) {\n        float id;\n        float dvert = dVertex(q, r);\n        float dedge = dSegments(q, r, id);\n        id = (dvert < dedge) ? 4. : id;\n        return vec2(min(dvert, dedge), id);\n    }\n    return vec2(FAR, -1.0);\n}\n\nvec2 trace(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    vec2 h;\n    for (int i = 0; i < MAX_TRACE_STEPS; i++) {\n        h = map(ro + rd * t);\n        if (h.x < 1e-5 * (t * 1.25 + 1.))\n            return vec2(t, h.y);\n        if (t > FAR)\n            break;\n        t += min(h.x, 0.02);\n    }\n    return vec2(FAR, -1.0);\n}\n\nvec3 calcNormal(vec3 p, inout float edge, float t) {\n\n    vec2 e = vec2(1./mix(400., iResolution.y, .5)*(1. + t*.5), 0);\n    float d1 = map(p + e.xyy).x, d2 = map(p - e.xyy).x;\n    float d3 = map(p + e.yxy).x, d4 = map(p - e.yxy).x;\n    float d5 = map(p + e.yyx).x, d6 = map(p - e.yyx).x;\n    float d = map(p).x*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n\n    e = vec2(.002, 0);\n    d1 = map(p + e.xyy).x, d2 = map(p - e.xyy).x;\n    d3 = map(p + e.yxy).x, d4 = map(p - e.yxy).x;\n    d5 = map(p + e.yyx).x, d6 = map(p - e.yyx).x;\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\nfloat softShadow(vec3 ro, vec3 lp, float tmin, float tmax, float k) {\n    const int maxShadeIterations = 24;\n    float res = 1.0;\n    float t = tmin;\n    vec3 rd = lp - ro;\n    rd /= max(length(rd), 1e-4);\n    for (int i = 0; i < maxShadeIterations; i++) {\n        float h = map(ro + rd * t).x;\n        t += clamp(h, 0.005, 0.2);\n        res = min(res, smoothstep(0., 1., k * h / t));\n        if (abs(h) < 0.001 || t > tmax)\n            break;\n    }\n    return clamp(res + 0.2, 0.0, 1.0);\n}\n\nfloat calcAO(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.15 * float(i) / 4.0;\n        float d = map(p + h * n).x;\n        occ += (h - d) * sca;\n        sca *= 0.75;\n    }\n    return clamp(1.0 - occ, 0.0, 1.0);\n}\n\nfloat n3D(vec3 p) {\n    const vec3 s = vec3(7, 157, 113);\n    vec3 ip = floor(p);\n    p -= ip;\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nvec3 envMap(vec3 p) {\n    p *= 2.;\n    float n3D2 = n3D(p*2.);\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(0.5, 1., c);\n    p = vec3(c*.8, c*.9, c);\n    return mix(p.zxy, p, n3D2*.34 + .665);\n}\n\nvec3 render(vec3 ro, vec3 rd, vec3 lp) {\n    vec3 col = vec3(0.);\n    vec2 result = trace(ro, rd);\n    float t = result.x;\n    float id = result.y;\n    if (id >= 0.) {\n        float ed;\n        vec3 pos = ro + rd * t;\n        vec3 nor = calcNormal(pos, ed, t);\n        vec3 oCol = chooseColor(id);\n\n        float ao = calcAO(pos, nor);\n        float sh = softShadow(pos + nor*.001, lp, 0.001, 2., t);\n\n        vec3 ld = lp - pos;\n        float dist = max(length(ld), 0.001);\n        ld /= dist;\n\n        float at = 2./(1. + dist*0.025 + dist*dist*0.05);\n\n        float diff = max(dot(ld, nor), 0.);\n        diff = pow(diff, 4.)*2.;\n        float spec = pow(max(dot( reflect(-ld, nor), -rd), 0.0 ), 8.0);\n        float fre = pow( clamp(dot(nor, rd) + 1., .0, 1.), 4.);\n        vec3 env = envMap(reflect(rd, nor))*1.5;\n\n        col += oCol * (diff + 0.25 + vec3(.8, .9, .97)*fre);\n        col += oCol * env;\n        col += vec3(.9, .95, .93)*spec;\n        col *= (1. - ed*.7);\n        col *= at*(sh + .25*ao)*ao;\n    }\n    vec3 bg = mix(fog*.2, fog*1.2, normalize(ro + rd*t).y*.5 + .5);\n    col = mix(col, bg, 1. - exp(-t*t*t*0.2));\n    return col;\n}\n\nvoid mouse(inout vec3 lookat) {\n    vec2 m = (iMouse.xy / iResolution.xy) + .5;\n    float rx = 2. *PI * m.x;\n    float ry = - PI* m.y;\n    lookat.xz = rot2d(lookat.xz, ry);\n    lookat.yz = rot2d(lookat.yz, rx);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n// -----------------\n// setup the fundamental tetrahedron\n\n    init(diagram, active_mirrors, M, v0);\n\n    // cosh(vradius), sinh(vradius), cosh(sradius), sinh(sradius)\n    cvr = cosh(vradius); svr = sinh(vradius);\n    csr = cosh(sradius); ssr = sinh(sradius);\n\n\n// ---------------\n// view settings\n\n    vec3 ro = vec3(0, 0, 0);\n    vec3 up = vec3(0, 1, 0);\n    vec3 lookat = vec3(1, 0, 0);\n    mouse(lookat);\n    vec3 forward = normalize(lookat - ro);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    vec3 lp = vec3(0, .2, 0);\n\n// -----------------\n// antialiasing loop\n\n    vec3 finalcol = vec3(0.);\n\n    for (int ii = 0; ii < AA; ii ++) {\n        for (int jj = 0; jj < AA; jj++) {\n            vec2 o = vec2(float(ii), float(jj)) / float(AA);\n            vec2 uv = (2. * fragCoord + o - iResolution.xy) / iResolution.y;\n            vec3 rd = normalize(uv.x * right + uv.y * up + forward * FOV);\n            finalcol += render(ro, rd, lp);\n        }\n    }\n    finalcol /= (float(AA) * float(AA));\n\n    fragColor = vec4(sqrt(clamp(finalcol, 0., 1.)), 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI    3.141592654\n\n\n// normal vectors of the four mirrors\nmat4 M;\n\n// the initial vertex\nvec4 v0;\n\n// cosh, sinh of the vertex radius and edge radius\nfloat cvr, svr, csr, ssr;\n\n// 2d rotation\nvec2 rot2d(vec2 p, float a) { return cos(a) * p + sin(a) * vec2(p.y, -p.x); }\n\n// Minkowski inner product with Sylvester type (3, 1)\nfloat hdot(in vec4 p, in vec4 q) { return dot(p.xyz, q.xyz) - p.w * q.w; }\n\n// normalize a time-like vector <v, v> < 0\nvec4 hnormalize(in vec4 p) { return p / sqrt(-hdot(p, p)); }\n\n// reflection about a plane with normal `n`\nfloat href(inout vec4 p, in vec4 n) {\n    float k = min(0., hdot(p, n));\n    p -= 2. * k * n;\n    return k;\n}\n\n// knighty's conservative distance conversion from hyperboloid to 3d flat distance.\n// for a 3d point p, it's lifted to a 4d point q on the hyperboloid:\n//\n//        2p     1+r^2\n// q = ( -----,  ----- ).\n//       1-r^2   1-r^2\n//\n// any point with distance d (ca=cosh(d),sa=sinh(d)) to q can be written as q*ca + v*sa,\n// wheren v is a unit tangent vector at q. We want v look like (sp, t).\n// so we have two unknowns (s, t) and two equations:\n\n// 1. s^2 * r^2 - t^2 = 1  (tangent vector must be space-like)\n// 2. 2*s/(1-r^2)*r^2 - (1+r^2)/(1-r^2)*t = 0 (definition of tangent vector at q)\n\n// solve for s, t we have s = (1+r^2)/(r *(1-r^2)) and t = 2*r/(1-r^2).\n// hence the point we choose to project to 3d is\n// ([ 2*ca/(1-r^2) + (1+r^2)/(r *(1-r^2))*sa ] * p,\n//  [ ca*(1+r^2)/(1-r^2) + sa*2*r/(1-r^2) ])\nfloat knightyDD(float ca, float sa, float r) {\n    float x = 1. + r * r;\n    float y = 2. - x;\n    return (2. * r * ca + x * sa) / (x * ca + 2. * r * sa + y) - r;\n}\n\n\n// Given the Coxeter diagram and active mirrors (on/off),\n// get the normals of the reflection mirrors and the initial vertex.\n// Warning: due to the procedure used here, the first three mirrors must\n// have \"spherical\" type.\nvoid init(in float[6] diagram, in vec4 active_mirrors, inout mat4 M, inout vec4 v0) {\n    // Cartan matrix of the Coxeter group:\n    // ( -1  c01  c02  c03)\n    // (c01   -1  c12  c13)\n    // (c02  c12   -1  c23)\n    // (c03  c13  c23   -1)\n    // cij = -cos(PI / (Coxeter label bewteen i-th and j-th mirror))\n    float c01 = -cos(PI / diagram[0]);\n    float c02 = -cos(PI / diagram[1]);\n    float c03 = -cos(PI / diagram[2]);\n    float c12 = -cos(PI / diagram[3]);\n    float c13 = -cos(PI / diagram[4]);\n    float c23 = -cos(PI / diagram[5]);\n\n    vec4 A, B, C, D;\n\n    // find the reflection mirrors A, B, C, D.\n    // A can be always chosen as x-axis\n    A = vec4(1, 0, 0, 0);\n\n    B = vec4(c01, sqrt(1. - c01*c01), 0., 0.);\n\n    C = vec4(c02, 0, 0, 0);\n    C.y = (c12 - C.x * B.x) / B.y;\n    C.z = sqrt(abs(1. - dot(C.xy, C.xy))); // avoid rounding error in paracompact case\n\n    D = vec4(c03, 0, 0, 0);\n    D.y = (c13 - D.x * B.x) / B.y;\n    D.z = (c23 - dot(D.xy, C.xy) ) / C.z;\n    // !important: if you want to make the fundamental chamber lie in the upper\n    // sheet of the hyperboloid then you must use \"-\" sign here.\n    D.w = -sqrt(abs(dot(D.xyz, D.xyz) - 1.));\n\n    // below is suggested by @mla\n    vec4 H = vec4(1, 1, 1, -1);\n    v0 = hnormalize(active_mirrors * inverse(mat4(H*A, H*B, H*C, H*D)));\n    M = mat4(A, B, C, D);\n}\n\n\n// if distance between p and q is a, C is a circle with radius VR centered at q,\n// then the distance from p to C is a - VR, hence\n// cosh(a - VR) = cosh(a)cosh(VR) - sinh(a)sinh(VR)\n// sinh(a - VR) = sinh(a)cosh(VR) - cosh(a)sinh(VR)\nfloat dVertex(vec4 p, float r) {\n    float ca = -hdot(p, v0);\n    float sa = 0.5 * sqrt(-hdot(p - v0, p - v0) * hdot(p + v0, p + v0));\n    return knightyDD(ca * cvr - sa * svr,\n                     sa * cvr - ca * svr, r);\n}\n\n// let pj = a * n + b * v0 be the projection of p onto the plane given by (v0, n).\n// take Minkowski dot with p - pj by v0 and n:\n// (p, n) = a + b * (v0, n)\n// (p, v0) = a * (v0, n) - b\n// then solve this 2x2 linear system.\nfloat dSegment(vec4 p, vec4 n, float r) {\n    float pn = hdot(p, n);\n    float pv = hdot(p, v0);\n    float nv = hdot(n, v0);\n    float det = -1.0 - nv * nv;\n    float a = (-nv * pv - pn) / det;\n    float b = (pv - pn * nv) / det;\n    vec4 pj = hnormalize(min(a, 0.) * n + b * v0);\n    float ca = -hdot(p, pj);\n    float sa = 0.5 * sqrt(-hdot(p - pj, p - pj) * hdot(p + pj, p + pj));\n    return knightyDD(ca * csr - sa * ssr, sa * csr - ca * ssr, r);\n}\n\n\n// fold a point p in 4d up to a given maximum of steps, return true if\n// we successfully transformed p into the fundamental domain else return false.\nbool fold(inout vec4 p, mat4 M) {\n    const int max_iter = 40;\n    float k;\n    for(int i = 0; i < max_iter; i++) {\n        k = 0.;\n        p.x = abs(p.x);\n        k += href(p, M[1]);\n        k += href(p, M[2]);\n        k += href(p, M[3]);\n        // break as soon as we find it's already in the fundamental domain\n        if(k == 0.) return true;\n    }\n    return false;\n}\n\n// find the shortest distance from p to the 4 base edges\n// as well as the index of that edge.\nfloat dSegments(vec4 p, float r, inout float index) {\n    float d = 1.0;\n    for(int i=0; i<4; i++) {\n        float dseg = dSegment(p, M[i], r);\n        if (dseg < d) {\n            d = dseg;\n            index = float(i);\n        }\n    }\n    return d;\n}\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"ctB3RG","date":"0","viewed":0,"name":"Volcano lake","username":"neozhaoliang","description":" Draws the 3d ball packing of the hyperbolic group","likes":0,"published":0,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Output to screen\n    vec4 tex = texelFetch(iChannel0,ivec2(gl_FragCoord.xy),0);\n    \n\tvec3 color = tex.rgb/tex.a;\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI                 3.1415926535\n#define ReflectionsNumber  3\n#define MIN_EPS            2./16777216.\n#define FudgeFactor        1.0\n#define Dither             0.5\n#define MaxRaySteps        300\n#define RefineSteps        5\n#define MaxDistance        200.\n#define GradientBackground 2.83785\n#define Iterations         500\n#define NormalBackStep     0.6125\n#define ShadowSoft         19.0118\n#define ShadowBlur         0.\n#define coneApertureAO     0.378985\n#define DetailAO           -1.96825\n#define maxIterAO          19\n#define FudgeAO            0.349943\n#define HardShadow         1.\n#define LightFallOff       0.38016\n#define Specular           0.4\n#define SpecularExp        200.0\n#define ApertureNbrSides   5\n#define Aperture           0.003\n#define AntiAliasScale     1.5\n#define FocalPlane         1.\n#define GaussianWeight     1.\n\n#define FOV                0.685022\n\n#define CloudBase          -5.8\n#define CloudDensity       0.484136\n#define CloudScale         2.50337\n\n\n#define HF_Const           0.05333\n#define HF_Fallof          0.187344\n#define HF_FogIter         1\n#define HF_Intensity       0.\n#define HF_Offset          0.\n#define HF_Scatter         10.\n\n#define AO_pointlight      0.449594\n#define AO_camlight        1.59217\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nvec4 orbitTrap;\n\nconst vec3 Eye = vec3(5.52166, -0.807811, 2.62172);\nconst vec3 Target = vec3(1.21024, 5.81932, -4.00749);\nconst vec3 Up = -normalize(vec3(0.268486,0.412693,0.587178));\nconst vec3 Reflection = vec3(0.352941,0.352941,0.352941);\nconst vec3 SunLightColor = vec3(0.968627);\nconst vec3 CloudColor = vec3(0.65, 0.68, 0.7);\nconst vec3 CloudColor2 = vec3(0.07,0.17,0.24);\nconst vec3 Clouds_Dir = vec3(0.273574,-0.22061,-1);\nconst vec3 HF_Dir = vec3(0, 0, 1);\nconst vec4 CamLight = vec4(1, 1, 1, 0.2);\nconst vec4 HF_Color = vec4(0.564706, 0.752941, 0.878431, 1);\nconst vec4 AmbiantLight = vec4(0.972549,0.972549,0.972549,0.5);\nconst vec4 X = vec4(0.898039, 0.937255, 0.976471, 1);\nconst vec4 Y = vec4(0.898039, 0.937255, 0.976471, 0);\nconst vec4 Z = vec4(0.898039, 0.937255, 0.976471, 0);\nconst vec4 R = vec4(0.898039, 0.937255, 0.976471, 1);\nconst vec3 FloorColor = vec3(0.313725);\nconst vec3 BackgroundColor = vec3(0.270588, 0.403922, 0.6);\nconst vec3 BaseColor = vec3(0.72549, 0.72549, 0.521569);\nconst vec4 SpotLight = vec4(1, 1, 1, 0.73438);\nconst float Detail = -3.8;\nconst float minDist = pow(10.0, Detail);\nconst vec3 LightPos = vec3(0.7888, -5.6502, 2.6654);\nconst float LightSize = 0.0;\nconst float aoEps = pow(10.0, DetailAO);\nbool depthFlag = true;\nbool floorHit = false;\nbool lighthit = false;\nfloat floorDist = 0.0;\nvec3 floorNormal = vec3(0, 0, 1);\nconst float FloorHeight = 1.8;\nvec3 colorBase = vec3(0);\nfloat fSteps = 0.0;\nvec2 coord;\nvec2 viewCoord;\nvec2 seed;\n\nfloat exp1(float x){ return exp(clamp(x,-80.,80.));}//have to use this to avoid black dots (again)\nvec3 exp1(vec3 x){ return exp(clamp(x,vec3(-80.),vec3(80.)));}\n\nuint wang_hash(uint seed)\n{\n\tseed = (seed ^ 61u) ^ (seed >> 16u);\n\tseed *= 9u;\n\tseed = seed ^ (seed >> 4u);\n\tseed *= 0x27d4eb2du;\n\tseed = seed ^ (seed >> 15u);\n\treturn seed ;\n}\n\nfloat rand(vec2 p){\n\tuint ix = floatBitsToUint(p.x);\n\tuint iy = floatBitsToUint(p.y);\n\treturn float(wang_hash(wang_hash(ix)+iy)) / 4294967296.0;\n}\n\nfloat rand(vec3 pos){\n\tuint ix = floatBitsToUint(pos.x);\n\tuint iy = floatBitsToUint(pos.y);\n\tuint iz = floatBitsToUint(pos.z);\n\treturn float(wang_hash(wang_hash(wang_hash(ix)+iy)+iz)) / 4294967296.0;\n}\nvec2 rand2(vec2 co){\n\t// implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn\n\tvec2(fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453),\n\t\tfract(cos(dot(co.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec2 NGonDisc(vec2 co) {\n\tvec2 r = rand2(co);\n\tfloat d=1./tan(PI/float(ApertureNbrSides));\n\tfloat lh=1./sqrt(1.+d*d);\n\tvec2 p=vec2(r.x+r.y, r.x-r.y);\n\tp.x*=d;\n\tp*=lh;\n\tfloat a=dot(rand2(11.*co+vec2(1.,1.)),vec2(1.,1.));\n\ta=floor(a*float(ApertureNbrSides))*2.*PI/float(ApertureNbrSides);\n\tvec2 cs= vec2(cos(a), sin(a));\n\tp= vec2(cs.x*p.x-cs.y*p.y, cs.x*p.y+cs.y*p.x);\n\t/*a=ApertureRot*PI/360.;\n\tcs= vec2(cos(a), sin(a));\n\tp= vec2(cs.x*p.x-cs.y*p.y, cs.x*p.y+cs.y*p.x);*/\n\treturn p;\n}\n\n\nvec2 rand2n() {\n    seed += vec2(-1,1);\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n\t\tfract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec3 ortho(vec3 v) {\n    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nfloat DElight(vec3 pos) {\n\treturn length(LightPos-pos)-LightSize;\n}\n\n\nstruct Ball {\n    vec4 data;\n    bool isplane;\n    bool invert;\n};\n\nconst Ball[5] balls = Ball[5] (\n    Ball(vec4(0.12132034, 0.50730594, 2.3483438, 1.014611872354576), false, false),\n    Ball(vec4(0, 1.73205081, 0, 2.449489742783177), false, true),\n    Ball(vec4(0.8660254037844386,  -0.5, 0.0, 0.8660254037844386),  true, false),\n    Ball(vec4(-0.8660254037844386, -0.5, 0.0, 0.8660254037844386), true, false),\n    Ball(vec4(0, 1, 0, 0), true, false)\n);\n\n\nfloat distanceToBall(vec3 p, Ball B) {\n    if (B.isplane)\n        return dot(vec4(p, 1), B.data);\n    else\n        return length(p - B.data.xyz) - B.data.w;\n}\n\nbool try_reflect(inout vec3 p,\n                 in Ball B,\n                 inout float scale,\n                 inout vec4 orb) {\n    if (B.isplane) {\n        float k = dot(vec4(p, 1), B.data);\n        if (k >= 0.)\n            return true;\n        p -= 2.0 * k  * B.data.xyz;\n        return false;\n    }\n    else {\n        vec3 cen = B.data.xyz;\n        float r = B.data.w;\n        vec3 q = p - cen;\n        float d2 = dot(q, q);\n        float k = (r * r) / d2;\n        if ( (k < 1.0 && B.invert) || (k > 1. && !B.invert) )\n            return true;\n\n        orb = min(orb, vec4(abs(p), d2));\n        scale *= k;\n        p = k * q + cen;\n        return false;\n    }\n}\n\nfloat map(inout vec3 p, inout float scale, inout vec4 orb) {\n    for (int i = 0; i < Iterations; i++) {\n        bool cond = true;\n        for (int k = 0; k < 5; k++) {\n            cond = cond && try_reflect(p, balls[k], scale, orb);\n        }\n        if (cond)\n            break;\n    }\n    return abs(p.z);\n}\n\n\nfloat DE(vec3 p) {\n    float DEfactor=1.;\n    float d = map(p, DEfactor, orbitTrap);\n    return 0.25 * d / DEfactor;\n}\n\nfloat DEF(vec3 p) {\n\tfloat d = DE(p);\n    floorDist = abs(dot(floorNormal, p) - FloorHeight);\n\tif (d<floorDist) {\n\t\tfSteps++;\n\t\treturn d;\n\t}\n    else\n    return floorDist;\n}\n\n\nfloat DEF2(vec3 p) {\n    floorDist = abs(dot(floorNormal,p)-FloorHeight);\n\treturn min(floorDist, DE(p)*FudgeFactor);\n}\n\nvec3 normal(vec3 pos, float normalDistance) {\n\tnormalDistance = max(normalDistance*0.5, 1.0e-5);\n\tvec3 e = vec3(0.0,normalDistance,0.);\n\tvec3 n = vec3(DE(pos+e.yxx)-DE(pos-e.yxx),\n\t\tDE(pos+e.xyx)-DE(pos-e.xyx),\n\t\tDE(pos+e.xxy)-DE(pos-e.xxy));\n\tn = normalize(n);\n\treturn n==n ? n : vec3(0.0);\n}\n\nfloat linstep(float a, float b, float t){return clamp((t-a)/(b-a),0.,1.);}\nfloat shadow(vec3 ro, vec3 lightPos, float eps){\n\t//return 1.;\n\tfloat rCoC=eps;\n\tvec3 rd=(lightPos-ro);\n\tfloat lightDist=length(rd);\n\trd/=lightDist;\n\tfloat coneGrad=ShadowSoft;\n\tconeGrad=ShadowBlur/lightDist;\n\tfloat t=DEF2(ro)+rCoC;\n\tfloat d=1.0,s=1.0;\n\tfloat jitter=Dither*(rand(ro.xy)-0.5);\n\tfor(int i=0;i<MaxRaySteps;i++){\n\t\tif(t>lightDist || s<0.001) break;\n\t\tfloat r=rCoC+t*coneGrad;//radius of cone\n\t\td=DEF2(ro+rd*(t+r*jitter))+r;\n\t\ts*=linstep(0.,2.*r,1.*d);//smoothstep(-r,r,d);//\n\t\tt+=abs(0.75*d+ShadowSoft*r);\n    }\n\ts=max(0.,s-0.001)/0.999;\n\treturn clamp(1.-s,0.0,1.0);\n}\n\nvec3 getVdirAO(vec3 dir){//dir is supposed to be normalized\n\t//return dir;\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = cross(dir, o1);\n\tvec2 r = rand2n();\n\tr.x=r.x*2.*PI;\n\tfloat cAAO = coneApertureAO*2.;\n\tfloat kAO = coneApertureAO;//1./sqrt(1.+cAAO*cAAO);\n\tr.y*= kAO;\n\tfloat ry = sqrt(r.y);\n\tfloat rz=sqrt(1.-r.y);\n\treturn cos(r.x)*ry*o1+sin(r.x)*ry*o2+rz*dir;\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n) {\n\tvec3 Vdir =  getVdirAO( n );\n\tfloat ao = 0.0;\n\tfloat de = DEF(p)/aoEps;//*(-DetailAO);//dividing by aoEps gives control on the overall scale of the AO.\n\tfloat wSum = 0.0;\n\tfloat w = 1.0;\n\tfloat d = 1.0-(Dither*rand(p.xy));\n\tfloat D=1.;\n\tfor (int i =1; i <maxIterAO; i++) {\n\t\tfloat prevD=D;\n\t\tD = DEF(p+ d*Vdir*de);\n\t\tD = D/(d*de*dot(Vdir,n)*FudgeAO);\n\t\tD=min(prevD,D);//if light is obscured at previous level it should be obscured at least at the same amount at this level.\n\t\tw *= 1.;//Maybe removed next time\n\t\td*=1.61;//next level  -> x2. maybe becomes a parameter\n\t\tao += w*clamp(1.0-D,0.0,1.0);\n\t\twSum += w;\n\t}\n\treturn ao/wSum;//clamp(AO1*ao/wSum, 0.0, 1.0);\n}\n\n\nvec3 cycle(vec3 c, float s) {\n\treturn vec3(0.5) + 0.5 * cos(s * 0.1 + c);\n}\n\n\n\nvec3 getColor() {\n\torbitTrap.w = sqrt(orbitTrap.w);\n\tvec3 orbitColor = cycle(X.xyz, orbitTrap.x) * X.w * orbitTrap.x +\n\t                  cycle(Y.xyz, orbitTrap.y) * Y.w * orbitTrap.y +\n\t                  cycle(Z.xyz, orbitTrap.z) * Z.w * orbitTrap.z +\n\t                  cycle(R.xyz, orbitTrap.w) * R.w * orbitTrap.w;\n\t\n\tvec3 color = mix(BaseColor, 3.0*orbitColor,  1.0);\n\treturn color;\n}\n\n\n\nstruct SRay{\n\tvec3 Origin; // origin of the ray. Intially camera center\n\tvec3 Direction; // main ray direction\n\tvec3 Offset; // For DoF\n\tfloat Pos; // current position along the ray\n\tfloat fudge;// Lazy way to avoid overshooting\n\tfloat iFP;// =1/FocalPlane\n};\n\nvoid SRAdvance(inout SRay Ray, float dist) { Ray.Pos+=dist*Ray.fudge;}\n\nvec3 SRCurrentPt(SRay Ray) {\n\tfloat t = Ray.Pos; \n\tvec3 p = Ray.Origin + Ray.Direction*t ;\n\tt = 1. - t * Ray.iFP;\n\tfloat d = t;\n\td = d - (2. * smoothstep(-1.5, 1.5, t) - 1.);\n\treturn p + Ray.Offset * d;\n}\n\nSRay SRReflect(SRay Ray, vec3 normal, float eps){\n\tvec3 hit=SRCurrentPt(Ray);\n\tRay.Direction = reflect(Ray.Direction, normal);\n\tRay.Offset = reflect(Ray.Offset, normal);\n\tRay.Origin= hit + reflect(Ray.Origin - hit, normal);//hit-Ray.Direction*Ray.Pos;\n\t//Ray.Origin= hit-Ray.Direction*Ray.Pos;\n\tRay.Pos+=eps;\n\treturn Ray;\n}\n\nvec3 fogAmount3(vec3 P0, vec3 P1){//Modified from: http://www.iquilezles.org/www/articles/fog/fog.htm\n\t//ToDo: make dependent on the fog color\n\tvec3 hfdir=vec3(0, 0, 1);\n\tfloat t=length(P1-P0);\n\tfloat A=HF_Fallof*dot(P1-P0,hfdir);\n\tA=(1.0-exp1(-A))/A;\n\tvec3 amount= HF_Color.rgb*(HF_Intensity * exp1(-HF_Fallof*(dot(P0,hfdir)-HF_Offset))* A  + HF_Const) * t;\n\t//amount=clamp(amount,-5.,100.);\n\treturn clamp(exp1(-amount),vec3(0.),vec3(1.));//Return transmission factor\n}\n\n\nvec3 lighting(vec3 n, vec3 color, vec3 pos, vec3 dir, float eps, out float shadowStrength, float ao) {\n\tshadowStrength = 0.0;\n\tvec3 col=vec3(0.);\n\tfloat D2L2=dot(LightPos-pos,LightPos-pos);\n\tfloat falloff=pow(D2L2,-LightFallOff);\n\tvec3 spotDir = normalize(LightPos-pos);\n\t\n\tfloat nDotL = max(0., dot(n,spotDir));\n\tvec3 halfVector = normalize(-dir+spotDir);\n\tfloat diffuse = nDotL;\n\t//float ambient = AmbiantLight;//max(CamLightMin,dot(-n, dir));\n\tfloat hDotN = max(0.,dot(n,halfVector));\n\t\n\t// An attempt at Physcical Based Specular Shading:\n\t// http://renderwonk.com/publications/s2010-shading-course/\n\t// (Blinn-Phong with Schickl term and physical normalization)\n\t//float specular =((SpecularExp+2.)/8.)*pow(hDotN,SpecularExp+0.00001)*(SpecularExp + (1.-SpecularExp)*pow(1.-hDotN,5.))*nDotL*Specular;\n\tfloat f0=(SpecularExp-1.)/(SpecularExp+1.); f0*=f0;\n\tfloat fresnel=f0+(1.-f0)*pow(1.+dot(n,dir),5.);\n\tfloat specular =((SpecularExp+2.)/8.)*fresnel*nDotL*pow(hDotN,SpecularExp+0.00001)*Specular;\n\t//specular = min(SpecularMax,specular);\n\t\t\n\tif (HardShadow>0.0) {\n\t\t// check path from pos to spotDir\n\t\tshadowStrength = shadow(pos+n*eps, LightPos, eps);\n\t\t\n\t\tdiffuse = mix(diffuse,0.0,HardShadow*shadowStrength);\n\t\t// specular = mix(specular,0.0,HardShadow*f);\n\t\tspecular*=1.-shadowStrength;//if (shadowStrength>0.0) specular = 0.0; // always turn off specular, if blocked\n\t}\n\tvec3 FG=fogAmount3(pos,LightPos);//fog Attenuates light.\n\t//return (FG*SpotLight.xyz*SpotLight.w*falloff*(diffuse+ specular)+CamLight.xyz*CamLight.w*(ambient)*(1.-ao))*color;\n\tcol+=FG*SpotLight.xyz*SpotLight.w*falloff*(diffuse+ specular)*(1.-clamp(AO_pointlight*ao, 0.0, 1.0));\n\n\tnDotL = max(0., dot(n,-dir));\n\thalfVector = -dir;\n\tdiffuse = nDotL;\n\thDotN = max(0.,dot(n,halfVector));\n\tspecular =((SpecularExp+2.)/8.)*fresnel*nDotL*pow(hDotN,SpecularExp+0.00001)*Specular;\n\tcol+=CamLight.xyz*CamLight.w*(diffuse+ specular)*(1.-clamp(AO_camlight*ao, 0.0, 1.0));\n\n\tcol+=AmbiantLight.xyz*AmbiantLight.w*(1.-clamp(ao, 0.0, 1.0));\n\tcol*=color;\n\treturn col;\n}\n\n\nvec3 trace(inout SRay Ray, inout vec3 hitNormal, inout float glow) {\n\tglow = 1000.0;\n\tvec3 hit = SRCurrentPt(Ray);\n\torbitTrap = vec4(10000.0);\n\tfloorHit = false;\n\tbool hitSomething = false;\n\tfloorDist = 0.0;\n\t\n\tfloat dist = 0.0;\n\t\n\tint steps;\n\tcolorBase = vec3(0.0,0.0,0.0);\n\t\n\t// We will adjust the minimum distance based on the current zoom\n\tfloat eps = minDist;\n\tfloat lightde=0.;\n\tfloat epsModified = max(MIN_EPS, Ray.Pos * eps * FudgeFactor);\n\torbitTrap = vec4(10000.0);\n\tvec3 p = SRCurrentPt(Ray);\n\tfloat ldist = min(DEF(p) * FudgeFactor, DElight(p));\n\tldist *= (Dither*rand(Ray.Direction.xy))+(1.0-Dither);\n\tSRAdvance(Ray, ldist); \n\tfor (steps=0; steps<MaxRaySteps; steps++) {\n\t\tvec3 p = SRCurrentPt(Ray); //from + totalDist * direction;\n\t\t//dist = DEF(p) * FudgeFactor;\n\t\tdist = lightde = DElight(p);//DEL(p, lightde);\n\t\tdist = min(dist,DEF(p) * FudgeFactor);\n\t\tglow=min(lightde,glow);\n\t\tSRAdvance(Ray, dist);\n\t\tepsModified = max(MIN_EPS, Ray.Pos*eps* FudgeFactor);\n\t\tif (dist < epsModified) {\n\t\t\t// move back\n\t\t\tfor(int i=0; i<RefineSteps;i++){\n\t\t\t\tSRAdvance(Ray, dist-1.5*epsModified);\n\t\t\t\tp = SRCurrentPt(Ray);\n\t\t\t\tdist = lightde = DElight(p);//DEL(p, lightde);\n\t\t\t\tdist = min(dist,DEF(p) * FudgeFactor);\n\t\t\t\tglow=min(lightde,glow);\n\t\t\t}\n\t\t\thitSomething = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (Ray.Pos > MaxDistance) {\n\t\t\tfSteps -= (Ray.Pos-MaxDistance)/dist;\n\t\t\tbreak;\n\t\t}\n\t\t//ldist = dist;\n\t}\n\tif (dist ==floorDist*FudgeFactor) floorHit = true;\n\tvec3 hitColor=vec3(0.);\n\t//float stepFactor = clamp((fSteps)/float(GlowMax),0.0,1.0);\n\tvec3 backColor = BackgroundColor;\n    {\n\t\tfloat t = length(coord);\n\t\tbackColor = mix(backColor, vec3(0.0,0.0,0.0), t*GradientBackground);\n\t}\n\t\n\tif (steps==MaxRaySteps) orbitTrap = vec4(0.0);\n\t\n\tfloat shadowStrength = 0.0;\n\tif ( hitSomething ) {\n\t\tif (dist==lightde) {lighthit=true; return SpotLight.xyz*SpotLight.w/(LightSize+0.01);}\n\t\t// We hit something, or reached MaxRaySteps\n\t\thit = SRCurrentPt(Ray); //from + totalDist * direction;\n\t\tfloat ao = 0.; // = stepFactor ;\n\t\t\n\t\tif (floorHit) {\n\t\t\thitNormal = floorNormal;\n\t\t\tif(dot(floorNormal,p)-FloorHeight<0.) \n\t\t\t\thitNormal *=-1.0;\n\t\t} else {\n\t\t\thitNormal= normal(hit-NormalBackStep*epsModified*Ray.Direction, epsModified); \n\t\t}\n\t\t\n\n\t\thitColor = getColor();\n\n\t\tao = ambientOcclusion(hit, hitNormal);\n\t\tif (floorHit) {\n\t\t\thitColor = FloorColor;\n\t\t}\n\t\t\n\t\t//hitColor = mix(hitColor, AO.xyz ,ao);\n\t\thitColor = lighting(hitNormal, hitColor,  hit,  Ray.Direction,epsModified,shadowStrength,ao);\n\n\t}\n\telse {\n\n\t\thitColor = backColor;\n\t\thitNormal = vec3(0.0);\n\t\tRay.Pos=MaxDistance;\n\t}\nif(depthFlag) {\n                // do depth on the first hit not on reflections\n                depthFlag=false;\n                // for rendering depth to alpha channel in EXR images\n                // see http://www.fractalforums.com/index.php?topic=21759.msg87160#msg87160\n                gl_FragDepth = 1.0/Ray.Pos;\n\n        }\n\n\treturn hitColor;\n}\n\nfloat cnoyz(vec3 co){\n\tvec3 d=smoothstep(0.0,1.0,fract(co));\n\tco=floor(co);\n\tconst vec2 v=vec2(1.0,0.0);\n\treturn mix(mix(mix(rand(co),rand(co+v.xyy),d.x),\n\t\tmix(rand(co+v.yxy),rand(co+v.xxy),d.x),\n\t\td.y),mix(mix(rand(co+v.yyx),rand(co+v.xyx),d.x),\n\t\tmix(rand(co+v.yxx),rand(co+v.xxx),d.x),d.y),d.z);\n}\n\n\nfloat cloudDensity( in vec3 p , in vec3 cloudDir, in float t)\n{\n\tvec3 q=p/CloudScale;\n\tq/=vec3(1.0);\n\tfloat f=0.0,a=0.5;\n\tfor(int i=0;i<3;i++){\n    \t\tf+= a*cnoyz( q ); \n\t\tq = q*2.03;\n\t\ta = a*0.5;\n\t}\n\tfloat y=dot(p,cloudDir);\n\tfloat cDen=1.0 - 2.0*abs(0.5*(1.+CloudBase)-y)/(1.-CloudBase);\n\treturn clamp( CloudDensity * cDen - f, 0.0, 1.0 );\n}\n\nvec4 integrateClouds( in vec4 sum, in float dif, in float den, in float t )\n{\n    // lighting\n    vec3 lin = CloudColor*1.3 + SunLightColor*dif;        \n    vec4 col = vec4( mix(1.15*vec3(1.0,0.95,0.8), CloudColor2, den ), den );\n    col.xyz *= lin;\n\tcol=clamp(col,0.0,1.0);\n\tcol.xyz = mix( col.xyz, BackgroundColor, 1.-exp(-0.0025*t*t));\n    col.a *= mix(0.9,0.0,clamp(t*t/(MaxDistance*MaxDistance),0.0,1.0));\n    col.rgb *= col.a;\n    return sum + col*(1.0-sum.a);\n}\n\n\n\nvec4 clouds(vec3 p0, vec3 p1){\n\tvec3 ro=p0,rd=normalize(p1-p0),cloudDir=normalize(HF_Dir);\n    cloudDir=normalize(Clouds_Dir);\n\tvec4 sum = vec4(0.0);\n\tfloat t=0.1*CloudScale*rand(vec3(gl_FragCoord.xyy+30.0)),maxT=length(p1-p0);\n\tbool goingUp=(dot(rd,cloudDir)>0.0);\n\twhile(t<maxT) { \n\t\tvec3  pos = ro + t*rd; \n\t\tif((!goingUp && dot(pos,cloudDir)<CloudBase) || (goingUp && dot(pos,cloudDir)> 1.) || sum.a > 0.99) break; \n\t\tfloat den = cloudDensity(pos,cloudDir,t); \n\t\tif( den>0.01 ) { \n\t\t\tvec3 sundir=normalize(LightPos-pos);\n\t\t\tfloat dif = clamp((den - cloudDensity(pos+0.3*CloudScale*sundir,cloudDir,t))/0.6, -1.0, 1.0 ); \n\t\t\tsum = integrateClouds( sum, dif, den, t ); \n\t\t} \n\t\tt += 0.1*CloudScale+0.02*CloudScale*t*.99; \n\t}\n\treturn clamp(sum,0.0,1.0);\n}\n\n\nvec3 color(SRay Ray) {\n\tfloat glow=0.5;\n\tvec3 hitNormal = vec3(0.0);\n\tvec3 col = vec3(0.0);\n\tvec3 RWeight=vec3(1.);\n\n\tfor(int i=0; i<=ReflectionsNumber; i++) {\n\t\tvec3 prevPos = SRCurrentPt(Ray);\n\t\tvec3 col0 = trace(Ray, hitNormal, glow);\n\t\tvec3 curPos= SRCurrentPt(Ray);\n\t\tvec3 FG = fogAmount3(prevPos, curPos);\n\t\tcol0=mix(HF_Color.rgb*HF_Color.w,col0,FG);\t\t\n\n\t\tif(HF_Scatter*(HF_Intensity+HF_Const)>0.){ \n\t\t\tvec3 colfogglow=vec3(0.);\n\t\t\tcol0+=colfogglow*1./float(HF_FogIter);\n\t\t}\n\t\tvec4 clds=clouds(prevPos, curPos);\n\t\tcol0=col0*(1.0-clds.w)+clds.rgb;\t\n\t\tcol+=col0*RWeight;\n\t\tRWeight *= Reflection * FG;\n\t\tif (hitNormal == vec3(0.0) || dot(RWeight,RWeight)<0.0001 || lighthit || Ray.Pos>=MaxDistance) {//nothing hit or light hit or reflected light is too small\n\t\t\tbreak; \n\t\t}\n\t\t\n\t\tRay=SRReflect(Ray, hitNormal, 1.*minDist);\n\t}\n\treturn max(col, vec3(0));\n}\n\n\nvec2 uniformDisc(vec2 co) {\n\tvec2 r = rand2(co);\n\treturn sqrt(r.y)*vec2(cos(r.x*6.28),sin(r.x*6.28));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = viewCoord*(float(iFrame)+1.0);\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    vec3 hitNormal = vec3(0.0);\n\tvec3 hit;\n    vec2 PixelScale = 1./iResolution.xy;\n    vec3 from = Eye;\n    viewCoord = fragCoord;\n    coord = fragCoord;\n    \n    vec3 Dir = normalize(Target - Eye);\n    vec3 Right = normalize(cross(Dir, Up));\n    vec3 UpOrtho = normalize(cross(Right, Dir));\n\t\n    vec2 r = vec2(0.);\n\tif(ApertureNbrSides == 2)\n\t\t// We want to sample a circular diaphragm\n\t\tr = Aperture*uniformDisc(viewCoord*(float(iFrame)+1.0));\n\telse\n\t\t// We want to sample a polygonal diaphragm\n\t\tr = Aperture*NGonDisc(viewCoord*(float(iFrame)+1.0));\n\t\n\t//r*=1.-InFocusAWidth;//an error while modifying this script. It gives interresting result though. \n\n\t//jitter for multisampling\n\tvec2 disc = uniformDisc(coord*float(1+iFrame)); // subsample jitter\n\tvec2 jitteredCoord = coord + AntiAliasScale*PixelScale.y*FOV*disc;\n\t\n\t// Offset for DoF\n\tvec3 lensOffset =  r.x*Right + r.y*UpOrtho;\n\t//\"principal\" ray direction\n\tvec3 rayDir = (Dir+ jitteredCoord.x * Right + jitteredCoord.y * UpOrtho);\n\tfloat rayDirLength=length(rayDir);\n\tfloat FPO1= length(rayDir);\n\t\n\t//Construct the ray\n\tSRay Ray = SRay(from, rayDir/rayDirLength, lensOffset, 0., 1./max(1.,FPO1), 1./FocalPlane);\n\t\n\t//grab incoming light\n\tvec3 c =  color(Ray);\n\tfloat w =1.0-length(disc);\n    c*=w;\n\tfragColor += vec4(c, 1);\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"cst3DH","date":"0","viewed":0,"name":"[For]Rectangular domain coloring","username":"neozhaoliang","description":"The same domain coloring algorithm as https://www.shadertoy.com/view/tlcGzf, except rectangular.","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 f (vec2 z, float t, vec2 mouse) {\n    return cpow(z, 3.);\n}\n\nconst bool animate = true;\nconst bool grid = true; // (when not animating)\n\nconst float octaves = 4.0;\n\n// Grid lines:\nconst float lineWidth = 1.0;\nconst float lineFeather = 1.0;\nconst vec3 gridColor = vec3(0);\n\n// Power of contrast ramp function\n\nvec2 pixelToXY (vec2 point) {\n  \tvec2 aspect = vec2(1, iResolution.y / iResolution.x);\n    return (point / iResolution.xy - 0.5) * aspect * 5.0;\n}\n\n// Select an animation state\nfloat selector (float time) {\n    const float period = 10.0;\n    float t = fract(time / period);\n    return smoothstep(0.4, 0.5, t) * smoothstep(1.0, 0.9, t);\n}\n\nvec3 colorscale (float phase) {\n    return rainbow(phase / 2.0 - 0.25);\n}\n\nvec2 complexContouringGridFunction (vec2 x) {\n// distance to integer grid x=k, k in Z\n  return 2. * abs(fract(x - 0.5) - 0.5);\n}\n\nfloat checkerboard (vec2 xy) {\n// checker pattern with unit length squares\n  vec2 f = fract(xy * 0.5) * 2.0 - 1.0;\n  return f.x * f.y > 0.0 ? 1.0 : 0.0;\n}\n\nvec4 rectangularDomainColoring (vec4 f_df,\n                     vec2 steps,\n                     vec2 baseScale,\n                     vec2 gridOpacity,\n                     float shadingOpacity,\n                     float lineWidth,\n                     float lineFeather,\n                     vec3 gridColor,\n                     float phaseColoring\n) {\n  vec2 f = f_df.xy;\n  vec2 df = f_df.zw;\n  float absf = hypot(f);\n\n  baseScale *= 10.0;\n\n  // Computed as d|f|\n  float absdf = hypot(df);\n\n  float logdfx = log2(absdf) / log2(steps.x);  // logDx (|df|)\n  float Nx = floor(logdfx);\n  float fx = Nx + 1.0 - logdfx;\n\n  float logdfy = log2(absdf) / log2(steps.y);\n  float Ny = floor(logdfy);\n  float fy = Ny + 1.0 - logdfy;\n\n  // delta = D^{N} * m\n  vec2 delta = vec2(pow(steps.x, Nx), pow(steps.y, Ny)) * baseScale;\n  \n  float width1 = max(0.0, lineWidth - lineFeather);\n  float width2 = lineWidth + lineFeather;\n\n  float totalWeight = 0.0;\n  float shading = 0.0;\n\n  vec2 octaveScale = vec2(1.0);\n  vec2 grid = vec2(0.0);\n  vec2 gridScaleBase = vec2(\n    pow(steps.x, fx),\n    pow(steps.y, fy)\n  );\n\n  for(float i = 0.; i < octaves; i++) {\n    float w0 = i == 0. ? 1e-4 : i + 1.;\n    float w1 = i == octaves - 1. ? 1e-4 : i + 2.;\n    float w = mix(w0, w1, fx);\n\n    totalWeight += w;\n    vec2 value = f / delta * octaveScale;\n\n    vec2 gridSlope = baseScale * gridScaleBase / octaveScale / steps;\n    \n    \n    // draw contour lines for value = k, i.e. f / delta * octaveScale = k\n    vec2 xygrid = complexContouringGridFunction(value) * gridSlope;\n\n    grid += w * vec2(smoothstep(width2, width1, xygrid.x), smoothstep(width2, width1, xygrid.y));\n\n    shading += w * checkerboard(value);\n\n    octaveScale /= steps;\n  }\n\n  shading = shading / totalWeight;\n  grid /= totalWeight;\n  grid *= gridOpacity;\n\n  float carg = atan(f_df.y, f_df.x) * HALF_PI_INV * 2.0;\n  vec3 color = mix(vec3(1.0), clamp(colorscale(carg), 0.0, 1.0), phaseColoring);\n\n  const float gamma = 0.454;\n  color.r = pow(color.r, gamma);\n  color.g = pow(color.g, gamma);\n  color.b = pow(color.b, gamma);\n\n  color = mix(vec3(1), color, 0.97);\n\n  float mixedGrid = max(grid.x, grid.y);\n  float shade = mix(1.0, shading, shadingOpacity);\n  vec3 result = clamp(mix(color * shade, gridColor, mixedGrid), vec3(0), vec3(1));\n\n  result.r = pow(result.r, 1.0 / gamma);\n  result.g = pow(result.g, 1.0 / gamma);\n  result.b = pow(result.b, 1.0 / gamma);\n\n  return vec4(result, 1);\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 xy = pixelToXY(fragCoord);\n    vec2 mouse = pixelToXY(iMouse.xy);\n\n    vec2 fz = f(xy, iTime * 0.2, mouse);\n\n    // fwidth(fz) works, but it adds ugly anisotropy in the width of lines near zeros/poles.\n    // Insead, we compute the magnitude of the derivatives separately.\n    //\n    // Also *NOTE* that this is a very important place in which we use `hypot` instead of an\n    // algebraically equivalent built-in `length`. Floating point is limited and we lose lots\n    // of our floating point domain if we're not careful about over/underflow.\n    vec4 fdf = vec4(fz, vec2(hypot(dFdx(fz)), hypot(dFdy(fz))));\n\n   \tfloat select = animate ? selector(iTime) : (grid ? 1.0 : 0.0);\n\n    fragColor = rectangularDomainColoring(\n        fdf,\n        vec2(8.0), // steps\n        vec2(1.0), // scale\n        mix(vec2(0.4), vec2(1.0), select), // grid opacity\n        mix(0.2, 0.0, select),       // shading opacity\n        lineWidth,\n        lineFeather,\n        gridColor,\n        mix(1.0, 0.0, select)        // phase coloring\n    );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Complex math! Beware that these functions are not all great for overflow,\n// even though a GPU is precisely the sort of place where you ought to be \n// *very* concerned about overflow.\n//\n// This also includes a partial implementation of automatic differentiation\n// for complex arithmetic using vec4 as a + bi --> vec4(a, b, da, db). This\n// may be used to successfully avoid standard derivatives, though I just\n// didn't find it worthwhile when standard derivatives are so easy and well\n// supported.\n\n#define PI 3.141592653589793238\n#define TO_RADIANS 0.01745329251\n#define HALF_PI 1.57079633\n#define HALF_PI_INV 0.15915494309\n#define PI_INV 0.31830988618\n#define TWO_PI 6.28318530718\n\nfloat hypot (vec2 z) {\n  float x = abs(z.x);\n  float y = abs(z.y);\n  float t = min(x, y);\n  x = max(x, y);\n  t = t / x;\n  return x * sqrt(1.0 + t * t);\n}\n\nvec2 cadd (vec2 a, vec2 b) {\n  return a + b;\n}\n\nvec2 csub (vec2 a, vec2 b) {\n  return a - b;\n}\n\nfloat cmod (vec2 z) {\n  return hypot(z);\n} \n\nvec2 csqrt (vec2 z) {\n  float t = sqrt(2.0 * (cmod(z) + (z.x >= 0.0 ? z.x : -z.x)));\n  vec2 f = vec2(0.5 * t, abs(z.y) / t);\n\n  if (z.x < 0.0) f.xy = f.yx;\n  if (z.y < 0.0) f.y = -f.y;\n\n  return f;\n}\n\n/*\nfloat sinh (float x) {\n  return 0.5 * (exp(x) - exp(-x));\n}\n\nfloat cosh (float x) {\n  return 0.5 * (exp(x) + exp(-x));\n}*/\n\nvec2 sinhcosh (float x) {\n  vec2 ex = exp(vec2(x, -x));\n  return 0.5 * (ex - vec2(ex.y, -ex.x));\n}\n\nfloat cabs (vec2 z) {\n  return cmod(z);\n}\n\nvec2 clog(vec2 z) {\n  return vec2(\n    log(hypot(z)),\n    atan(z.y, z.x)\n  );\n}\n\nvec2 catan (vec2 z) {\n  float a = z.x * z.x + (1.0 - z.y) * (1.0 - z.y);\n  vec2 b = clog(vec2(1.0 - z.y * z.y - z.x * z.x, -2.0 * z.x) / a);\n  return 0.5 * vec2(-b.y, b.x);\n} \n\nvec2 catanh (vec2 z) {\n  float oneMinus = 1.0 - z.x;\n  float onePlus = 1.0 + z.x;\n  float d = oneMinus * oneMinus + z.y * z.y;\n\n  vec2 x = vec2(onePlus * oneMinus - z.y * z.y, z.y * 2.0) / d;\n\n  vec2 result = vec2(log(hypot(x)), atan(x.y, x.x)) * 0.5;\n\n  return result;\n} \n\nvec2 cacos (vec2 z) {\n  vec2 a = csqrt(vec2(\n    z.y * z.y - z.x * z.x + 1.0,\n    -2.0 * z.x * z.y\n  ));\n\n  vec2 b = clog(vec2(a.x - z.y, a.y + z.x));\n  return vec2(HALF_PI - b.y, b.x);\n} \n\nvec2 cacosh (vec2 z) {\n  vec2 a = cacos(z);\n\n  if (a.y <= 0.0) {\n    return vec2(-a.y, a.x);\n  }\n\n  return vec2(a.y, -a.x);\n} \n\nvec2 cacot (vec2 z) {\n  return catan(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 cacoth(vec2 z) {\n  return catanh(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 casin (vec2 z) {\n  vec2 a = csqrt(vec2(\n    z.y * z.y - z.x * z.x + 1.0,\n    -2.0 * z.x * z.y\n  ));\n\n  vec2 b = clog(vec2(\n    a.x - z.y,\n    a.y + z.x\n  ));\n\n  return vec2(b.y, -b.x);\n} \n\nvec2 casinh (vec2 z) {\n  vec2 res = casin(vec2(z.y, -z.x));\n  return vec2(-res.y, res.x);\n} \n\nvec2 cacsch(vec2 z) {\n  return casinh(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 casec (vec2 z) {\n  float d = dot(z, z);\n  return cacos(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 casech(vec2 z) {\n  return cacosh(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 cconj (vec2 z) {\n  return vec2(z.x, -z.y);\n} \n\nvec2 ccos (vec2 z) {\n  return sinhcosh(z.y).yx * vec2(cos(z.x), -sin(z.x));\n} \n\nvec2 ccosh (vec2 z) {\n  return sinhcosh(z.x).yx * vec2(cos(z.y), sin(z.y));\n} \n\nvec2 ccot (vec2 z) {\n  z *= 2.0;\n  vec2 sch = sinhcosh(z.y);\n  return vec2(-sin(z.x), sch.x) / (cos(z.x) - sch.y);\n} \n\nvec2 ccoth(vec2 z) {\n  z *= 2.0;\n  vec2 sch = sinhcosh(z.x);\n  return vec2(sch.x, -sin(z.y)) / (sch.y - cos(z.y));\n} \n\nvec2 ccsc (vec2 z) {\n  float d = 0.25 * (exp(2.0 * z.y) + exp(-2.0 * z.y)) - 0.5 * cos(2.0 * z.x);\n\n  return sinhcosh(z.y).yx * vec2(sin(z.x), -cos(z.x)) / d;\n} \n\nvec2 ccsch (vec2 z) {\n  vec2 sch = sinhcosh(z.x);\n  float d = cos(2.0 * z.y) - (exp(2.0 * z.x) + exp(-2.0 * z.x)) * 0.5;\n  return vec2(-cos(z.y), sin(z.y)) * sch / (0.5 * d);\n} \n\nvec2 cdiv (vec2 a, vec2 b) {\n  float e, f;\n  float g = 1.0;\n  float h = 1.0;\n\n  if( abs(b.x) >= abs(b.y) ) {\n    e = b.y / b.x;\n    f = b.x + b.y * e;\n    h = e;\n  } else {\n    e = b.x / b.y;\n    f = b.x * e + b.y;\n    g = e;\n  }\n\n  return (a * g + h * vec2(a.y, -a.x)) / f;\n} \n\nvec2 cexp(vec2 z) {\n  return vec2(cos(z.y), sin(z.y)) * exp(z.x);\n} \n\nvec2 cinv (vec2 b) {\n  float e, f;\n  vec2 g = vec2(1, -1);\n\n  if( abs(b.x) >= abs(b.y) ) {\n    e = b.y / b.x;\n    f = b.x + b.y * e;\n    g.y = -e;\n  } else {\n    e = b.x / b.y;\n    f = b.x * e + b.y;\n    g.x = e;\n  }\n\n  return g / f;\n} \n\nvec2 cmul (vec2 a, vec2 b) {\n  return vec2(\n    a.x * b.x - a.y * b.y,\n    a.y * b.x + a.x * b.y\n  );\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c) {\n  return cmul(cmul(a, b), c);\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c, vec2 d) {\n  return cmul(cmul(a, b), cmul(c, d));\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c, vec2 d, vec2 e) {\n  return cmul(cmul(a, b, c), cmul(d, e));\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c, vec2 d, vec2 e, vec2 f) {\n  return cmul(cmul(a, b, c), cmul(d, e, f));\n} \n\nvec2 cpolar (vec2 z) {\n  return vec2(\n    atan(z.y, z.x),\n    hypot(z)\n  );\n} \n\nvec2 cpow (vec2 z, float x) {\n  float r = hypot(z);\n  float theta = atan(z.y, z.x) * x;\n  return vec2(cos(theta), sin(theta)) * pow(r, x);\n}\n\nvec2 cpow (vec2 a, vec2 b) {\n  float aarg = atan(a.y, a.x);\n  float amod = hypot(a);\n\n  float theta = log(amod) * b.y + aarg * b.x;\n\n  return vec2(\n    cos(theta),\n    sin(theta)\n  ) * pow(amod, b.x) * exp(-aarg * b.y);\n} \n\nvec2 csec (vec2 z) {\n  float d = 0.25 * (exp(2.0 * z.y) + exp(-2.0 * z.y)) + 0.5 * cos(2.0 * z.x);\n  return sinhcosh(z.y).yx * vec2(cos(z.x), sin(z.x)) / d;\n} \n\nvec2 csech(vec2 z) {\n  float d = cos(2.0 * z.y) + 0.5 * (exp(2.0 * z.x) + exp(-2.0 * z.x));\n  vec2 sch = sinhcosh(z.x);\n\n  return vec2(cos(z.y), -sin(z.y)) * sch.yx / (0.5 * d);\n} \n\nvec2 csin (vec2 z) {\n  return sinhcosh(z.y).yx * vec2(sin(z.x), cos(z.x));\n} \n\nvec4 csincos (vec2 z) {\n  float c = cos(z.x);\n  float s = sin(z.x);\n  return sinhcosh(z.y).yxyx * vec4(s, c, c, -s);\n} \n\nvec2 csinh (vec2 z) {\n  return sinhcosh(z.x) * vec2(cos(z.y), sin(z.y));\n} \n\nvec2 csqr (vec2 z) {\n  return vec2(\n    z.x * z.x - z.y * z.y,\n    2.0 * z.x * z.y\n  );\n} \n\nvec2 ctan (vec2 z) {\n  vec2 e2iz = cexp(2.0 * vec2(-z.y, z.x));\n\n  return cdiv(\n    e2iz - vec2(1, 0),\n    vec2(-e2iz.y, 1.0 + e2iz.x)\n  );\n} \n\nvec2 ctanh (vec2 z) {\n  z *= 2.0;\n  vec2 sch = sinhcosh(z.x);\n  return vec2(sch.x, sin(z.y)) / (sch.y + cos(z.y));\n}\n\n\nvec4 cmul (vec4 a, vec4 b) {\n  return vec4(\n    cmul(a.xy, b.xy),\n    cmul(a.xy, b.zw) + cmul(a.zw, b.xy)\n  );\n}\n\nvec4 cmul (vec2 a, vec4 b) {\n  return vec4(\n    cmul(a.xy, b.xy),\n    cmul(a.xy, b.zw)\n  );\n}\n\nvec4 cmul (vec4 a, vec2 b) {\n  return vec4(\n    cmul(a.xy, b.xy),\n    cmul(a.zw, b.xy)\n  );\n}\n\nvec4 cmul (vec4 a, vec4 b, vec4 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec2 a, vec4 b, vec4 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec4 a, vec2 b, vec4 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec4 a, vec4 b, vec2 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec4 a, vec2 b, vec2 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec2 a, vec4 b, vec2 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec2 a, vec2 b, vec4 c) { return cmul(cmul(a, b), c); }\n\nvec4 csqr (vec4 a) {\n  return vec4(\n    csqr(a.xy),\n    2.0 * cmul(a.xy, a.zw)\n  );\n}\nvec4 cdiv (vec4 a, vec4 b) {\n  return vec4(\n    cdiv(a.xy, b.xy),\n    cdiv(cmul(b.xy, a.zw) - cmul(a.xy, b.zw), csqr(b.xy))\n  );\n}\n\nvec4 cdiv (vec2 a, vec4 b) {\n  return vec4(\n    cdiv(a.xy, b.xy),\n    cdiv(-cmul(a.xy, b.zw), csqr(b.xy))\n  );\n}\n\nvec4 cdiv (vec4 a, vec2 b) {\n  return vec4(\n    cdiv(a.xy, b.xy),\n    cdiv(cmul(b.xy, a.zw), csqr(b.xy))\n  );\n}\n\nvec4 csub(vec4 a, vec4 b) {\n  return a - b;\n}\n\nvec4 csub(vec2 a, vec4 b) {\n  return vec4(a.xy - b.xy, -b.zw);\n}\n\nvec4 csub(vec4 a, vec2 b) {\n  return vec4(a.xy - b.xy, a.zw);\n}\n\nvec4 cadd(vec4 a, vec4 b) {\n  return a + b;\n}\n\nvec4 cadd(vec2 a, vec4 b) {\n  return vec4(a.xy + b.xy, b.zw);\n}\n\nvec4 cadd(vec4 a, vec2 b) {\n  return vec4(a.xy + b.xy, a.zw);\n}\n\n\nvec4 cinv(vec4 a) {\n  vec2 ainv = cinv(a.xy);\n  return vec4(ainv, cmul(a.zw, -csqr(ainv)));\n}\n\nvec4 cexp(vec4 a) {\n  vec2 expa = cexp(a.xy);\n  return vec4(expa, cmul(expa, a.zw));\n}\n\nvec4 csqrt(vec4 a) {\n  float r = hypot(a.xy);\n  float b = sqrt(2.0 * (r + a.x));\n  float c = sqrt(2.0 * (r - a.x));\n  float re = a.x >= 0.0 ? 0.5 * b : abs(a.y) / c;\n  float im = a.x <= 0.0 ? 0.5 * c : abs(a.y) / b;\n  vec2 s = vec2(re, a.y < 0.0 ? -im : im);\n  return vec4(s, cmul(a.zw, 0.5 * cinv(s)));\n}\n\n/*vec4 cpow(vec4 a, float n) {\n  float theta = atan(a.y, a.x);\n  float r = hypot(a.xy);\n  float tn = theta * n;\n  float rn = pow(r, n);\n  vec2 s = rn * vec2(sin(tn), cos(tn));\n  float rn1 = pow(r, n - 1.0);\n  float tn1 = theta * (n - 1.0);\n  return vec4(s, cmul(a.zw, n * rn1 * vec2(sin(tn1), cos(tn1))));\n}*/\n\nvec4 clog(vec4 z) {\n  return vec4(\n    log(hypot(z.xy)),\n    atan(z.y, z.x),\n    cdiv(z.zw, z.xy)\n  );\n}\n\nvec4 csin(vec4 a) {\n  vec4 asincos = csincos(a.xy);\n  return vec4(asincos.xy, cmul(asincos.zw, a.zw));\n}\n\nvec4 ccos(vec4 a) {\n  vec4 asincos = csincos(a.xy);\n  return vec4(asincos.zw, cmul(-asincos.xy, a.zw));\n}\n\nvec4 ctan(vec4 a) {\n  return cdiv(csin(a), ccos(a));\n}\n\nvec4 casin(vec4 z) {\n  vec4 s = clog(vec4(-z.y, z.x, -z.w, z.z) + csqrt(csub(vec2(1, 0), csqr(z))));\n  return vec4(s.y, -s.x, s.w, -s.z);\n}\n\nvec4 cacos(vec4 z) {\n  vec4 s = -casin(z);\n  s.x += HALF_PI;\n  return s;\n}\n\nvec4 catan(vec4 z) {\n  vec2 s = clog(cdiv(cadd(vec2(0, 1), z.xy), csub(vec2(0, 1), z.xy)));\n  return vec4(\n     0.5 * vec2(-s.y, s.x),\n     cmul(z.zw, cinv(cadd(vec2(1, 0), csqr(z))))\n  );\n}\n\nvec4 csinh(vec4 z) {\n  vec4 ez = cexp(z);\n  return 0.5 * (ez - cinv(ez));\n}\n\nvec4 ccosh(vec4 z) {\n  vec4 ez = cexp(z);\n  return 0.5 * (ez + cinv(ez));\n}\n\nvec4 ctanh(vec4 z) {\n  vec4 ez = cexp(z);\n  vec4 ezinv = cinv(ez);\n  return 0.5 * cdiv(ez - ezinv, ez + ezinv);\n}\n\nvec4 casinh(vec4 z) {\n  return clog(cadd(z, csqrt(cadd(vec2(1, 0), csqr(z)))));\n}\n\nvec4 cacosh(vec4 z) {\n  return clog(z + cmul(csqrt(cadd(z, vec2(1, 0))), csqrt(csub(z, vec2(1, 0)))));\n}\n\nvec4 catanh(vec4 z) {\n  return 0.5 * clog(cdiv(cadd(z, vec2(1,  0)), csub(vec2(1, 0), z)));\n}\n\n// https://github.com/d3/d3-color\n// Copyright 2010-2016 Mike Bostock\n// All rights reserved.\n// \n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n// \n// * Redistributions of source code must retain the above copyright notice, this\n//   list of conditions and the following disclaimer.\n// \n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// \n// * Neither the name of the author nor the names of contributors may be used to\n//   endorse or promote products derived from this software without specific prior\n//   written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nvec3 cubehelix(vec3 c) {\n  vec2 sc = vec2(sin(c.x), cos(c.x));\n  return c.z * (1.0 + c.y * (1.0 - c.z) * (\n    sc.x * vec3(0.14861, 0.29227, -1.97294) + \n    sc.y * vec3(1.78277, -0.90649, 0.0)\n  ));\n}\n\nvec3 rainbow(float t) {\n  return cubehelix(vec3(\n    TWO_PI * t - 1.74533,\n    (0.25 * cos(TWO_PI * t) + 0.25) * vec2(-1.5, -0.9) + vec2(1.5, 0.8)\n  ));\n}","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"ctVyWD","date":"0","viewed":0,"name":"forkforHyperbolic tilings: intro","username":"neozhaoliang","description":"This is similar to Shane's work https://www.shadertoy.com/view/WlBczG but uses a different approach.","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Hyperbolic tilings: intro\" by None. https://shadertoy.com/view/-1\n// 2023-11-17 15:16:59\n\n/*\n    A mimic of shane's work at https://www.shadertoy.com/view/WlBczG.\n    \n    Show the basic procedure to draw a 2d hyperbolic Poincare tiling.\n    \n    Also can draw paracompact and noncompact tilings (with ideal and hyperideal vertices)\n\n*/\n// show the three reflection mirrors\n//#define debug_mirrors\n\n// comment out this to see the initial pattern\n//#define enableMouseInversion\n\n// change to Klein model\n//#define KleinModel\n\n// set inf = 1.0 for paracompact tiling\n// set inf > 1.0 for noncompact tiling\n#define inf       1.0\n\n#define PI\t\t  3.14159265\n#define TAU\t      6.28318531\n#define MAX_ITER  30\n\n\n// the smaller this value, the larger the black area\n#define BlackRegionSize   0.065\n\n// the first entry in PQR must be finite, other two entries can be either finite or infinite\n// for example (3, inf 4), (3, 4, inf), etc\nconst vec3 PQR = vec3(3, inf, 3);\n\n\n// reflection mirrors\nvec2 A, B;\nvec3 C;\n\n// two vertices of the fundamental triangle, the 3rd one is the origin\nvec2 v0, m0;\n\n// count the number of reflections across each mirror\nfloat count;\n\n// compute cos(PI / x), for x = infiniy this is inf using Vinberg's convention.\nfloat dihedral(float x) { return x == inf ? inf : cos(PI / x); }\n\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\nvoid init() {\n\n    float cAB = dihedral(PQR.x);\n    float sAB = sqrt(1. - cAB*cAB);\n    \n\tA = vec2(1, 0);\n    B = vec2(-cAB, sAB);\n    \n    float cAC = dihedral(PQR.y);\n    float cBC = dihedral(PQR.z);\n    \n    float k1 = cAC;\n    float k2 = (cBC + cAB*cAC) / sAB;\n    float r = 1. / sqrt(k1*k1 + k2*k2 - 1.);\n    \n    C = vec3(k1, k2, 1.)*r;\n    \n    if (r*r >= C.x*C.x)\n        v0 = vec2(0., C.y - sqrt(r*r - C.x*C.x));\n    else\n        v0 = vec2(0, 1);\n        \n    vec2 n = vec2(-B.y, B.x);\n    float b = dot(C.xy, n);\n    float c = dot(C.xy, C.xy) - r*r;\n    float k = -1.0;\n    \n    if (b*b >= c)\n        k = b + sqrt(b*b-c);\n    \n    m0 = k*n;\n}\n\n\nbool try_reflect(inout vec2 p, vec2 mirror, inout float count) {\n    float k = dot(p, mirror);\n    if (k >= 0.)\n        return true;\n    p -= 2. * k  * mirror;\n    count += 1.;\n    return false;\n}\n\n\nbool try_reflect(inout vec2 p, vec3 sphere, inout float count) {\n    vec2 cen = sphere.xy;\n    float r = sphere.z;\n    float d = length(p - cen) - r;\n    if (d >= 0.)\n        return true;\n    p -= cen;\n    p *= r * r/ dot(p, p);\n    p += cen;\n    count += 1.;\n    return false;\n}\n\n\nvoid fold(inout vec2 p, inout float count) {\n    count = 0.;\n    for (int k = 0; k < MAX_ITER; k++) {\n        try_reflect(p, A, count);\n        try_reflect(p, B, count);\n        try_reflect(p, C, count);\n    }\n}\n\nvoid fold2(inout vec2 p, inout float count) {\n    count = 0.;\n    for (int k = 0; k < MAX_ITER; k++) {\n        try_reflect(p, A, count);\n        //try_reflect(p, B, count);\n        try_reflect(p, C, count);\n    }\n}\n\n\nfloat sBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew) {\n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n\nvec2 mouseInversion(vec2 p) {\n    vec2 m = vec2((2.*iMouse.xy - iResolution.xy)/iResolution.y);\n    if(length(m) < 1e-3) m += 1e-3; \n    if(abs(m.x)>.98*.7071 || abs(m.y)>.98*.7071) m *= .98;\n\n    float k = 1./dot(m, m);\n    vec2 invCtr = k*m;\n    float t = (k - 1.)/dot(p -invCtr, p - invCtr);\n    p = t*p + (1. - t)*invCtr;\n    p.x = -p.x;\n    return p;    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    uv *= 1.05;\n    vec2 p = uv;\n    \n#ifdef enableMouseInversion\n    p = mouseInversion(p);\n    p = rot2(iTime/16.)*p;\n#endif\n\n    init();   \n    \n    if(length(p)> 1.)\n        p /= dot(p, p);\n        \n#ifdef KleinModel\n    p = p / (1. + sqrt(1. - dot(p, p)));\n#endif\n    vec2 q = p;\n    float count2= count;\n    fold(p, count);\n    fold2(q, count2);\n    \n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    ln = min(ln, lBox(p, vec2(0), v0, .007));    \n    ln = min(ln, lBox(p, vec2(0), m0, .007));\n    ln = min(ln, length(p-C.xy) - C.z - 0.007);\n\n    ln2 = min(ln2, lBox(p, vec2(0), m0, .007));\n    pnt = min(pnt, length(p - v0)); \n    pnt = min(pnt, length(p - m0));\n   \n    float ssf = (2. - smoothstep(0., .25, abs(length(uv) - 1.) - .25));\n    float sf = 2./iResolution.y*ssf;\n        \n    vec3 oCol = .55 + .45*cos(count*TAU / 8. + vec3(0, 1, 2));\n    float pat = smoothstep(0., .25, abs(fract(ln2*50. - .2) - .5)*2. -.2);\n   \n    float sh = clamp(.65 + ln/v0.y*4., 0., 1.);\n    \n    vec3 col = min(oCol*(pat*.2 + .9)*sh, 1.);\n    \n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - BlackRegionSize)));\n\n    pnt = min(pnt, length(p));\n    float ddd = length(q - vec2(0.15, 0.3));\n    int id = (pnt < ddd) ? 0 : 1;\n    pnt = min(pnt, ddd) - 0.032;\n   \n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnt));\n    \n    if (id == 0)\n        col = mix(col, vec3(1, .8, .3), 1. - smoothstep(0., sf, pnt + .02));\n    else\n        col = mix(col, vec3(3., .2, .8), 1. - smoothstep(0., sf, pnt));\n    \n    vec3 bg = vec3(1, .2, .4);\n    bg *= .7*(mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .5)*.5 + .5);\n    pat = smoothstep(0., .25, abs(fract((uv.x - uv.y)*43. - .25) - .5)*2. -.5);\n    bg *= max(1. - length(uv)*.5, 0.)*(pat*.2 + .9);\n    \n    float cir = length(uv);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*10., abs(cir - 1.) - .05))*.7);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., abs(cir - 1.) - .05)));\n    col = mix(col, vec3(.9) + bg, (1. - smoothstep(0., sf, abs(cir - 1.) - .03)));\n    col = mix(col, col*max(1. - length(uv)*.5, 0.), (1. - smoothstep(0., sf, -cir + 1.05)));\n    col = mix(col, bg, (1. - smoothstep(0., sf, -cir + 1.05)));\n    \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(cir - 1.035) - .03))*.8);\n    col = mix(col, 1. - exp(-col), .35);\n\n#ifdef debug_mirrors\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.01, abs(dot(uv, A)) - 0.01));\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.01, abs(dot(uv, B)) - 0.01));\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.02, abs(length(uv-C.xy) - C.z))-0.01);\n#endif\n\n    fragColor = vec4(sqrt(max(col, 0.)), 1.);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"dtdGWn","date":"0","viewed":0,"name":"liang fork Apollonian","username":"neozhaoliang","description":"The classic standard apollonian/kleinian fractal (everybody needs to render one at some point).","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Apollonian\" by iq. https://shadertoy.com/view/4ds3zn\n// 2023-04-23 15:41:41\n\n// Created by inigo quilez - iq/2013\n//   https://www.youtube.com/c/InigoQuilez\n//   https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n\n// I can't recall where I learnt about this fractal.\n//\n// Coloring and fake occlusions are done by orbit trapping, as usual.\n\n\n// Antialiasing level\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2 // Make it 3 if you have a fast machine\n#endif\n\nvec4 orb; \n\nfloat map( vec3 p, float s )\n{\n float DEfactor=1.;\n\tfloat scale = 1.0;\n\n\torb = vec4(1000.0); \n\t\n\t float d = map(p, DEfactor, orbitTrap);\n\n\t\n\treturn 0.25*d/scale;\n}\n\nfloat trace( in vec3 ro, in vec3 rd, float s )\n{\n\tfloat maxd = 30.0;\n    float t = 0.01;\n    for( int i=0; i<512; i++ )\n    {\n\t    float precis = 0.001 * t;\n        \n\t    float h = map( ro+rd*t, s );\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float s )\n{\n    float precis = 0.001 * t;\n\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy, s ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, s ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, s ) + \n                      e.xxx*map( pos + e.xxx, s ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float anim )\n{\n    // trace\t\n    vec3 col = vec3(0.0);\n    float t = trace( ro, rd, anim );\n    if( t>0.0 )\n    {\n        vec4 tra = orb;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t, anim );\n\n        // lighting\n        vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n        vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n        float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n        float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n        float amb = (0.7+0.3*nor.y);\n        float ao = pow( clamp(tra.w*2.0,0.0,1.0), 1.2 );\n\n        vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*ao;\n        brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n        brdf += 1.0*vec3(0.40,0.40,0.40)*bac*ao;\n\n        // material\t\t\n        vec3 rgb = vec3(1.0);\n        rgb = mix( rgb, vec3(1.0,0.80,0.2), clamp(6.0*tra.y,0.0,1.0) );\n        rgb = mix( rgb, vec3(1.0,0.55,0.0), pow(clamp(1.0-2.0*tra.z,0.0,1.0),8.0) );\n\n        // color\n        col = rgb*brdf*exp(-0.2*t);\n    }\n\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init();\n    float time = iTime*0.25;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 1, jj = 1;\n    #endif\n    {\n        vec2 q = fragCoord.xy+vec2(float(ii),float(jj))/float(AA);\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n\n        // camera\n        vec3 ro = vec3( 2.8*cos(0.1+.33*time), 0.4 + 0.30*cos(0.37*time), 2.8*cos(0.5+0.35*time) ).xzy;\n        vec3 ta = vec3( 1.9*cos(1.2+.41*time), 0.4 + 0.10*cos(0.27*time), 1.9*cos(2.0+0.38*time) ).xzy;\n        float roll = 0.2*cos(0.1*time);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(roll), 0., cos(roll));\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        tot += render( ro, rd, anim );\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"int euclideanTriangleType = 1;\nvec3 dihedralAngles0_234 = vec3(3, 2, 7);\nvec3 dihedralAngles1_234 = vec3(2, 3, 7);\nfloat dihedralAngle0_1 = 4.;\nvec4 isRealBall = vec4(0);\nint Iterations = 39;\nfloat DEcor = 1.;\nvec4 orbitTrap;\n\n#define inf           1.0\n#define L2(x)         dot(x, x)\n#define PI           3.141592653\n\n//infinite foldings-----------------------------------------------------------//\n//fold about line with normal ndir (normalized) and dist to origin d.\nvoid fold(inout vec2 p, in vec2 ndir, in float d) {\n    float t = dot(p, ndir) + d;\n    t = 2.*min(t,0.);\n    p -= t * ndir;\n}\n\n//fmod with step = stp\nvoid infmod(inout float x, float stp) {\n    x *= 1./stp;\n    x -= floor(x);\n    x *= stp;\n}\n\n//infinite fold. stp is the tile size.\n//its like performing infinite folds about plane at 0 and plane at stp\nvoid inffold(inout float x, float stp) {\n    x *= 1./(2.*stp);\n    x -= floor(x);\n    x  = 0.5 - abs( x - 0.5 );\n    x *= 2.*stp;\n}\n\n//Simplest: fold into unit square then about the diagonal\nvoid fold244(inout vec2 p) {\n    inffold( p.x , 1. );\n    inffold( p.y , 1. );\n#define VAL sqrt(2.)/2.\n    fold( p, -vec2( VAL, VAL ), VAL);\n#undef VAL\n}\n\n//fold into rectangle then a little sequence of line folds.\nvoid fold236(inout vec2 p) {\n#define S3 sqrt(3.)\n    inffold( p.x , 3. );\n    inffold( p.y , S3 );\n    vec2 n = -0.5 * vec2(S3, 1.);\n    float d = .5 * S3;\n    fold(p, n, d);\n    p = abs(p);\n    fold(p, n, d);\n#undef S3\n}\n\n//most complicated\nvoid fold333(inout vec2 p) {\n#define S3 sqrt(3.)\n    //change origin\n    p.x += 1.;\n    //fold y into segment of height sqrt(3)\n    inffold( p.y ,S3 );\n    //change of coordinates to go to ( (2,0) ; (1,sqrt(3)) ) ish basis. We only nees x coordinate to be transformed\n    p.x -= p.y * 1. / S3;\n    //do an fmod instead for x.\n    infmod(p.x, 6.);\n    //undo the coordinates change\n    p.x += p.y * 1./S3;\n    //The folding sequence... 4 folds\n    //There are other choices. I've choosen the one where I need only one direction instead of two.\n    vec2 n = -0.5 * vec2(S3, 1.);\n    float d = 2. * S3;\n    //1st\n    fold(p, n, d);\n    //2nd\n    d = S3;\n    fold(p, n, d);\n    //3rd\n    p.y = abs(p.y);\n    //4th same as 2nd\n    fold(p, n, d);\n    //restore origin\n    p.x -=1.;\n#undef S3\n}\n\nconst float s2 = sqrt(2.);\nconst float s3 = sqrt(3.);\n\nfloat dihedral(float x) {\n    return x == inf ? inf : cos(PI / x);\n}\n\nvec3 dihedral(vec3 v) {\n    return vec3(dihedral(v.x), dihedral(v.y), dihedral(v.z));\n}\n\nstruct Ball {\n    bool isplane;\n    vec3 n;\n    float r;\n    bool invert;\n    bool isRealBall;\n};\n\n// coclusters are mirror balls, they corresponde to root vectors (space-like)\nBall[5] coclusters;\n// clusters are real balls, they corresponde to space-like weight vectors\nBall[5] clusters;\n\nBall defaultBall() {\n    return Ball(false, vec3(0, 0, -1), 0., false, false);\n}\n\n// Distance from a point to a ball\nfloat sdistanceToBall(vec3 p, Ball B) {\n    if (B.isplane) {\n        float k = dot(vec4(p, 1), vec4(B.n, B.r));\n        return k;\n    }\n    else\n        return length(p - B.n) - B.r;\n}\n\nBall from_plane(vec3 n, float d) {\n    return Ball(true, n, d, false, false);\n}\n\nBall from_sphere(vec3 cen, float r) {\n    return Ball(false, cen, r, false, false);\n}\n\nvoid invertBall(inout Ball B) {\n    B.invert = !B.invert;\n}\n\nbool try_reflect(inout vec3 p,\n                 in Ball B,\n                 inout float scale,\n                 inout vec4 orb) {\n    orb = min(orb, vec4(abs(p),dot(p,p)));\n    if (B.isplane) {\n        float k = dot(vec4(p, 1), vec4(B.n, B.r));\n        if (k >= 0.)\n            return true;\n        p -= 2. * k  * B.n;\n        return false;\n    }\n    else {\n        vec3 cen = B.n;\n        float r = B.r;\n        vec3 q = p - cen;\n        float d2 = dot(q, q);\n        float k = (r * r) / d2;\n        if ( (k < 1.0 && B.invert) || (k > 1. && !B.invert) )\n            return true;\n        else {\n            scale *= k;\n            p = k * q + cen;\n            return false;\n        }\n    }\n}\n\nBall solveBall(mat3 M, vec3 b) {\n    vec3 p = b * inverse(M);\n    return from_sphere(vec3(p.xy, 0.), p.z);\n}\n\nBall solveBall(vec2 P, Ball B0, Ball B1) {\n    if (B0.isplane) {\n        float z = B0.r;\n        vec3 cen = vec3(P, z);\n        float R = sqrt(L2(cen - B1.n) - B1.r*B1.r);\n        return from_sphere(cen, R);\n    }\n    else {\n        float r1 = B1.r;\n        float r0 = B0.r;\n        float z0 = B0.n.z;\n        float k0 = L2(P - B0.n.xy);\n        float k1 = L2(P - B1.n.xy);\n        float z = (r1*r1 - r0*r0 + z0*z0 + k0 - k1) / (2.*z0);\n        float R = sqrt(k1 + z*z - r1*r1);\n        return from_sphere(vec3(P, z), R);\n    }\n}\n\nvoid init() {\n\n    mat3 M0, M1;\n    vec3 b;\n    Ball B0, B1, B2, B3, B4;\n    vec3 t0 = dihedral(dihedralAngles0_234);\n    vec3 t1 = dihedral(dihedralAngles1_234);\n    float t01 = dihedral(dihedralAngle0_1);\n    // A, B, C are the vertices of the triangle formed by mirror plane v2, v3, v4 and z=0 plane\n    vec2 A, B, C;\n\n    // the 236 case\n    if (euclideanTriangleType == 0) {\n        A = vec2(0, 0), B = vec2(0, s3), C = vec2(1, 0);\n        B2 = from_plane(vec3(1, 0, 0), 0.);\n        B3 = from_plane(vec3(-s3/2., -0.5, 0), s3/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(1, 0, -t1.x), vec3(s3/2., 0.5, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(1, 0, -t0.x), vec3(s3/2., 0.5, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(0, s3/2., 0);\n    }\n\n    // the 244 case\n    else if (euclideanTriangleType == 1) {\n        A = vec2(0, 0), B = vec2(0, 1), C = vec2(1, 0);\n        B2 = from_plane(vec3(1, 0, 0), 0.);\n        B3 = from_plane(vec3(-s2/2., -s2/2., 0), s2/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(1, 0, -t1.x), vec3(1./s2, 1./s2, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(1, 0, -t0.x), vec3(1./s2, 1./s2, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(0, s2/2., 0);\n    }\n\n    // the 333 case\n    else {\n        A = vec2(-1, 0), B = vec2(0, s3), C = vec2(1, 0);\n        B2 = from_plane(vec3(s3/2., -.5, 0), s3/2.);\n        B3 = from_plane(vec3(-s3/2., -.5, 0), s3/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(-s3/2., 0.5, t1.x), vec3(s3/2., .5, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(-s3/2., 0.5, t0.x), vec3(s3/2., .5, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(s3, s3, 0)/2.;\n    }\n\n    // now we solve the virtual ball B1, this can't be a plane\n    B1 = solveBall(M1, b);\n    invertBall(B1);\n\n    // now we solve the virtual ball B0, this can be either a plane or a sphere\n    // this depends on if all entries in dihedralAngles0 are all 2\n    if (dot(dihedralAngles0_234, vec3(1)) == 6.) {\n        B0 = from_plane(vec3(0, 0, -1), B1.r*t01);\n    }\n    else {\n        B0 = solveBall(M0, b);\n        float r1 = B1.r, r0 = B0.r;\n        B0.n.z = sqrt(r0*r0 + r1*r1 + 2.*r0*r1*t01 - L2(B1.n.xy - B0.n.xy));\n        invertBall(B0);\n    }\n    coclusters = Ball[5] (B0, B1, B2, B3, B4);\n\n    //now we process the real balls\n    for (int k = 0; k < 5; k++) {\n        clusters[k] = defaultBall();\n    }\n\n    clusters[1] = from_plane(vec3(0, 0, -1.), B0.n.z);\n    clusters[1].isRealBall = isRealBall.x == 1.;\n\n    clusters[2] = solveBall(C, B0, B1);\n    clusters[2].isRealBall = isRealBall.y == 1.;\n\n    clusters[3] = solveBall(A, B0, B1);\n    clusters[3].isRealBall = isRealBall.z == 1.;\n\n    clusters[4] = solveBall(B, B0, B1);\n    clusters[4].isRealBall = isRealBall.w == 1.;\n}\n\n#if 1\n// In this version, invisible (non active) real balls are used to reduce oerstepping.\n// One may notice that when activating other balls the ovestepping is educed a lot.\n// Not very good but better than nothing. :)\nfloat dist2balls(vec3 p, float scale) {\n    float d = abs(p.z); //Ball 0\n    for (int j = 1; j < 5; j++) {\n        float s = clusters[j].isRealBall ? 0. : DEcor*scale;\n        d = min( s + abs( sdistanceToBall( p, clusters[j] ) ) , d );\n    }\n    return d/scale;\n}\n#else\n// Normal version\nfloat dist2balls( vec3 p, float scale) {\n    float d = abs(p.z); //Ball 0\n    for (int j = 1; j < 5; j++)\n        if (clusters[j].isRealBall)\n            d = min(abs(sdistanceToBall(p, clusters[j])), d);\n    return d/scale;\n}\n#endif\n\nvoid EuclideanFold(inout vec3 p) {\n    if( euclideanTriangleType == 0)\n        fold236(p.xy);\n    else if ( euclideanTriangleType == 1)\n        fold244(p.xy);\n    else\n        fold333(p.xy);\n}\n\nfloat map(inout vec3 p, inout float scale, inout vec4 orb) {\n    float d = dist2balls(p, scale);\n    // bool cond = true;\n    // K: Very strange behaviour : doing cond && tru_reflect() cuts things out.\n    // Remove all those tests and just see if the orbit stops. Now DE is \"much\" better.\n    for (int i = 0; i < Iterations ; i++) {\n        vec3 ap = p;\n        EuclideanFold(p);\n        for (int k = 0; k < 2; k++)\n            try_reflect(p, coclusters[k], scale, orb);\n        if (all(not(bvec3(p-ap))))\n            break;\n        d = min( d, dist2balls(p, scale));\n    }\n#if 0\n    // Slow version. DEs to balls are each iterations\n    return d;\n#else\n    // Fast version. distance to balls is done only once.\n    return dist2balls(p, scale);\n#endif\n}\n\nfloat DE(vec3 p) {\n    float DEfactor=1.;\n    //orbiTrap is not initialized by default. That's what was producing the strange haze and colors.\n    orbitTrap = vec4(1);\n    float d = map(p, DEfactor, orbitTrap);\n\n    //Call basic shape and scale its DE\n    return 0.3 * d ;// Fudging here because fudge factor desn't seem to affect shadows :-/\n}\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"dsBfR3","date":"0","viewed":0,"name":"my fork Neo three worlds","username":"neozhaoliang","description":"Motivated by Escher's artwork \"three worlds\", try to combine spherical, Euclidean, hyperbolic geometry in one scene. See three worlds through the mirrors at the same time.","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Neo three worlds\" by neozhaoliang. https://shadertoy.com/view/ss2cz3\n// 2023-07-21 12:05:54\n\nvec3 get_floor_color(vec2 z) {\n    // Modify P, Q, R to change the tiling\n    const float P = 2.;\n    const float Q = 3.;\n    const float R = 7.;\n    const float cp = cos(PI / P), sp = sin(PI / P);\n    const vec2 mB = vec2(-cp, sp);\n    const float k1 = cos(PI / Q);\n    const float k2 = (cos(PI / R) + cp * k1) / sp;\n    const float rad = 1. / sqrt(k1 * k1 + k2 * k2 - 1.);\n    const vec2 cen = vec2(k1 * rad, k2 * rad);\n    const vec2 v0 = vec2(0, cen.y - sqrt(rad * rad - cen.x * cen.x));\n    const vec2 n_ = vec2(-mB.y, mB.x);\n    const float b_ = dot(cen, n_);\n    const float c_ = dot(cen, cen) - rad * rad;\n    const float k_ = b_ + sqrt(b_ * b_ - c_);\n    const vec2 m0 = k_ * n_;\n\n    vec2 p = square_to_disc(z);\n    vec2 invCtr = vec2(1);\n    float t = 1. / dot(p -invCtr, p - invCtr);\n    p = mix(invCtr, p, t);\n    p.x = -p.x;\n    p = rot2(iTime/12.)*p;\n\n    if (length(p) > 1.)\n        p /= dot(p, p);\n\n    float count = 0.;\n    for (int i = 0; i < MAX_TILING_REFLECTIONS; i++) {\n        if (p.x < 0.) {\n            p.x = -p.x;\n            count += 1.;\n        }\n        float k = dot(p, mB);\n        if (k < 0.) {\n            p -= 2. * k * mB;\n            count += 1.;\n        }\n        \n        float d = length(p - cen) - rad;\n        if (d < 0.) {\n            p -= cen;\n            p *= rad * rad / dot(p, p);\n            p += cen;\n            count += 1.;\n        }\n    }\n    \n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    ln = min(ln, lBox(p, vec2(0), v0, .007));    \n    ln = min(ln, lBox(p, vec2(0), m0, .007));\n    ln = min(ln, length(p - cen) - rad - 0.007);\n\n    ln2 = min(ln2, lBox(p, vec2(0), m0, .007));\n    pnt = min(pnt, length(p - v0)); \n    pnt = min(pnt, length(p - m0)); \n    \n    float sf = 2. / iResolution.y;\n    float rnd = smoothstep(.8, .97, sin(iTime*.5 + count)*.5 + .5);\n        \n    vec3 oCol = .55 + .45*cos(count * PI / 4. + vec3(0, 1, 2));\n    oCol = mix(oCol*.1, clamp(oCol*3.5, 0., 1.), rnd);\n     \n    float pat = smoothstep(0., .25, abs(fract(ln2*50. - .2) - .5)*2. -.2);\n   \n    float sh = clamp(.65 + ln/v0.y*4., 0., 1.);\n    vec3 col = min(oCol*(pat*.2 + .9)*sh, 1.);\n\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - BlackRegionSize)));\n\n    pnt -= .032;\n    pnt = min(pnt, length(p) - .032);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnt));\n    \n    rnd = smoothstep(.8, .97, sin(iTime * 1.5)*.5 + .5);\n    vec3 blink = vec3(1.3, 0.25, 0.35);\n    blink = mix(blink * 0.5, blink * 2.2, rnd);\n    col = mix(col, blink, 1. - smoothstep(0., sf, pnt + .02));\n    return col;\n}\n\nvec3 get_ceil_color(vec2 p) {\n    const float P = 3.;\n    const float Q = 3.;\n    const float R = 3.;\n    const float cp = cos(PI / P), sp = sin(PI / P);\n    const float cq = cos(PI / Q), cr = cos(PI / R);\n    const vec2 mB = vec2(-cp, sp);\n    const vec3 mC = vec3(-cr, -(cq + cr * cp) / sp, 1.);\n    const vec2 v0 = vec2(0, -1./mC.y);\n    const float k_ = mB.x / mB.y;\n    const float x_ = 1. / (k_ * mC.y - mC.x);\n    const float y_ = -k_ * x_;\n    const vec2 m0 = vec2(x_, y_);\n    \n    p = rot2(iTime/12.)*p;\n\n    float count = 0.;\n    for (int i = 0; i < MAX_TILING_REFLECTIONS; i++) {\n        if (p.x < 0.) {\n            p.x = -p.x;\n            count += 1.;\n        }\n        float k = dot(p, mB);\n        if (k < 0.) {\n            p -= 2. * k * mB;\n            count += 1.;\n        }\n        \n        k = dot(vec3(p, 1.), mC);\n        if (k < 0.) {\n            p -= 2. * k * mC.xy;\n            count += 1.;\n        }\n    }\n    \n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    //ln = min(ln, lBox(p, vec2(0), v0, .05));    \n    //ln = min(ln, lBox(p, vec2(0), m0, .05));\n    ln = min(ln, lBox(p, v0, m0, .05));\n\n    ln2 = min(ln2, lBox(p, vec2(0), m0, .007));\n    pnt = min(pnt, length(p - v0)); \n    pnt = min(pnt, length(p - m0)); \n    \n    float sf = 2. / iResolution.y;\n    float rnd = smoothstep(.8, .97, sin(iTime + count * PI)*.5 + .5);\n        \n    vec3 oCol = .55 + .45*cos(count * PI / 8. + vec3(0, 1, 2)).yzx;\n    oCol = mix(oCol*.1, clamp(oCol*1.5, 0., 1.), rnd);\n     \n    float pat = smoothstep(0., .25, abs(fract(ln2*15. - .2) - .5)*2. -.2);\n   \n    float sh = clamp(.65 + ln/v0.y*4., 0., 1.);\n    vec3 col = min(oCol*(pat*.2 + .9)*sh, 1.);\n\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - BlackRegionSize * 16.)));\n\n    pnt -= .15;\n    pnt = min(pnt, length(p) - .15);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnt));\n    \n    rnd = smoothstep(.4, .5, sin(iTime)*.5 + .5);\n    vec3 blink = vec3(1.3, 0.25, 0.35);\n    blink = mix(blink * 0.5, blink * 2.2, rnd);\n    col = mix(col, blink, 1. - smoothstep(0., sf, pnt + .02));\n    return col;\n}\n\n// distance to the four sides of mirrors \nfloat sdMirror(vec3 p) {\n    vec2 d = RoomSize.xz - abs(p.xz);\n    return min(d.x, d.y);\n}\n\n// the floor and the ceil\nfloat sdFloor(vec3 p) {\n    return RoomSize.y - abs(p.y);\n}\n\n// wood framework\nfloat sdRoomFrame(vec3 p) {\n    return sdBoxFrame(p, RoomSize, vec3(RoomFrameSize));\n}\n\nfloat sdMirrorFrame(vec3 p) {    \n    float d1 = sdBoxFrame(p, RoomSize, WindowFrameSize.xyy);\n    float d2 = sdBoxFrame(p, RoomSize, WindowFrameSize.yxy);\n    float d3 = sdBoxFrame(p, RoomSize, WindowFrameSize.yyx);\n    return min(d1, min(d2, d3));\n}\n\n// polyhedra with faces and edges\nvec2 sdPolyhedra(vec3 p) {\n    p *= RotObj;\n    p = fold_spherical(p);\n    p -= v0S;\n    float d1 = sdPolyhedraFaces(p);\n    float d2 = sdPolyhedraEdges(p);\n    float d = min(d1, d2);\n    float id = d1 < d2 ? 1. : 2.;\n    return vec2(d, id);\n}\n\nfloat sdScene(vec3 p) {\n    float d1 = sdMirror(p);\n    float d2 = sdFloor(p);\n    float d3 = sdRoomFrame(p);\n    float d4 = sdMirrorFrame(p);\n    float d5 = sdPolyhedra(p).x;\n    return min(d1, min(d2, min(d3, min(d4, d5))));\n}\n\nvec3 trace(vec3 pos, vec3 rd) {\n    float h = 1.0;\n    for (int i = 0; i < MAX_TRACE_STEPS; i++) {\n        if (h < PRECISION)\n            break;\n        h = sdScene(pos);\n        pos += rd * min(h, MAX_MARCH_STEP);\n    }\n    return pos;\n}\n\nfloat soft_shadow(vec3 pos, vec3 lp) {\n    const float softness = 16.;\n    const float shadowStartDistance = .1;\n    const int shadowLoopCount = 16;\n\n    vec3 ld = lp - pos;\n    float ldist = max(length(lp), 0.001);\n    ld /= ldist;\n    float epsilon = .001;\n    float t = shadowStartDistance;\n    float h = 1.;\n    float shade = 1.0;\n    for (int i=0; i < shadowLoopCount; i++ ) {\n        if (h < epsilon || t > ldist)\n            break;\n        h = sdScene(pos + ld * t);\n        shade = min(shade, smoothstep(0.0, 1.0, softness*h/t));\n        t += h;\n    }\n    return clamp(shade + 0.25, 0., 1.);\n}\n\nvec3 get_normal(vec3 p) {\n    const vec2 d = vec2(-1, 1) * .001;\n    return normalize(\n            sdScene(p + d.xxx)*d.xxx +\n            sdScene(p + d.yyx)*d.yyx +\n            sdScene(p + d.yxy)*d.yxy +\n            sdScene(p + d.xyy)*d.xyy);\n}\n\nstruct Light {\n    vec3 pos;\n    vec3 col;\n};\n\nLight lights[] = Light[] (\n    Light(vec3(2.5, 2.2, 2.5), vec3(1) * 5.),\n    Light(vec3(-1, -.5, -1), vec3(1)),\n    Light(vec3(-2.5,-1.9,-2.5), vec3(0, .3, 1))\n);\n\nvec4 wallColor(vec3 dir, vec3 nor, vec3 eds) {\n    float d = min3(eds.x, eds.y, eds.z);\n    \n    // Texturing of walls\n    vec3 albedo = texture(iChannel1, vec2(eds.xy * 2.0)).rgb;\n    albedo = pow(albedo, vec3(2.2)) * 0.5;\n    \n    // Simple diffuse lighting\n    float lighting = 0.2 + max(dot(nor, vec3(0.8, 0.5, 0.0)), 0.0);\n    \n    if (dot(dir, nor) < 0.0) {\n        // Outer walls, just add a black line to hide seams\n        float f = clamp(d * 1000.0 - 3.0, 0.0, 1.0);\n        albedo = mix(vec3(0.01), albedo, f);\n        return vec4(albedo * lighting, f);\n    } else {\n        // Inner walls, add fancy lights\n        float m = max3(eds.x, eds.y, eds.z);\n        vec2 a = fract(vec2(d, m) * 40.6) - 0.5;\n        float b = 1.0 - sqrt(dot(a, a));\n        b = 0.2 / (dot(a, a) + 0.2);\n        \n        float lightShape = 1.0 - clamp(d * 100.0 - 2.0, 0.0, 1.0);\n        lightShape *= b;\n        \n        vec3 emissive = vec3(3.5, 1.8, 1.0);\n        return vec4(mix(albedo * lighting, emissive, lightShape), 0.0);\n    }\n\treturn vec4(1.0);\n}\n\n\nvoid ray_bounce(in vec3 p,\n                in vec3 rd,\n                out vec3 diffuse,\n                out vec3 ref_dir,\n                out vec3 bounceTint,\n                in vec3 normal) {\n\n    vec3 bCol = vec3(0);\n    for( int i=0; i < lights.length(); i++ ) {\n        vec3 ld = lights[i].pos - p;\n        float ldist = max(length(ld), 0.001);\n        ld /= ldist;\n        float diff = max(0., dot(normal, ld));\n        float at = 1.5 / (1. + ldist * 0.3 + ldist * ldist * 0.1);\n        float sh = soft_shadow(p, lights[i].pos);\n        bCol += lights[i].col * sh * (.2 + diff) * at;\n    }\n    // ambient light\n    vec3 ao = vec3(.03,.05,.07);\n    // sample SDF to approximate occlusion\n    ao *= exp2(min(0., sdScene(p + normal * 0.3) / 0.3 - 1.));\n    ao *= exp2(min(0., sdScene(p + normal * .15) / .15 - 1.));\n    ao *= exp2(min(0., sdScene(p + normal * .07) / .07 - 1.));\n    bCol += ao;\n    \n    // https://www.shadertoy.com/view/tlBGR1\n    vec3 albedo = vec3(.3,.5,.6) * .4;\n    vec4 specLevel = vec4(0.9, 0.9, 0.9, 1);\n\n    float d1 = sdMirror(p);\n    float d2 = sdFloor(p);\n    float d3 = sdRoomFrame(p);\n    float d4 = sdMirrorFrame(p);\n    vec2 sdPoly = sdPolyhedra(p);\n    float d5 = sdPoly.x, id = sdPoly.y;\n    float d = min(d1, min(min(d2, d3), min(d4, d5)));\n    \n    if (d == d3) {  // room frame\n        albedo = vec3(.25);\n        specLevel = vec4(0.08);\n    }\n    else if (d == d4) {  // mirror border\n        albedo = vec3(0.01);\n        specLevel = vec4(0.2, 0.2, 0.2, 1.);\n    }\n    else if (d == d5) {  // polyhedra\n        if (id == 2.) {  // polyhedra edges\n            albedo = vec3(0.15, 0.3, 0.8);\n            specLevel = vec4(vec3(0.05), 1.);\n        }\n        else {  // polyhedra faces\n            specLevel = vec4(0.7);\n        }\n    }\n    else if (d == d2) {  // floor and ceil\n        vec2 uv = p.xz;\n        albedo = p.y < 0. ? get_floor_color(uv / (RoomSize.x - RoomFrameSize))\n                          : get_ceil_color(uv * 2.);\n        float ior = 1.33;\n        float schlick = pow((ior - 1.) / (ior + 1.), 2.);\n\t    specLevel = vec4(vec3(schlick), 1);\n    \tspecLevel *= mix(.2, .7, p.x);\n    \tnormal = normalize(normal + (texture(iChannel0, vec2(p.xz) /2.).rgb - .5) * .005);\n    }\n    \n    float fresnel = pow(dot(normal, rd) + 1., 5.);\n    vec3 spec = mix(specLevel.xyz, specLevel.www, fresnel);\n    \n    bounceTint = spec;\n    diffuse = albedo * (vec3(1) - spec) * bCol;\n    ref_dir = reflect(rd, normal);\n}\n\nvec3 get_ray_color(vec3 ro, vec3 rd) {\n    vec3 pos = ro;\n    vec3 tint = vec3(1);\n\n    vec3 col = vec3(0);\n    for (int i = 0; i < MAX_RAY_BOUNCES; i++) {\n        pos = trace(pos, rd);\n        vec3 normal = get_normal(pos);\n        vec3 bounceTint, diffuse;\n        ray_bounce(pos, rd, diffuse, rd, bounceTint, normal);\n        pos += normal * PRECISION * 2.;\n        col += diffuse * tint;\n        tint *= bounceTint;\n        if (length(tint) < .01)\n            break;\n    }\n    return col;\n}\n\nmat3 camera_matrix(vec3 eye, vec3 lookat, vec3 up) {\n    vec3 forward = normalize(lookat - eye);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    return mat3(right, up, -forward);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init_spherical();\n\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 movement = vec2(iTime * 0.2, sin(iTime * 0.2) * 0.5);\n    vec3 eye = 2.5 * vec3(\n        cos(movement.x) * cos(movement.y),\n        0.5*sin(movement.y),\n        sin(movement.x) * cos(movement.y));\n    eye += vec3(1, 0.3, 1) * cos(vec3(0.75, 0.3, 0.2) * iTime);\n   \n    vec2 mouse = vec2(0);\n    if (iMouse.x > 0.) {\n        mouse = 2. * iMouse.xy / iResolution.y - 1.;\n        eye = rot_y(mouse.x) * rot_x(mouse.y) * eye;\n    }\n    vec3 lookat = vec3(0);\n    vec3 up = vec3(0, 1, 0);\n    mat3 M = camera_matrix(eye, lookat, up);\n    \n    vec3 ray = M * normalize(vec3(uv, -2.));\n    vec3 col = get_ray_color(eye, ray);\n    fragColor = vec4(clamp(sqrt(col), 0., 1.), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI  3.141592654\n#define BlackRegionSize  0.03\n#define L2(x)  dot(x, x)\n#define RotObj  rot_x(iTime/2.)*rot_z(iTime/3.)\n#define PolyhedraEdgeSize  0.02\n#define PolyhedraFaceOffset  0.\n#define RoomSize  vec3(5, 2.5, 5)\n#define RoomFrameSize  0.5\n#define WindowFrameSize vec2(RoomFrameSize*1.2, 0)\n#define MAX_TILING_REFLECTIONS 12\n#define MAX_TRACE_STEPS  128\n#define MAX_RAY_BOUNCES  15\n#define PRECISION        1e-3\n#define MAX_MARCH_STEP   1.0\n#define min3(x, y, z)     (min(x, min(y, z)))\n#define max3(x, y, z)     (max(x, max(y, z)))\n\n\nconst vec3 pqr_wythoff = vec3(5, 2, 3);\nconst vec3 bary = vec3(1, 1, 1);\n\nmat3 matS, triS;\nvec3 v0S;\n\nvoid init_spherical() {\n    vec3 c = cos(PI / pqr_wythoff);\n    float sp = sin(PI / pqr_wythoff.x);\n    vec3 m1 = vec3(1, 0, 0);\n    vec3 m2 = vec3(-c.x, sp, 0);\n    float x3 = -c.z;\n    float y3 = -(c.y + c.x*c.z)/sp;\n    float z3 = sqrt(1.0 - x3*x3 - y3*y3);\n    vec3 m3 = vec3(x3, y3, z3);\n    matS = mat3(m1, m2, m3);\n    triS[0] = normalize(cross(m2, m3));\n    triS[1] = normalize(cross(m3, m1));\n    triS[2] = normalize(cross(m1, m2));\n    v0S = normalize(bary * inverse(matS));\n}\n\nvec3 fold_spherical(vec3 p) {\n    for (int i = 0; i < 5; i++)\n    for (int j = 0; j < 3; j++) {\n        p -= 2. * min(dot(p, matS[j]), 0.) * matS[j];\n    }\n    return p;\n}\n\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n ) {\n    n = max(n * n, 0.001);\n    n /= (n.x + n.y + n.z ); \n\treturn (\n        texture(tex, p.yz) * n.x +\n        texture(tex, p.zx) * n.y +\n        texture(tex, p.xy) * n.z\n    ).xyz;\n}\n\nmat2 rot2(in float a) {\n    float c = cos(a), s = sin(a); return mat2(c, -s, s, c);\n}\n\nmat3 rot_x(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0,  0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\nmat3 rot_y(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n}\n\nmat3 rot_z(in float t) {\n    float cz = cos(t), sz = sin(t);\n    return mat3(cz, -sz, 0.,\n                sz, cz, 0.,\n                0., 0., 1.);\n}\n\nfloat sBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew) {\n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n// https://www.shadertoy.com/view/3ljcRh\n// I changed e to vec3 so it works for non-uniform edge size\nfloat sdBoxFrame(vec3 p, vec3 b, vec3 e) {\n    p = abs(p) - b;\n    vec3 q = abs(p + e) - e;\n    return min(min(\n        length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n        length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n        length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdPolyhedraEdges(vec3 p) {\n    float d = 1e5;\n    for (int i = 0; i < 3; i++) {\n        d = min(d, L2(p - min(0., dot(p, matS[i])) * matS[i]));\n    }\n\treturn sqrt(d) - PolyhedraEdgeSize;\n}\n\nfloat sdPolyhedraFaces(vec3 p) {\n   return max(dot(p, triS[0]), max(dot(p, triS[1]), dot(p, triS[2]))) - PolyhedraFaceOffset;\n}\n\n//complex multiplication\nvec2 cMul(vec2 a, vec2 b) {\n\treturn vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\n// complex inverse \nvec2 cDiv( vec2 a, vec2 b ) {\n  float d = dot(b, b);\n  return vec2(dot(a, b), a.y*b.x - a.x*b.y ) / d;\n}\n\n// complex inverse \nvec2 cInv(vec2 a) {\n\treturn vec2(a.x, -a.y) / dot(a, a);\n}\n\n// code below taken from @mla's https://www.shadertoy.com/view/Mlsfzs\nvoid sncndn(float u, float k2,\n            out float sn, out float cn, out float dn) {\n    float emc = 1.0 - k2;\n    float a = 1.0, b, c;\n    const int N = 4;\n    float em[N], en[N];\n    dn = 1.0;\n    for (int i = 0; i < N; i++) {\n        em[i] = a;\n        emc = sqrt(emc);\n        en[i] = emc;\n        c = 0.5*(a + emc);\n        emc *= a;\n        a = c;\n    }\n\n    u = c*u;\n    sn = sin(u);\n    cn = cos(u);\n    if (sn != 0.0) {\n        a = cn / sn;\n        c *= a;\n        for(int i = N - 1; i >= 0; i--) {\n            b = em[i];\n            a *= c;\n            c *= dn;\n            dn = (en[i] + a) / (b + a);\n            a = c/b;\n        }\n        a = 1.0 / sqrt(c*c + 1.0);\n        if (sn < 0.0)\n            sn = -a;\n        else\n            sn = a;\n        cn = c * sn;\n    }\n}\n\nvec2 cn(vec2 z, float k2) {\n  float snu, cnu, dnu, snv, cnv, dnv;\n  sncndn(z.x, k2, snu, cnu, dnu);\n  sncndn(z.y, 1.0-k2, snv, cnv, dnv);\n  return vec2(cnu * cnv, -snu*dnu*snv*dnv) / (1. - dnu*dnu*snv*snv);\n}\n\nvec2 square_to_disc(vec2 z) {     \n    z = cDiv(z, vec2(1));\n    z -= vec2(1, 0);\n    z *= 1.854;\n    z = cn(z, 0.5);\n    z = cMul(z, vec2(0.70711));\n    return z;\n}","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"ddGXDy","date":"0","viewed":0,"name":"my fork Simple & Cheap Die SDF","username":"neozhaoliang","description":"A simple SDF for a die with the correct mappings of dots to faces. Although it has a lot of branches, it's cheap in the way that it makes use of symmetries of the dots and faces instead of using loops and arrays of coordinates.","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Simple & Cheap Die SDF\" by fizzer. https://shadertoy.com/view/csySDG\n// 2023-04-15 03:34:19\n\n// Distance to hemisphere-shaped hole in a plane.\nfloat hole(vec3 p, float r)\n{\n    float c = min(0., length(p.xz) - r);\n    return (p.y > 0.) ? length(vec2(c, p.y)) : r - length(p);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// Die SDF.\nfloat die(vec3 p)\n{\n    // Get index of closest face on die, and local point b.\n    vec3 q = abs(p);\n\n    bvec3 dots = sign(p.z) > 0. ? bvec3(false, true, true) : bvec3(true, true, false);\n    vec3 b = p.xzy * sign(p.z);\n\n    if(q.x > q.y && q.x > q.z)\n    {\n        b = p.zxy * sign(p.x);\n        b.z = -b.z;\n        dots = sign(p.x) > 0. ? bvec3(false, true, false) : bvec3(true, true, true);\n    }\n    else if(q.y > q.z)\n    {\n        b = p.zyx * sign(p.y);\n        dots = sign(p.y) > 0. ? bvec3(false, false, true) : bvec3(false, false, false);\n    }\n    \n    // Some parameteric constants.\n    float r = .02, r2 = .04 ,r3 = .13;\n\n    b.y -= .5 - r;\n    \n    float d;\n\n    if(all(not(dots)))\n    {\n        // Special case for side 6.\n        b.x = abs(b.x);\n        b.z = mod(b.z + .3 / 2., .3) - .3 / 2.;\n        d = hole(b - vec3(.2, 0, 0), r3);\n    }\n    else\n    {\n        // The sides other than 6 have reflective symmetry in two lines.\n        if(b.x > -b.z)\n            b.xz = -b.zx;\n\n        if(b.x > b.z)\n            b.xz = b.zx;\n\n        // Thanks to this symmetry, the presence of only three dots account\n        // for all of the sides. So the effective LUT contains 3 bits per face.\n        if(b.z - b.x > .25)\n            d = dots.y ? hole(b - vec3(-1, 0, +1) / 4., r3) : b.y;\n        else if(-b.x - b.z > .25)\n            d = dots.x ? hole(b - vec3(-1, 0, -1) / 4., r3) : b.y;\n        else\n            d = dots.z ? hole(b, r3): b.y;\n    }\n    \n    // Use sdRoundBox to bevel the outer edges of the die.\n    return max(d - r, sdRoundBox(p, vec3(.5) - r2, r2));\n}\n\nfloat dist(vec3 p)\n{\n    return die(p);\n}\n\nvec3 norm(vec3 p)\n{\n    // The usual.\n    vec3 e = vec3(1e-4, 0, 0);\n    float d = dist(p);\n    return normalize(vec3(dist(p + e.xyy), dist(p + e.yxy), dist(p + e.yyx)) - d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    // Camera position and target.\n    vec3 campos = vec3(cos(iTime) * 2., sin(iTime / 2.) * 2., sin(iTime) * 2.);\n    \n    if(iMouse.z > 0.)\n    {\n        float u = -iMouse.x / iResolution.x * 6.;\n        float v = -(iMouse.y - iResolution.y / 2.) / iResolution.y * 3.;\n        campos = vec3(cos(u) * 2., v, sin(u) * 2.);\n    }\n    \n    vec3 camtarget = vec3(0);\n\tvec3 ro = campos, rd = normalize(vec3(uv, 1.));\n    \n    // Camera lookat.\n    vec3 w = normalize(camtarget - campos);\n    vec3 u = normalize(cross(vec3(0, 1, 0), w));\n    vec3 v = cross(w, u);\n    rd = mat3(u, v, w) * rd;\n    \n    float t = 0.;\n    for(int i = 0; i < 100; ++i)\n    {\n        float d = dist(ro + rd * t);\n        if(abs(d) < 1e-4 || t > 10.)\n            break;\n        t += d;\n    }\n\n    vec3 rp = ro + rd * t;\n    vec3 col = vec3(.12);\n        \n    if(t < 10.)\n    {\n        // Typical lighting and shading.\n        vec3 l = normalize(vec3(1, 2, 1.5));\n        vec3 n = norm(rp);\n        vec3 baseColour = mix(vec3(0), vec3(1), smoothstep(.01, .02, sdRoundBox(rp, vec3(.38), .1)));\n        vec3 rr = reflect(rd, n);\n        vec3 spec = textureLod(iChannel0, rr, 1.).rgb;\n        vec3 diff = vec3(0.5 + 0.5 * dot(n, l)) + vec3(0.5 + 0.5 * -n.y) * vec3(.1, .1, .2) * 1.5;\n        float fresnel = mix(0.01, .4, pow(clamp(1. + dot(rd, n), 0., 1.), 2.));\n\n        col = mix(baseColour * diff, spec, fresnel);\n    }\n\n    // Output and gamma correction.\n    fragColor = vec4(pow(col, vec3(1. / 2.2)), 1.);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"tlKcRw","date":"0","viewed":0,"name":"polytestt","username":"neozhaoliang","description":"test","likes":0,"published":0,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Robert Śmietana (Logos) - 11.03.2020\n// Bielsko-Biała, Poland, UE, Earth, Sol, Milky Way, Local Group, Laniakea :)\n\n// 2d rotation\nvec2 rot2d(vec2 p, float a) { return cos(a) * p + sin(a) * vec2(p.y, -p.x); }\n\nvoid rot4d(inout vec4 p)\n{\n    p.xy = rot2d(p.xy, iTime*0.2);\n    p.zw = rot2d(p.zw, iTime*0.2);\n}\n\n\n\n//--- camera stuff ---//\n\nmat3 setCamera(in vec3 ro, in vec3 ta)\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(0.0, 1.0, sin(0.59*iTime));\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\n    return mat3(cu, cv, cw);\n}\n\n\n//--- scene description ---//\n\nfloat distanceToScene(vec3 p)\n{\n    float r = length(p);\n    vec4 q = vec4(2.*p, 1.-r*r) / (1.+r*r);\n    rot4d(q);\n    bool found = fold(q);\n    if (found) {\n        float id;\n        float dvert = dVertex(q, r);\n        float dedge = dSegments(q, r, id);\n        id = (dvert < dedge) ? 4. : id;\n        return min(dvert, dedge);\n        }\n        return 1e5;\n}\n\n\n//--- cheap normal computing ---//\n\nvec3 computeSurfaceNormal(vec3 p)\n{\n    float d = distanceToScene(p);\n    \n    return normalize(vec3(\n        distanceToScene(p + vec3(0.001, 0.0, 0.0)) - d,\n        distanceToScene(p + vec3(0.0, 0.001, 0.0)) - d,\n        distanceToScene(p + vec3(0.0, 0.0, 0.001)) - d));\n}\n\n\n//--- output color ---//\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\ninit();\n    \n    //--- camera setup ---//\n    \n    float rtime = 0.35*iTime;\n    \n    vec2 p   = (-iResolution.xy + 2.0*fragCoord - 1.0) / iResolution.y;\n \tvec3 pos = vec3(5.0 + 5.0*cos(rtime), 10.0*cos(1.2*rtime), 6.0 + 5.0*sin(0.78*rtime));\n    vec3 tar = vec3(0.0);\n    vec3 dir = setCamera(pos, tar) * normalize(vec3(p.xy, 6.));  \n    \n    \n    //--- distance to nearest object in the scene ---//\n    \n\tfloat t = 0.0;\n\tfor(int i = 0; i < 210; i++)\n    {\n\t\tfloat d = distanceToScene(pos + t*dir);\n\t\tif(d < 0.003) break;\n        \n\t\tt += d;\n\n        \n\t\t//--- early skip of background pixels ---//\n    \n        if (t > 27.0)\n        {\n            fragColor = vec4(0.0);\n            return;\n        }\n\t}\n    \n    \n    //--- output color depends on few things ---//\n    \n    vec3  sn = computeSurfaceNormal(pos + t*dir);\t\t\t// surface normal\n    float dc = clamp(dot(sn, normalize(pos)), 0.0, 1.0);\t// diffuse component\n    float sr = pow(dc, 100.0);\t\t\t\t\t\t\t\t// specular reflection\n    float od = length(pos + t*dir);\t\t\t\t\t\t\t// distance to origin\n    \n\tfragColor     = abs(dir.xzyz);\n    fragColor    *= 0.2 + 0.8*dc;\n    fragColor.yz *= clamp(od, 0.0, 1.0);\n    fragColor    += sr;\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI    3.141592653\nconst float[6] diagram = float[6](3.0, 2.0, 2.0, 3.0, 2.0, 5.0);\n\n// active mirrors, 1 for active, 0 for non-active. This determines the position\n// of the initial vertex hence the truncation type of the honeycomb.\nconst vec4 active_mirrors = vec4(1.0, 0.0, 0.0, 0.0);\n\n// normal vectors of the four mirrors\nmat4 M;\n\n// the initial vertex\nvec4 v0;\n\n// size of the vertex and segments\nconst float vradius = 0.035;\nconst float sradius = 0.01;\n\nfloat cvr = cos(vradius), svr = sin(vradius);\nfloat csr = cos(sradius), ssr = sin(sradius);\n\n// reflection about a plane with normal `n`\nfloat ref(inout vec4 p, in vec4 n)\n{\n    float k = min(0., dot(p, n));\n    p -= 2. * k * n;\n    return k;\n}\n\n\n\nfloat knightyDD(float ca, float sa, float r)\n{\n    float x = 1. - r * r;\n    float y = 2. - x;\n    return r - (2. * r * ca - x * sa) / (x * ca + 2. * r * sa + y);\n}\n\n\nvoid init()\n{\n    // Cartan matrix of the Coxeter group:\n    // ( -1  c01  c02  c03)\n    // (c01   -1  c12  c13)\n    // (c02  c12   -1  c23)\n    // (c03  c13  c23   -1)\n    // cij = -cos(PI / (Coxeter label bewteen i-th and j-th mirror))\n    float c01 = -cos(PI / diagram[0]);\n    float c02 = -cos(PI / diagram[1]);\n    float c03 = -cos(PI / diagram[2]);\n    float c12 = -cos(PI / diagram[3]);\n    float c13 = -cos(PI / diagram[4]);\n    float c23 = -cos(PI / diagram[5]);\n\n    vec4 A, B, C, D;\n    // find the reflection mirrors A, B, C, D.\n    // A can be always chosen as x-axis\n    A = vec4(1., 0., 0., 0.);\n    B = vec4(c01, sqrt(1. - c01*c01), 0., 0.);\n    C = vec4(c02, 0., 0., 0.);\n    C.y = (c12 - C.x * B.x) / B.y;\n    C.z = sqrt(abs(1. - dot(C.xy, C.xy))); // avoid rounding error in paracompact case\n    D = vec4(c03, 0., 0., 0.);\n    D.y = (c13 - D.x * B.x) / B.y;\n    D.z = (c23 - dot(D.xy, C.xy) ) / C.z;\n    D.w = -sqrt(abs(1. - dot(D.xyz, D.xyz))); // !important: - sign is used here\n\n    M = mat4(A, B, C, D);\n    v0 = normalize(active_mirrors * inverse(M));\n    \n}\n\n// fold a point p in 4d up to a given maximum of steps, return true if\n// we successfully transformed p into the fundamental domain else return false.\nbool fold(inout vec4 p)\n{\n    float k;\n    for(int i=0; i<20; i++)\n    {\n        k = 0.;\n        p.x = abs(p.x);\n        k += ref(p, M[1]);\n        k += ref(p, M[2]);\n        k += ref(p, M[3]);\n        // break as soon as we find it's already in the fundamental domain\n        if(k == 0.) return true;\n    }\n    return false;\n}\n\n// if distance between p and q is a, C is a circle with radius VR centered at q,\n// then the distance from p to C is a - VR, hence\n// cosh(a - VR) = cosh(a)cosh(VR) - sinh(a)sinh(VR)\n// sinh(a - VR) = sinh(a)cosh(VR) - cosh(a)sinh(VR)\nfloat dVertex(vec4 p, float r)\n{\n    float ca = dot(p, v0);\n    float sa = 0.5 * length(p-v0) * length(p+v0);\n    return knightyDD(ca * cvr + sa * svr, sa * cvr - ca * svr, r);\n}\nfloat dSegment(vec4 p, vec4 n, float r)\n{\n    float pn = dot(p, n);\n    float pv = dot(p, v0);\n    float nv = dot(n, v0);\n\n    float a = pv - pn*nv;\n    float b = pn - pv*nv;\n    vec4 pj = normalize(min(b, 0.) * n + a * v0);\n    float ca = dot(p, pj);\n    float sa = 0.5 * sqrt(1.-ca*ca);\n    return knightyDD(ca * csr + sa * ssr, sa * csr - ca * ssr, r);\n}\n\nfloat dSegments(vec4 p, float r, inout float index)\n{\n    float d = 1.0;\n    for(int i=0; i<4; i++)\n    {\n        float dseg = dSegment(p, M[i], r);\n        if (dseg < d)\n        {\n            d = dseg;\n            index = float(i);\n        }\n    }\n    return d;\n}\n","name":"Common","description":"","type":"common"}]}]